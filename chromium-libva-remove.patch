From c13a597516f19a1c7489b342cd8198ea173d5b68 Mon Sep 17 00:00:00 2001
From: Alexandre Courbot <acourbot@chromium.org>
Date: Sun, 23 Jul 2017 03:48:48 +0000
Subject: [PATCH] Remove third_party/libva

There is no need to carry a copy of the libva headers when they are
supposed to be present on the system anyway (since we are linking
against the system library).

Relying on the system headers also reduces the risk of ABI mismatch,
and makes updating libva easier since it only needs to be done on the
system side.

Since the headers are removed, we must now make sure that the compiler
will not meet them in cases where they are irrelevant. To this end, add
a use_vaapi GN variable and USE_VAAPI compiler variable that control
whether VA-API related code will be included.

BUG=742069
TEST=Did two builds with use_vaapi set to true and false in the gn args.
Confirmed that VA-API related files were only compiled in the case
use_vaapi is true. Also confirmed that the video decode, video encode,
and jpeg decode accelerator unittests compiled in both cases and that the
tests actually use the VA-API when use_vaapi is defined.

Cq-Include-Trybots: master.tryserver.chromium.android:android_optional_gpu_tests_rel;master.tryserver.chromium.linux:linux_optional_gpu_tests_rel;master.tryserver.chromium.mac:mac_optional_gpu_tests_rel;master.tryserver.chromium.win:win_optional_gpu_tests_rel
Change-Id: Id4b8dbe31856344824023563d369735989562e82
Reviewed-on: https://chromium-review.googlesource.com/569529
Commit-Queue: Alexandre Courbot <acourbot@chromium.org>
Reviewed-by: Nico Weber <thakis@chromium.org>
Reviewed-by: Pawel Osciak <posciak@chromium.org>
Reviewed-by: Pawe≈Ç Hajdan Jr. <phajdan.jr@chromium.org>
Reviewed-by: Richard Coles <torne@chromium.org>
Reviewed-by: Kenneth Russell <kbr@chromium.org>
Cr-Commit-Position: refs/heads/master@{#488877}
---

diff --git a/content/gpu/BUILD.gn b/content/gpu/BUILD.gn
index f029ee6..a5424bb 100644
--- a/content/gpu/BUILD.gn
+++ b/content/gpu/BUILD.gn
@@ -103,10 +103,6 @@
     ]
   }
 
-  if (is_chromeos && current_cpu != "arm") {
-    configs += [ "//third_party/libva:libva_config" ]
-  }
-
   if (use_x11) {
     deps += [ "//ui/events/platform/x11" ]
   }
diff --git a/content/gpu/gpu_main.cc b/content/gpu/gpu_main.cc
index 2513826..4b87a8c 100644
--- a/content/gpu/gpu_main.cc
+++ b/content/gpu/gpu_main.cc
@@ -38,6 +38,7 @@
 #include "gpu/ipc/service/gpu_config.h"
 #include "gpu/ipc/service/gpu_init.h"
 #include "gpu/ipc/service/gpu_watchdog_thread.h"
+#include "media/gpu/features.h"
 #include "ui/events/platform/platform_event_source.h"
 #include "ui/gfx/switches.h"
 #include "ui/gl/gl_context.h"
@@ -84,7 +85,7 @@
 #include "ui/ozone/public/ozone_platform.h"
 #endif
 
-#if defined(OS_CHROMEOS) && defined(ARCH_CPU_X86_FAMILY)
+#if BUILDFLAG(USE_VAAPI)
 #include "media/gpu/vaapi_wrapper.h"
 #endif
 
@@ -135,7 +136,7 @@
       (void)base::RandUint64();
     }
 
-#if defined(OS_CHROMEOS) && defined(ARCH_CPU_X86_FAMILY)
+#if BUILDFLAG(USE_VAAPI)
     media::VaapiWrapper::PreSandboxInitialization();
 #endif
 #if defined(OS_WIN)
diff --git a/media/gpu/BUILD.gn b/media/gpu/BUILD.gn
index 00802b7..3a65c75 100644
--- a/media/gpu/BUILD.gn
+++ b/media/gpu/BUILD.gn
@@ -2,12 +2,19 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//build/buildflag_header.gni")
 import("//build/config/features.gni")
 import("//build/config/ui.gni")
 import("//media/gpu/args.gni")
 import("//media/media_options.gni")
 import("//testing/test.gni")
 
+buildflag_header("features") {
+  header = "features.h"
+
+  flags = [ "USE_VAAPI=$use_vaapi" ]
+}
+
 declare_args() {
   # A temporary arg for building MCVD while it's being implemented.
   # See http://crbug.com/660942
@@ -18,7 +25,7 @@
   import("//build/config/mac/mac_sdk.gni")
 }
 
-if (is_chromeos && current_cpu != "arm") {
+if (use_vaapi) {
   action("libva_generate_stubs") {
     extra_header = "va_stub_header.fragment"
 
@@ -152,6 +159,7 @@
   ]
 
   public_deps = [
+    ":features",
     "//base",
     "//gpu",
     "//media",
@@ -274,6 +282,8 @@
         "v4l2_device.h",
         "v4l2_image_processor.cc",
         "v4l2_image_processor.h",
+        "v4l2_jpeg_decode_accelerator.cc",
+        "v4l2_jpeg_decode_accelerator.h",
         "v4l2_slice_video_decode_accelerator.cc",
         "v4l2_slice_video_decode_accelerator.h",
         "v4l2_video_decode_accelerator.cc",
@@ -289,51 +299,47 @@
         sources += [
           "tegra_v4l2_device.cc",
           "tegra_v4l2_device.h",
-          "v4l2_jpeg_decode_accelerator.cc",
-          "v4l2_jpeg_decode_accelerator.h",
         ]
       }
     }
-    if (current_cpu != "arm") {
+  }
+
+  if (use_vaapi) {
+    sources += [
+                 "va_surface.h",
+                 "vaapi_jpeg_decode_accelerator.cc",
+                 "vaapi_jpeg_decode_accelerator.h",
+                 "vaapi_jpeg_decoder.cc",
+                 "vaapi_jpeg_decoder.h",
+                 "vaapi_picture.cc",
+                 "vaapi_picture.h",
+                 "vaapi_video_decode_accelerator.cc",
+                 "vaapi_video_decode_accelerator.h",
+                 "vaapi_video_encode_accelerator.cc",
+                 "vaapi_video_encode_accelerator.h",
+                 "vaapi_wrapper.cc",
+                 "vaapi_wrapper.h",
+               ] + get_target_outputs(":libva_generate_stubs")
+    configs += [ "//third_party/libyuv:libyuv_config" ]
+    deps += [
+      ":libva_generate_stubs",
+      "//media",
+      "//third_party/libyuv",
+    ]
+    if (use_x11) {
+      configs += [ "//build/config/linux:x11" ]
+      deps += [ "//ui/gfx/x" ]
       sources += [
-                   "va_surface.h",
-                   "vaapi_jpeg_decode_accelerator.cc",
-                   "vaapi_jpeg_decode_accelerator.h",
-                   "vaapi_jpeg_decoder.cc",
-                   "vaapi_jpeg_decoder.h",
-                   "vaapi_picture.cc",
-                   "vaapi_picture.h",
-                   "vaapi_video_decode_accelerator.cc",
-                   "vaapi_video_decode_accelerator.h",
-                   "vaapi_video_encode_accelerator.cc",
-                   "vaapi_video_encode_accelerator.h",
-                   "vaapi_wrapper.cc",
-                   "vaapi_wrapper.h",
-                 ] + get_target_outputs(":libva_generate_stubs")
-      configs += [
-        "//third_party/libva:libva_config",
-        "//third_party/libyuv:libyuv_config",
+        "vaapi_tfp_picture.cc",
+        "vaapi_tfp_picture.h",
       ]
-      deps += [
-        ":libva_generate_stubs",
-        "//media",
-        "//third_party/libyuv",
+    }
+    if (use_ozone) {
+      deps += [ "//ui/ozone" ]
+      sources += [
+        "vaapi_drm_picture.cc",
+        "vaapi_drm_picture.h",
       ]
-      if (use_x11) {
-        configs += [ "//build/config/linux:x11" ]
-        deps += [ "//ui/gfx/x" ]
-        sources += [
-          "vaapi_tfp_picture.cc",
-          "vaapi_tfp_picture.h",
-        ]
-      }
-      if (use_ozone) {
-        deps += [ "//ui/ozone" ]
-        sources += [
-          "vaapi_drm_picture.cc",
-          "vaapi_drm_picture.h",
-        ]
-      }
     }
   }
 
@@ -412,9 +418,6 @@
       "//third_party/khronos:khronos_headers",
       ":gpu_config",
     ]
-    if (is_chromeos && current_cpu != "arm") {
-      configs += [ "//third_party/libva:libva_config" ]
-    }
 
     if (is_win || is_chromeos) {
       sources += [
@@ -513,7 +516,6 @@
       "//ui/gl:test_support",
     ]
     configs += [
-      "//third_party/libva:libva_config",
       "//third_party/libyuv:libyuv_config",
       ":gpu_config",
     ]
@@ -547,7 +549,6 @@
       "//ui/gl:test_support",
     ]
     configs += [
-      "//third_party/libva:libva_config",
       "//third_party/libyuv:libyuv_config",
       ":gpu_config",
     ]
diff --git a/media/gpu/DEPS b/media/gpu/DEPS
index d96abca..cb7766c 100644
--- a/media/gpu/DEPS
+++ b/media/gpu/DEPS
@@ -1,7 +1,6 @@
 # Do NOT add net/ or ui/base without a great reason, they're huge!
 include_rules = [
   "+third_party/angle",
-  "+third_party/libva",
   "+third_party/libyuv",
   "+third_party/v4l-utils",
   "+third_party/webrtc/common_video",
diff --git a/media/gpu/args.gni b/media/gpu/args.gni
index 0c4f3316..df4b0f9 100644
--- a/media/gpu/args.gni
+++ b/media/gpu/args.gni
@@ -10,6 +10,7 @@
   # platforms which have v4l2 hardware encoder / decoder.
   use_v4l2_codec = false
 
-  # Indicates if VA-API-based hardware acceleration is to be used.
+  # Indicates if VA-API-based hardware acceleration is to be used. This
+  # is typically the case on x86-based ChromeOS devices.
   use_vaapi = false
 }
diff --git a/media/gpu/gpu_video_decode_accelerator_factory.cc b/media/gpu/gpu_video_decode_accelerator_factory.cc
index f74e62e..b440d26 100644
--- a/media/gpu/gpu_video_decode_accelerator_factory.cc
+++ b/media/gpu/gpu_video_decode_accelerator_factory.cc
@@ -5,8 +5,10 @@
 #include "media/gpu/gpu_video_decode_accelerator_factory.h"
 
 #include "base/memory/ptr_util.h"
+#include "build/build_config.h"
 #include "gpu/command_buffer/service/gpu_preferences.h"
 #include "media/base/media_switches.h"
+#include "media/gpu/features.h"
 #include "media/gpu/gpu_video_accelerator_util.h"
 #include "media/gpu/media_gpu_export.h"
 
@@ -23,16 +25,16 @@
 #include "media/gpu/v4l2_video_decode_accelerator.h"
 #include "ui/gl/gl_surface_egl.h"
 #endif
-#if defined(ARCH_CPU_X86_FAMILY)
-#include "media/gpu/vaapi_video_decode_accelerator.h"
-#include "ui/gl/gl_implementation.h"
-#endif
 #elif defined(OS_ANDROID)
 #include "media/gpu/android/device_info.h"
 #include "media/gpu/android_video_decode_accelerator.h"
 #include "media/gpu/android_video_surface_chooser_impl.h"
 #include "media/gpu/avda_codec_allocator.h"
 #endif
+#if BUILDFLAG(USE_VAAPI)
+#include "media/gpu/vaapi_video_decode_accelerator.h"
+#include "ui/gl/gl_implementation.h"
+#endif
 
 namespace media {
 
@@ -87,9 +89,9 @@
   capabilities.supported_profiles =
       DXVAVideoDecodeAccelerator::GetSupportedProfiles(gpu_preferences,
                                                        workarounds);
-#elif defined(OS_CHROMEOS)
+#elif defined(OS_CHROMEOS) || BUILDFLAG(USE_VAAPI)
   VideoDecodeAccelerator::SupportedProfiles vda_profiles;
-#if defined(USE_V4L2_CODEC)
+#if defined(OS_CHROMEOS) && defined(USE_V4L2_CODEC)
   vda_profiles = V4L2VideoDecodeAccelerator::GetSupportedProfiles();
   GpuVideoAcceleratorUtil::InsertUniqueDecodeProfiles(
       vda_profiles, &capabilities.supported_profiles);
@@ -97,7 +99,7 @@
   GpuVideoAcceleratorUtil::InsertUniqueDecodeProfiles(
       vda_profiles, &capabilities.supported_profiles);
 #endif
-#if defined(ARCH_CPU_X86_FAMILY)
+#if BUILDFLAG(USE_VAAPI)
   vda_profiles = VaapiVideoDecodeAccelerator::GetSupportedProfiles();
   GpuVideoAcceleratorUtil::InsertUniqueDecodeProfiles(
       vda_profiles, &capabilities.supported_profiles);
@@ -140,7 +142,7 @@
     &GpuVideoDecodeAcceleratorFactory::CreateV4L2VDA,
     &GpuVideoDecodeAcceleratorFactory::CreateV4L2SVDA,
 #endif
-#if defined(OS_CHROMEOS) && defined(ARCH_CPU_X86_FAMILY)
+#if BUILDFLAG(USE_VAAPI)
     &GpuVideoDecodeAcceleratorFactory::CreateVaapiVDA,
 #endif
 #if defined(OS_MACOSX)
@@ -221,7 +223,7 @@
 }
 #endif
 
-#if defined(OS_CHROMEOS) && defined(ARCH_CPU_X86_FAMILY)
+#if BUILDFLAG(USE_VAAPI)
 std::unique_ptr<VideoDecodeAccelerator>
 GpuVideoDecodeAcceleratorFactory::CreateVaapiVDA(
     const gpu::GpuDriverBugWorkarounds& workarounds,
diff --git a/media/gpu/gpu_video_decode_accelerator_factory.h b/media/gpu/gpu_video_decode_accelerator_factory.h
index d54230c..819569b 100644
--- a/media/gpu/gpu_video_decode_accelerator_factory.h
+++ b/media/gpu/gpu_video_decode_accelerator_factory.h
@@ -13,6 +13,7 @@
 #include "gpu/config/gpu_driver_bug_workarounds.h"
 #include "gpu/config/gpu_info.h"
 #include "media/base/android_overlay_mojo_factory.h"
+#include "media/gpu/features.h"
 #include "media/gpu/media_gpu_export.h"
 #include "media/video/video_decode_accelerator.h"
 
@@ -105,7 +106,7 @@
       const gpu::GpuDriverBugWorkarounds& workarounds,
       const gpu::GpuPreferences& gpu_preferences) const;
 #endif
-#if defined(OS_CHROMEOS) && defined(ARCH_CPU_X86_FAMILY)
+#if BUILDFLAG(USE_VAAPI)
   std::unique_ptr<VideoDecodeAccelerator> CreateVaapiVDA(
       const gpu::GpuDriverBugWorkarounds& workarounds,
       const gpu::GpuPreferences& gpu_preferences) const;
diff --git a/media/gpu/gpu_video_encode_accelerator_factory.cc b/media/gpu/gpu_video_encode_accelerator_factory.cc
index 873b64a..d1b8ff3 100644
--- a/media/gpu/gpu_video_encode_accelerator_factory.cc
+++ b/media/gpu/gpu_video_encode_accelerator_factory.cc
@@ -5,15 +5,14 @@
 #include "media/gpu/gpu_video_encode_accelerator_factory.h"
 
 #include "base/memory/ptr_util.h"
+#include "build/build_config.h"
+#include "media/gpu/features.h"
 #include "media/gpu/gpu_video_accelerator_util.h"
 
 #if defined(OS_CHROMEOS)
 #if defined(USE_V4L2_CODEC)
 #include "media/gpu/v4l2_video_encode_accelerator.h"
 #endif
-#if defined(ARCH_CPU_X86_FAMILY)
-#include "media/gpu/vaapi_video_encode_accelerator.h"
-#endif
 #elif defined(OS_ANDROID) && BUILDFLAG(ENABLE_WEBRTC)
 #include "media/gpu/android_video_encode_accelerator.h"
 #elif defined(OS_MACOSX)
@@ -23,6 +22,9 @@
 #include "media/base/media_switches.h"
 #include "media/gpu/media_foundation_video_encode_accelerator_win.h"
 #endif
+#if BUILDFLAG(USE_VAAPI)
+#include "media/gpu/vaapi_video_encode_accelerator.h"
+#endif
 
 namespace media {
 
@@ -37,7 +39,7 @@
 }
 #endif
 
-#if defined(OS_CHROMEOS) && defined(ARCH_CPU_X86_FAMILY)
+#if BUILDFLAG(USE_VAAPI)
 std::unique_ptr<VideoEncodeAccelerator> CreateVaapiVEA() {
   return base::WrapUnique<VideoEncodeAccelerator>(
       new VaapiVideoEncodeAccelerator());
@@ -76,7 +78,7 @@
 #if defined(OS_CHROMEOS) && defined(USE_V4L2_CODEC)
   vea_factory_functions.push_back(&CreateV4L2VEA);
 #endif
-#if defined(OS_CHROMEOS) && defined(ARCH_CPU_X86_FAMILY)
+#if BUILDFLAG(USE_VAAPI)
   if (!gpu_preferences.disable_vaapi_accelerated_video_encode)
     vea_factory_functions.push_back(&CreateVaapiVEA);
 #endif
diff --git a/media/gpu/ipc/service/BUILD.gn b/media/gpu/ipc/service/BUILD.gn
index abb8396..c62c7be 100644
--- a/media/gpu/ipc/service/BUILD.gn
+++ b/media/gpu/ipc/service/BUILD.gn
@@ -50,10 +50,6 @@
 
   configs += [ "//media/gpu:gpu_config" ]
 
-  if (is_chromeos && current_cpu != "arm") {
-    configs += [ "//third_party/libva:libva_config" ]
-  }
-
   if (is_win) {
     configs += [ "//build/config/compiler:no_size_t_to_int_warning" ]
   }
diff --git a/media/gpu/ipc/service/gpu_jpeg_decode_accelerator_factory_provider.cc b/media/gpu/ipc/service/gpu_jpeg_decode_accelerator_factory_provider.cc
index 710e4be..f95f6d5 100644
--- a/media/gpu/ipc/service/gpu_jpeg_decode_accelerator_factory_provider.cc
+++ b/media/gpu/ipc/service/gpu_jpeg_decode_accelerator_factory_provider.cc
@@ -7,19 +7,17 @@
 #include "base/bind.h"
 #include "base/command_line.h"
 #include "base/threading/thread_task_runner_handle.h"
+#include "build/build_config.h"
 #include "media/base/media_switches.h"
 #include "media/gpu/fake_jpeg_decode_accelerator.h"
-
-#if defined(OS_CHROMEOS) && defined(ARCH_CPU_X86_FAMILY)
-#define USE_VAAPI_JDA
-#endif
+#include "media/gpu/features.h"
 
 #if defined(OS_CHROMEOS) && defined(USE_V4L2_CODEC) && \
     defined(ARCH_CPU_ARM_FAMILY)
 #define USE_V4L2_JDA
 #endif
 
-#if defined(USE_VAAPI_JDA)
+#if BUILDFLAG(USE_VAAPI)
 #include "media/gpu/vaapi_jpeg_decode_accelerator.h"
 #endif
 
@@ -45,7 +43,7 @@
 }
 #endif
 
-#if defined(USE_VAAPI_JDA)
+#if BUILDFLAG(USE_VAAPI)
 std::unique_ptr<JpegDecodeAccelerator> CreateVaapiJDA(
     scoped_refptr<base::SingleThreadTaskRunner> io_task_runner) {
   return base::MakeUnique<VaapiJpegDecodeAccelerator>(
@@ -85,7 +83,7 @@
 #if defined(USE_V4L2_JDA)
     result.push_back(base::Bind(&CreateV4L2JDA));
 #endif
-#if defined(USE_VAAPI_JDA)
+#if BUILDFLAG(USE_VAAPI)
     result.push_back(base::Bind(&CreateVaapiJDA));
 #endif
   }
diff --git a/media/gpu/jpeg_decode_accelerator_unittest.cc b/media/gpu/jpeg_decode_accelerator_unittest.cc
index 3a1e962..e8d7e4b 100644
--- a/media/gpu/jpeg_decode_accelerator_unittest.cc
+++ b/media/gpu/jpeg_decode_accelerator_unittest.cc
@@ -26,6 +26,7 @@
 #include "build/build_config.h"
 #include "media/base/test_data_util.h"
 #include "media/filters/jpeg_parser.h"
+#include "media/gpu/features.h"
 #include "media/gpu/video_accelerator_unittest_helpers.h"
 #include "media/video/jpeg_decode_accelerator.h"
 #include "third_party/libyuv/include/libyuv.h"
@@ -36,11 +37,12 @@
 #include "media/gpu/v4l2_device.h"
 #include "media/gpu/v4l2_jpeg_decode_accelerator.h"
 #endif
-#if defined(ARCH_CPU_X86_FAMILY)
+#endif
+
+#if BUILDFLAG(USE_VAAPI)
 #include "media/gpu/vaapi_jpeg_decode_accelerator.h"
 #include "media/gpu/vaapi_wrapper.h"
 #endif
-#endif
 
 namespace media {
 namespace {
@@ -133,7 +135,7 @@
 JpegClient::~JpegClient() {}
 
 void JpegClient::CreateJpegDecoder() {
-#if defined(OS_CHROMEOS) && defined(ARCH_CPU_X86_FAMILY)
+#if BUILDFLAG(USE_VAAPI)
   decoder_.reset(
       new VaapiJpegDecodeAccelerator(base::ThreadTaskRunnerHandle::Get()));
 #elif defined(OS_CHROMEOS) && defined(USE_V4L2_CODEC)
@@ -599,7 +601,7 @@
     LOG(ERROR) << "Unexpected switch: " << it->first << ":" << it->second;
     return -EINVAL;
   }
-#if defined(OS_CHROMEOS) && defined(ARCH_CPU_X86_FAMILY)
+#if BUILDFLAG(USE_VAAPI)
   media::VaapiWrapper::PreSandboxInitialization();
 #endif
 
diff --git a/media/gpu/va_stub_header.fragment b/media/gpu/va_stub_header.fragment
index 91ba892..bed1984 100644
--- a/media/gpu/va_stub_header.fragment
+++ b/media/gpu/va_stub_header.fragment
@@ -3,10 +3,10 @@
 
 extern "C" {
 
-#include "third_party/libva/va/drm/va_drm.h"
-#include "third_party/libva/va/va.h"
+#include <va/va_drm.h>
+#include <va/va.h>
 #if defined(USE_X11)
-#include "third_party/libva/va/va_x11.h"
+#include <va/va_x11.h>
 #endif
 
 }
diff --git a/media/gpu/va_surface.h b/media/gpu/va_surface.h
index c73bc57..0ad963b 100644
--- a/media/gpu/va_surface.h
+++ b/media/gpu/va_surface.h
@@ -8,11 +8,12 @@
 #ifndef MEDIA_GPU_VA_SURFACE_H_
 #define MEDIA_GPU_VA_SURFACE_H_
 
+#include <va/va.h>
+
 #include "base/callback.h"
 #include "base/macros.h"
 #include "base/memory/ref_counted.h"
 #include "media/gpu/media_gpu_export.h"
-#include "third_party/libva/va/va.h"
 #include "ui/gfx/geometry/size.h"
 
 namespace media {
diff --git a/media/gpu/vaapi_drm_picture.cc b/media/gpu/vaapi_drm_picture.cc
index 5fc1cc5..fe68659 100644
--- a/media/gpu/vaapi_drm_picture.cc
+++ b/media/gpu/vaapi_drm_picture.cc
@@ -7,8 +7,6 @@
 #include "base/file_descriptor_posix.h"
 #include "media/gpu/va_surface.h"
 #include "media/gpu/vaapi_wrapper.h"
-#include "third_party/libva/va/drm/va_drm.h"
-#include "third_party/libva/va/va.h"
 #include "ui/gfx/gpu_memory_buffer.h"
 #include "ui/gfx/native_pixmap.h"
 #include "ui/gl/gl_bindings.h"
diff --git a/media/gpu/vaapi_video_decode_accelerator.cc b/media/gpu/vaapi_video_decode_accelerator.cc
index 4c80a0d..7659a70 100644
--- a/media/gpu/vaapi_video_decode_accelerator.cc
+++ b/media/gpu/vaapi_video_decode_accelerator.cc
@@ -8,6 +8,8 @@
 
 #include <memory>
 
+#include <va/va.h>
+
 #include "base/bind.h"
 #include "base/files/scoped_file.h"
 #include "base/logging.h"
@@ -26,7 +28,6 @@
 #include "media/gpu/vp8_decoder.h"
 #include "media/gpu/vp9_decoder.h"
 #include "media/video/picture.h"
-#include "third_party/libva/va/va_dec_vp8.h"
 #include "ui/gl/gl_bindings.h"
 #include "ui/gl/gl_image.h"
 
diff --git a/media/gpu/vaapi_video_encode_accelerator.cc b/media/gpu/vaapi_video_encode_accelerator.cc
index f44efc6..ab0e496 100644
--- a/media/gpu/vaapi_video_encode_accelerator.cc
+++ b/media/gpu/vaapi_video_encode_accelerator.cc
@@ -9,6 +9,8 @@
 #include <memory>
 #include <utility>
 
+#include <va/va.h>
+
 #include "base/bind.h"
 #include "base/callback.h"
 #include "base/macros.h"
@@ -19,7 +21,6 @@
 #include "media/base/bind_to_current_loop.h"
 #include "media/gpu/h264_dpb.h"
 #include "media/gpu/shared_memory_region.h"
-#include "third_party/libva/va/va_enc_h264.h"
 
 #define DVLOGF(level) DVLOG(level) << __func__ << "(): "
 
diff --git a/media/gpu/vaapi_wrapper.cc b/media/gpu/vaapi_wrapper.cc
index 4206ded..0739e56 100644
--- a/media/gpu/vaapi_wrapper.cc
+++ b/media/gpu/vaapi_wrapper.cc
@@ -7,6 +7,8 @@
 #include <dlfcn.h>
 #include <string.h>
 
+#include <va/va.h>
+
 #include "base/bind.h"
 #include "base/callback_helpers.h"
 #include "base/logging.h"
@@ -25,9 +27,9 @@
 #if defined(USE_X11)
 #include "ui/gfx/x/x11_types.h"  // nogncheck
 #elif defined(USE_OZONE)
-#include "third_party/libva/va/drm/va_drm.h"
-#include "third_party/libva/va/va_drmcommon.h"
-#include "third_party/libva/va/va_version.h"
+#include <va/va_drm.h>
+#include <va/va_drmcommon.h>
+#include <va/va_version.h>
 #include "ui/gfx/buffer_format_util.h"
 #include "ui/ozone/public/ozone_platform.h"
 #include "ui/ozone/public/surface_factory_ozone.h"
diff --git a/media/gpu/vaapi_wrapper.h b/media/gpu/vaapi_wrapper.h
index abb930f..22c7feb 100644
--- a/media/gpu/vaapi_wrapper.h
+++ b/media/gpu/vaapi_wrapper.h
@@ -16,6 +16,8 @@
 #include <set>
 #include <vector>
 
+#include <va/va.h>
+
 #include "base/files/file.h"
 #include "base/macros.h"
 #include "base/memory/ref_counted.h"
@@ -27,12 +29,10 @@
 #include "media/video/jpeg_decode_accelerator.h"
 #include "media/video/video_decode_accelerator.h"
 #include "media/video/video_encode_accelerator.h"
-#include "third_party/libva/va/va.h"
-#include "third_party/libva/va/va_vpp.h"
 #include "ui/gfx/geometry/size.h"
 
 #if defined(USE_X11)
-#include "third_party/libva/va/va_x11.h"
+#include <va/va_x11.h>
 #endif  // USE_X11
 
 #if defined(USE_OZONE)
diff --git a/media/gpu/video_decode_accelerator_unittest.cc b/media/gpu/video_decode_accelerator_unittest.cc
index fdfe898..ab7c54f 100644
--- a/media/gpu/video_decode_accelerator_unittest.cc
+++ b/media/gpu/video_decode_accelerator_unittest.cc
@@ -61,6 +61,7 @@
 #include "media/base/test_data_util.h"
 #include "media/filters/h264_parser.h"
 #include "media/gpu/fake_video_decode_accelerator.h"
+#include "media/gpu/features.h"
 #include "media/gpu/gpu_video_decode_accelerator_factory.h"
 #include "media/gpu/rendering_helper.h"
 #include "media/gpu/video_accelerator_unittest_helpers.h"
@@ -71,19 +72,17 @@
 #if defined(OS_WIN)
 #include "base/win/windows_version.h"
 #include "media/gpu/dxva_video_decode_accelerator_win.h"
-#elif defined(OS_CHROMEOS)
-#if defined(USE_V4L2_CODEC)
+#else
+#if defined(OS_CHROMEOS) && defined(USE_V4L2_CODEC)
 #include "media/gpu/v4l2_device.h"
 #include "media/gpu/v4l2_slice_video_decode_accelerator.h"
 #include "media/gpu/v4l2_video_decode_accelerator.h"
 #endif
-#if defined(ARCH_CPU_X86_FAMILY)
+#if BUILDFLAG(USE_VAAPI)
 #include "media/gpu/vaapi_video_decode_accelerator.h"
 #include "media/gpu/vaapi_wrapper.h"
-#endif  // defined(ARCH_CPU_X86_FAMILY)
-#else
-#error The VideoAccelerator tests are not supported on this platform.
-#endif  // OS_WIN
+#endif  // BUILDFLAG(USE_VAAPI)
+#endif  // defined(OS_WIN)
 
 #if defined(USE_OZONE)
 #include "ui/gfx/native_pixmap.h"
@@ -1854,7 +1853,7 @@
     ui::OzonePlatform::InitializeForUI();
 #endif
 
-#if defined(OS_CHROMEOS) && defined(ARCH_CPU_X86_FAMILY)
+#if BUILDFLAG(USE_VAAPI)
     media::VaapiWrapper::PreSandboxInitialization();
 #elif defined(OS_WIN)
     media::DXVAVideoDecodeAccelerator::PreSandboxInitialization();
diff --git a/media/gpu/video_encode_accelerator_unittest.cc b/media/gpu/video_encode_accelerator_unittest.cc
index 657eae2..7cbee5c 100644
--- a/media/gpu/video_encode_accelerator_unittest.cc
+++ b/media/gpu/video_encode_accelerator_unittest.cc
@@ -48,13 +48,14 @@
 #include "media/filters/ffmpeg_video_decoder.h"
 #include "media/filters/h264_parser.h"
 #include "media/filters/ivf_parser.h"
+#include "media/gpu/features.h"
 #include "media/gpu/gpu_video_encode_accelerator_factory.h"
 #include "media/gpu/video_accelerator_unittest_helpers.h"
 #include "media/video/fake_video_encode_accelerator.h"
 #include "media/video/video_encode_accelerator.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
-#if defined(OS_CHROMEOS) && defined(ARCH_CPU_X86_FAMILY)
+#if BUILDFLAG(USE_VAAPI)
 #include "media/gpu/vaapi_wrapper.h"
 #elif defined(OS_WIN)
 #include "media/gpu/media_foundation_video_encode_accelerator_win.h"
@@ -2323,7 +2324,7 @@
     LOG(FATAL) << "--measure_latency requires --run_at_fps enabled to work.";
   }
 
-#if defined(OS_CHROMEOS) && defined(ARCH_CPU_X86_FAMILY)
+#if BUILDFLAG(USE_VAAPI)
   media::VaapiWrapper::PreSandboxInitialization();
 #elif defined(OS_WIN)
   media::MediaFoundationVideoEncodeAccelerator::PreSandboxInitialization();
diff --git a/third_party/libva/BUILD.gn b/third_party/libva/BUILD.gn
deleted file mode 100644
index 61e7098..0000000
--- a/third_party/libva/BUILD.gn
+++ /dev/null
@@ -1,8 +0,0 @@
-# Copyright 2014 The Chromium Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style license that can be
-# found in the LICENSE file.
-
-# Add this config to targets that need to use the libva headers.
-config("libva_config") {
-  include_dirs = [ "." ]
-}
diff --git a/third_party/libva/COPYING b/third_party/libva/COPYING
deleted file mode 100644
index 900e775..0000000
--- a/third_party/libva/COPYING
+++ /dev/null
@@ -1,19 +0,0 @@
-    Permission is hereby granted, free of charge, to any person obtaining a
-    copy of this software and associated documentation files (the
-    "Software"), to deal in the Software without restriction, including
-    without limitation the rights to use, copy, modify, merge, publish,
-    distribute, sub license, and/or sell copies of the Software, and to
-    permit persons to whom the Software is furnished to do so, subject to
-    the following conditions:
-
-    The above copyright notice and this permission notice (including the
-    next paragraph) shall be included in all copies or substantial portions
-    of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
-    IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
-    ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/third_party/libva/OWNERS b/third_party/libva/OWNERS
deleted file mode 100644
index bf72e04..0000000
--- a/third_party/libva/OWNERS
+++ /dev/null
@@ -1 +0,0 @@
-posciak@chromium.org
diff --git a/third_party/libva/README.chromium b/third_party/libva/README.chromium
deleted file mode 100644
index c1eebd2..0000000
--- a/third_party/libva/README.chromium
+++ /dev/null
@@ -1,17 +0,0 @@
-Name: libva
-URL: https://github.com/01org/libva
-Source: git clone https://github.com/01org/libva.git
-Version: 1.7.1
-RealVersion: git tag libva-1.7.1
-License: MIT
-License File: COPYING
-Security Critical: no
-
-Description:
-This library is used for interfacing with the Intel graphics driver for
-hardware accelerated video encoding, decoding, blending and rendering.
-
-Local modifications:
-- remove struct _VAEncMacroblockParameterBufferH264 from va/va_enc_h264.h,
-  which contained an empty union, causing compile errors
-- remove va/egl/va_egl.h due to the lack of license header
diff --git a/third_party/libva/va/drm/va_drm.h b/third_party/libva/va/drm/va_drm.h
deleted file mode 100644
index 9af3cc8..0000000
--- a/third_party/libva/va/drm/va_drm.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * va_drm.h - Raw DRM API
- *
- * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef VA_DRM_H
-#define VA_DRM_H
-
-#include <va/va.h>
-
-/**
- * \file va_drm.h
- * \brief The raw DRM API
- *
- * This file contains the \ref api_drm "Raw DRM API".
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * \brief Returns a VA display derived from the specified DRM connection.
- *
- * This function returns a (possibly cached) VA display from the
- * specified DRM connection @fd.
- *
- * @param[in]   fd      the DRM connection descriptor
- * @return the VA display
- */
-VADisplay
-vaGetDisplayDRM(int fd);
-
-/**@}*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* VA_DRM_H */
diff --git a/third_party/libva/va/drm/va_drm_auth.h b/third_party/libva/va/drm/va_drm_auth.h
deleted file mode 100644
index 1aa6989..0000000
--- a/third_party/libva/va/drm/va_drm_auth.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef VA_DRM_AUTH_H
-#define VA_DRM_AUTH_H
-
-#include <stdint.h>
-#include <stdbool.h>
-
-DLL_HIDDEN
-bool
-va_drm_is_authenticated(int fd);
-
-DLL_HIDDEN
-bool
-va_drm_authenticate(int fd, uint32_t magic);
-
-#endif /* VA_DRM_AUTH_H */
diff --git a/third_party/libva/va/drm/va_drm_auth_x11.h b/third_party/libva/va/drm/va_drm_auth_x11.h
deleted file mode 100644
index 530eeed..0000000
--- a/third_party/libva/va/drm/va_drm_auth_x11.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef VA_DRM_AUTH_X11_H
-#define VA_DRM_AUTH_X11_H
-
-#include <stdint.h>
-#include <stdbool.h>
-
-DLL_HIDDEN
-bool
-va_drm_authenticate_x11(int fd, uint32_t magic);
-
-#endif /* VA_DRM_AUTH_X11_H */
diff --git a/third_party/libva/va/drm/va_drm_utils.h b/third_party/libva/va/drm/va_drm_utils.h
deleted file mode 100644
index b468c59..0000000
--- a/third_party/libva/va/drm/va_drm_utils.h
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * va_drm_utils.h - VA/DRM Utilities
- *
- * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef VA_DRM_UTILS_H
-#define VA_DRM_UTILS_H
-
-#include <va/va_backend.h>
-
-/**
- * \file va_drm_utils.h
- * \brief VA/DRM Utilities
- *
- * This file contains VA/DRM utility functions. The API herein defined is
- * internal to libva. Users include the VA/DRM API itself or VA/Android,
- * should it be based on DRM.
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * \brief Returns the VA driver name for the active display.
- *
- * This functions returns a newly allocated buffer in @driver_name_ptr that
- * contains the VA driver name for the active display. Active display means
- * the display obtained with any of the vaGetDisplay*() functions.
- *
- * The VADriverContext.drm_state structure must be valid, i.e. allocated
- * and containing an open DRM connection descriptor. The DRM connection
- * does *not* need to be authenticated as it only performs a call to
- * drmGetVersion().
- *
- * @param[in]   ctx     the pointer to a VADriverContext
- * @param[out]  driver_name_ptr the newly allocated buffer containing
- *     the VA driver name
- * @return VA_STATUS_SUCCESS if operation is successful, or another
- *     #VAStatus value otherwise.
- */
-DLL_HIDDEN
-VAStatus
-VA_DRM_GetDriverName(VADriverContextP ctx, char **driver_name_ptr);
-
-/**
- * \brief Checks whether the file descriptor is a DRM Render-Nodes one
- *
- * This functions checks whether the supplied file descriptor @fd
- * falls into the set of DRM Render-Nodes.
- */
-DLL_HIDDEN
-int
-VA_DRM_IsRenderNodeFd(int fd);
-
-/**@}*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* VA_DRM_UTILS_H */
diff --git a/third_party/libva/va/egl/va_backend_egl.h b/third_party/libva/va/egl/va_backend_egl.h
deleted file mode 100644
index 925d933..0000000
--- a/third_party/libva/va/egl/va_backend_egl.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (C) 2009 Splitted-Desktop Systems. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef VA_BACKEND_EGL_H
-#define VA_BACKEND_EGL_H
-
-#include <va/va.h>
-#include <va/va_backend.h>
-
-struct VADriverVTableEGL {
-    /* Get EGL ClientBufer buffer index and device id from surface id*/
-    VAStatus (*vaGetEGLClientBufferFromSurface) (
-        VADriverContextP ctx,
-        VASurfaceID surface,
-        void **buffer
-    );
-    /* TBD: more APIs for EGL */
-};
-
-#endif /* VA_BACKEND_EGL_H */
diff --git a/third_party/libva/va/glx/va_backend_glx.h b/third_party/libva/va/glx/va_backend_glx.h
deleted file mode 100644
index d110485..0000000
--- a/third_party/libva/va/glx/va_backend_glx.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (C) 2009 Splitted-Desktop Systems. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef VA_BACKEND_GLX_H
-#define VA_BACKEND_GLX_H
-
-struct VADriverContext;
-
-struct VADriverVTableGLX {
-    /* Optional: create a surface used for display to OpenGL */
-    VAStatus (*vaCreateSurfaceGLX)(
-        struct VADriverContext *ctx,
-        unsigned int            gl_target,
-        unsigned int            gl_texture,
-        void                  **gl_surface
-    );
-
-    /* Optional: destroy a VA/GLX surface */
-    VAStatus (*vaDestroySurfaceGLX)(
-        struct VADriverContext *ctx,
-        void                   *gl_surface
-    );
-
-    /* Optional: copy a VA surface to a VA/GLX surface */
-    VAStatus (*vaCopySurfaceGLX)(
-        struct VADriverContext *ctx,
-        void                   *gl_surface,
-        VASurfaceID             surface,
-        unsigned int            flags
-    );
-};
-
-#endif /* VA_BACKEND_GLX_H */
diff --git a/third_party/libva/va/glx/va_glx.h b/third_party/libva/va/glx/va_glx.h
deleted file mode 100644
index 1a0624d..0000000
--- a/third_party/libva/va/glx/va_glx.h
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Copyright (C) 2009 Splitted-Desktop Systems. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef VA_GLX_H
-#define VA_GLX_H
-
-#include <va/va.h>
-#include <GL/glx.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * Return a suitable VADisplay for VA API
- *
- * @param[in] dpy the X11 display
- * @return a VADisplay
- */
-VADisplay vaGetDisplayGLX(
-    Display *dpy
-);
-
-/**
- * Create a surface used for display to OpenGL
- *
- * The application shall maintain the live GLX context itself.
- * Implementations are free to use glXGetCurrentContext() and
- * glXGetCurrentDrawable() functions for internal purposes.
- *
- * @param[in]  dpy        the VA display
- * @param[in]  target     the GL target to which the texture needs to be bound
- * @param[in]  texture    the GL texture
- * @param[out] gl_surface the VA/GLX surface
- * @return VA_STATUS_SUCCESS if successful
- */
-VAStatus vaCreateSurfaceGLX(
-    VADisplay dpy,
-    GLenum    target,
-    GLuint    texture,
-    void    **gl_surface
-);
-
-/**
- * Destroy a VA/GLX surface
- *
- * The application shall maintain the live GLX context itself.
- * Implementations are free to use glXGetCurrentContext() and
- * glXGetCurrentDrawable() functions for internal purposes.
- *
- * @param[in]  dpy        the VA display
- * @param[in]  gl_surface the VA surface
- * @return VA_STATUS_SUCCESS if successful
- */
-VAStatus vaDestroySurfaceGLX(
-    VADisplay dpy,
-    void     *gl_surface
-);
-
-/**
- * Copy a VA surface to a VA/GLX surface
- *
- * This function will not return until the copy is completed. At this
- * point, the underlying GL texture will contain the surface pixels
- * in an RGB format defined by the user.
- *
- * The application shall maintain the live GLX context itself.
- * Implementations are free to use glXGetCurrentContext() and
- * glXGetCurrentDrawable() functions for internal purposes.
- *
- * @param[in]  dpy        the VA display
- * @param[in]  gl_surface the VA/GLX destination surface
- * @param[in]  surface    the VA source surface
- * @param[in]  flags      the PutSurface flags
- * @return VA_STATUS_SUCCESS if successful
- */
-VAStatus vaCopySurfaceGLX(
-    VADisplay    dpy,
-    void        *gl_surface,
-    VASurfaceID  surface,
-    unsigned int flags
-);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* VA_GLX_H */
diff --git a/third_party/libva/va/glx/va_glx_impl.h b/third_party/libva/va/glx/va_glx_impl.h
deleted file mode 100644
index c47f54a..0000000
--- a/third_party/libva/va/glx/va_glx_impl.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (C) 2009 Splitted-Desktop Systems. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef VA_GLX_IMPL_H
-#define VA_GLX_IMPL_H
-
-/**
- * Initialize GLX driver context
- *
- * @param[in]  ctx        the VA driver context
- * @return VA_STATUS_SUCCESS if successful
- */
-DLL_HIDDEN
-VAStatus va_glx_init_context(VADriverContextP ctx);
-
-#endif /* VA_GLX_IMPL_H */
diff --git a/third_party/libva/va/glx/va_glx_private.h b/third_party/libva/va/glx/va_glx_private.h
deleted file mode 100644
index e86efb6..0000000
--- a/third_party/libva/va/glx/va_glx_private.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright (C) 2009 Splitted-Desktop Systems. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef VA_GLX_PRIVATE_H
-#define VA_GLX_PRIVATE_H
-
-#include "sysdeps.h"
-#include "va.h"
-#include "va_backend.h"
-#include "va_x11.h"
-#include "va_glx.h"
-#include "va_backend_glx.h"
-#include <GL/glxext.h>
-
-#if GLX_GLXEXT_VERSION < 18
-typedef void (*PFNGLXBINDTEXIMAGEEXTPROC)(Display *, GLXDrawable, int, const int *);
-typedef void (*PFNGLXRELEASETEXIMAGEEXTPROC)(Display *, GLXDrawable, int);
-#endif
-
-#if GLX_GLXEXT_VERSION < 27
-/* XXX: this is not exactly that version but this is the only means to
-   make sure we have the correct <GL/glx.h> with those signatures */
-typedef GLXPixmap (*PFNGLXCREATEPIXMAPPROC)(Display *, GLXFBConfig, Pixmap, const int *);
-typedef void (*PFNGLXDESTROYPIXMAPPROC)(Display *, GLXPixmap);
-#endif
-
-typedef struct VAOpenGLVTable *VAOpenGLVTableP;
-
-struct VAOpenGLVTable {
-    PFNGLXCREATEPIXMAPPROC              glx_create_pixmap;
-    PFNGLXDESTROYPIXMAPPROC             glx_destroy_pixmap;
-    PFNGLXBINDTEXIMAGEEXTPROC           glx_bind_tex_image;
-    PFNGLXRELEASETEXIMAGEEXTPROC        glx_release_tex_image;
-    PFNGLGENFRAMEBUFFERSEXTPROC         gl_gen_framebuffers;
-    PFNGLDELETEFRAMEBUFFERSEXTPROC      gl_delete_framebuffers;
-    PFNGLBINDFRAMEBUFFEREXTPROC         gl_bind_framebuffer;
-    PFNGLGENRENDERBUFFERSEXTPROC        gl_gen_renderbuffers;
-    PFNGLDELETERENDERBUFFERSEXTPROC     gl_delete_renderbuffers;
-    PFNGLBINDRENDERBUFFEREXTPROC        gl_bind_renderbuffer;
-    PFNGLRENDERBUFFERSTORAGEEXTPROC     gl_renderbuffer_storage;
-    PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC gl_framebuffer_renderbuffer;
-    PFNGLFRAMEBUFFERTEXTURE2DEXTPROC    gl_framebuffer_texture_2d;
-    PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC  gl_check_framebuffer_status;
-};
-
-typedef struct VADisplayContextGLX *VADisplayContextGLXP;
-typedef struct VADriverContextGLX  *VADriverContextGLXP;
-typedef struct VASurfaceGLX        *VASurfaceGLXP;
-typedef struct VADriverVTableGLX   *VADriverVTableGLXP;
-
-typedef void (*vaDestroyFunc)(VADisplayContextP);
-
-struct VADisplayContextGLX {
-    vaDestroyFunc vaDestroy;
-};
-
-#define VA_DRIVER_CONTEXT_GLX(ctx) ((VADriverContextGLXP)((ctx)->glx))
-
-struct VADriverContextGLX {
-    struct VADriverVTableGLX    vtable;
-    struct VAOpenGLVTable       gl_vtable;
-    unsigned int                is_initialized  : 1;
-};
-
-#endif /* VA_GLX_PRIVATE_H */
diff --git a/third_party/libva/va/sysdeps.h b/third_party/libva/va/sysdeps.h
deleted file mode 100644
index 4de764d..0000000
--- a/third_party/libva/va/sysdeps.h
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright (c) 2007-2009 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef SYSDEPS_H
-#define SYSDEPS_H
-
-#ifdef HAVE_CONFIG_H
-# include "config.h"
-#endif
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdbool.h>
-#include <string.h>
-#include <stdint.h>
-#include <assert.h>
-
-#ifdef ANDROID
-# define Bool  int
-# define True  1
-# define False 0
-
-/* Macros generated from configure */
-# define LIBVA_VERSION_S "1.1.0"
-
-/* Android logging utilities */
-# include <utils/Log.h>
-
-# ifdef ANDROID_ALOG
-#  define va_log_error(buffer)  do { ALOGE("%s", buffer); } while (0)
-#  define va_log_info(buffer)   do { ALOGI("%s", buffer); } while (0)
-# elif ANDROID_LOG
-#  define va_log_error(buffer)  do { LOGE("%s", buffer); } while (0)
-#  define va_log_info(buffer)   do { LOGI("%s", buffer); } while (0)
-# endif
-#endif
-
-#ifndef va_log_error
-#define va_log_error(buffer) do {                       \
-        fprintf(stderr, "libva error: %s", buffer);     \
-    } while (0)
-#endif
-
-#ifndef va_log_info
-#define va_log_info(buffer) do {                        \
-        fprintf(stderr, "libva info: %s", buffer);      \
-    } while (0)
-#endif
-
-#if defined __GNUC__ && defined HAVE_GNUC_VISIBILITY_ATTRIBUTE
-# define DLL_HIDDEN __attribute__((visibility("hidden")))
-# define DLL_EXPORT __attribute__((visibility("default")))
-#else
-# define DLL_HIDDEN
-# define DLL_EXPORT
-#endif
-
-#endif /* SYSDEPS_H */
diff --git a/third_party/libva/va/va.h b/third_party/libva/va/va.h
deleted file mode 100644
index 22c4fc2..0000000
--- a/third_party/libva/va/va.h
+++ /dev/null
@@ -1,2960 +0,0 @@
-/*
- * Copyright (c) 2007-2009 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-/*
- * Video Acceleration (VA) API Specification
- *
- * Rev. 0.30
- * <jonathan.bian@intel.com>
- *
- * Revision History:
- * rev 0.10 (12/10/2006 Jonathan Bian) - Initial draft
- * rev 0.11 (12/15/2006 Jonathan Bian) - Fixed some errors
- * rev 0.12 (02/05/2007 Jonathan Bian) - Added VC-1 data structures for slice level decode
- * rev 0.13 (02/28/2007 Jonathan Bian) - Added GetDisplay()
- * rev 0.14 (04/13/2007 Jonathan Bian) - Fixed MPEG-2 PictureParameter structure, cleaned up a few funcs.
- * rev 0.15 (04/20/2007 Jonathan Bian) - Overhauled buffer management
- * rev 0.16 (05/02/2007 Jonathan Bian) - Added error codes and fixed some issues with configuration
- * rev 0.17 (05/07/2007 Jonathan Bian) - Added H.264/AVC data structures for slice level decode.
- * rev 0.18 (05/14/2007 Jonathan Bian) - Added data structures for MPEG-4 slice level decode 
- *                                       and MPEG-2 motion compensation.
- * rev 0.19 (08/06/2007 Jonathan Bian) - Removed extra type for bitplane data.
- * rev 0.20 (08/08/2007 Jonathan Bian) - Added missing fields to VC-1 PictureParameter structure.
- * rev 0.21 (08/20/2007 Jonathan Bian) - Added image and subpicture support.
- * rev 0.22 (08/27/2007 Jonathan Bian) - Added support for chroma-keying and global alpha.
- * rev 0.23 (09/11/2007 Jonathan Bian) - Fixed some issues with images and subpictures.
- * rev 0.24 (09/18/2007 Jonathan Bian) - Added display attributes.
- * rev 0.25 (10/18/2007 Jonathan Bian) - Changed to use IDs only for some types.
- * rev 0.26 (11/07/2007 Waldo Bastian) - Change vaCreateBuffer semantics
- * rev 0.27 (11/19/2007 Matt Sottek)   - Added DeriveImage
- * rev 0.28 (12/06/2007 Jonathan Bian) - Added new versions of PutImage and AssociateSubpicture 
- *                                       to enable scaling
- * rev 0.29 (02/07/2008 Jonathan Bian) - VC1 parameter fixes,
- *                                       added VA_STATUS_ERROR_RESOLUTION_NOT_SUPPORTED
- * rev 0.30 (03/01/2009 Jonathan Bian) - Added encoding support for H.264 BP and MPEG-4 SP and fixes
- *                                       for ISO C conformance.
- * rev 0.31 (09/02/2009 Gwenole Beauchesne) - VC-1/H264 fields change for VDPAU and XvBA backend
- *                                       Application needs to relink with the new library.
- *
- * rev 0.31.1 (03/29/2009)              - Data structure for JPEG encode
- * rev 0.31.2 (01/13/2011 Anthony Pabon)- Added a flag to indicate Subpicture coordinates are screen
- *                                        screen relative rather than source video relative.
- * rev 0.32.0 (01/13/2011 Xiang Haihao) - Add profile into VAPictureParameterBufferVC1
- *                                        update VAAPI to 0.32.0
- *
- * Acknowledgements:
- *  Some concepts borrowed from XvMC and XvImage.
- *  Waldo Bastian (Intel), Matt Sottek (Intel),  Austin Yuan (Intel), and Gwenole Beauchesne (SDS)
- *  contributed to various aspects of the API.
- */
-
-/**
- * \file va.h
- * \brief The Core API
- *
- * This file contains the \ref api_core "Core API".
- */
-
-#ifndef _VA_H_
-#define _VA_H_
-
-#include <stddef.h>
-#include <stdint.h>
-#include <va/va_version.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * \mainpage Video Acceleration (VA) API
- *
- * \section intro Introduction
- *
- * The main motivation for VA-API (Video Acceleration API) is to
- * enable hardware accelerated video decode and encode at various
- * entry-points (VLD, IDCT, Motion Compensation etc.) for the
- * prevailing coding standards today (MPEG-2, MPEG-4 ASP/H.263, MPEG-4
- * AVC/H.264, VC-1/VMW3, and JPEG).
- *
- * VA-API is split into several modules:
- * - \ref api_core
- * - \ref api_enc_h264
- * - \ref api_vpp
- */
-
-/**
- * \defgroup api_core Core API
- *
- * @{
- */
-
-/**
-Overview 
-
-The VA API is intended to provide an interface between a video decode/encode/display
-application (client) and a hardware accelerator (server), to off-load 
-video decode/encode/display operations from the host to the hardware accelerator at various 
-entry-points.
-
-The basic operation steps are:
-
-- Negotiate a mutually acceptable configuration with the server to lock
-  down profile, entrypoints, and other attributes that will not change on 
-  a frame-by-frame basis.
-- Create a decode context which represents a "virtualized" hardware decode 
-  device
-- Get and fill decode buffers with picture level, slice level and macroblock 
-  level data (depending on entrypoints)
-- Pass the decode buffers to the server to decode the current frame
-
-Initialization & Configuration Management 
-
-- Find out supported profiles
-- Find out entrypoints for a given profile
-- Find out configuration attributes for a given profile/entrypoint pair
-- Create a configuration for use by the decoder
-
-*/
-
-typedef void* VADisplay;	/* window system dependent */
-
-typedef int VAStatus;	/** Return status type from functions */
-/** Values for the return status */
-#define VA_STATUS_SUCCESS			0x00000000
-#define VA_STATUS_ERROR_OPERATION_FAILED	0x00000001
-#define VA_STATUS_ERROR_ALLOCATION_FAILED	0x00000002
-#define VA_STATUS_ERROR_INVALID_DISPLAY		0x00000003
-#define VA_STATUS_ERROR_INVALID_CONFIG		0x00000004
-#define VA_STATUS_ERROR_INVALID_CONTEXT		0x00000005
-#define VA_STATUS_ERROR_INVALID_SURFACE		0x00000006
-#define VA_STATUS_ERROR_INVALID_BUFFER		0x00000007
-#define VA_STATUS_ERROR_INVALID_IMAGE		0x00000008
-#define VA_STATUS_ERROR_INVALID_SUBPICTURE	0x00000009
-#define VA_STATUS_ERROR_ATTR_NOT_SUPPORTED	0x0000000a
-#define VA_STATUS_ERROR_MAX_NUM_EXCEEDED	0x0000000b
-#define VA_STATUS_ERROR_UNSUPPORTED_PROFILE	0x0000000c
-#define VA_STATUS_ERROR_UNSUPPORTED_ENTRYPOINT	0x0000000d
-#define VA_STATUS_ERROR_UNSUPPORTED_RT_FORMAT	0x0000000e
-#define VA_STATUS_ERROR_UNSUPPORTED_BUFFERTYPE	0x0000000f
-#define VA_STATUS_ERROR_SURFACE_BUSY		0x00000010
-#define VA_STATUS_ERROR_FLAG_NOT_SUPPORTED      0x00000011
-#define VA_STATUS_ERROR_INVALID_PARAMETER	0x00000012
-#define VA_STATUS_ERROR_RESOLUTION_NOT_SUPPORTED 0x00000013
-#define VA_STATUS_ERROR_UNIMPLEMENTED           0x00000014
-#define VA_STATUS_ERROR_SURFACE_IN_DISPLAYING   0x00000015
-#define VA_STATUS_ERROR_INVALID_IMAGE_FORMAT    0x00000016
-#define VA_STATUS_ERROR_DECODING_ERROR          0x00000017
-#define VA_STATUS_ERROR_ENCODING_ERROR          0x00000018
-/**
- * \brief An invalid/unsupported value was supplied.
- *
- * This is a catch-all error code for invalid or unsupported values.
- * e.g. value exceeding the valid range, invalid type in the context
- * of generic attribute values.
- */
-#define VA_STATUS_ERROR_INVALID_VALUE           0x00000019
-/** \brief An unsupported filter was supplied. */
-#define VA_STATUS_ERROR_UNSUPPORTED_FILTER      0x00000020
-/** \brief An invalid filter chain was supplied. */
-#define VA_STATUS_ERROR_INVALID_FILTER_CHAIN    0x00000021
-/** \brief Indicate HW busy (e.g. run multiple encoding simultaneously). */
-#define VA_STATUS_ERROR_HW_BUSY	                0x00000022
-/** \brief An unsupported memory type was supplied. */
-#define VA_STATUS_ERROR_UNSUPPORTED_MEMORY_TYPE 0x00000024
-#define VA_STATUS_ERROR_UNKNOWN			0xFFFFFFFF
-
-/** De-interlacing flags for vaPutSurface() */
-#define VA_FRAME_PICTURE        0x00000000 
-#define VA_TOP_FIELD            0x00000001
-#define VA_BOTTOM_FIELD         0x00000002
-
-/**
- * Enabled the positioning/cropping/blending feature:
- * 1, specify the video playback position in the isurface
- * 2, specify the cropping info for video playback
- * 3, encoded video will blend with background color
- */
-#define VA_ENABLE_BLEND         0x00000004 /* video area blend with the constant color */ 
-    
-/**
- * Clears the drawable with background color.
- * for hardware overlay based implementation this flag
- * can be used to turn off the overlay
- */
-#define VA_CLEAR_DRAWABLE       0x00000008
-
-/** Color space conversion flags for vaPutSurface() */
-#define VA_SRC_COLOR_MASK       0x000000f0
-#define VA_SRC_BT601            0x00000010
-#define VA_SRC_BT709            0x00000020
-#define VA_SRC_SMPTE_240        0x00000040
-
-/** Scaling flags for vaPutSurface() */
-#define VA_FILTER_SCALING_DEFAULT       0x00000000
-#define VA_FILTER_SCALING_FAST          0x00000100
-#define VA_FILTER_SCALING_HQ            0x00000200
-#define VA_FILTER_SCALING_NL_ANAMORPHIC 0x00000300
-#define VA_FILTER_SCALING_MASK          0x00000f00
-
-/**
- * Returns a short english description of error_status
- */
-const char *vaErrorStr(VAStatus error_status);
-
-typedef struct _VARectangle {
-  short x;
-  short y;
-  unsigned short width;
-  unsigned short height;
-} VARectangle;
-
-/**
- * Initialization:
- * A display must be obtained by calling vaGetDisplay() before calling
- * vaInitialize() and other functions. This connects the API to the 
- * native window system.
- * For X Windows, native_dpy would be from XOpenDisplay()
- */
-typedef void* VANativeDisplay;	/* window system dependent */
-
-int vaDisplayIsValid(VADisplay dpy);
-
-/**
- *  Set the override driver name instead of queried driver driver.
- */
-VAStatus vaSetDriverName(VADisplay dpy,
-                         char *driver_name
-);
-
-/**
- * Initialize the library 
- */
-VAStatus vaInitialize (
-    VADisplay dpy,
-    int *major_version,	 /* out */
-    int *minor_version 	 /* out */
-);
-
-/**
- * After this call, all library internal resources will be cleaned up
- */ 
-VAStatus vaTerminate (
-    VADisplay dpy
-);
-
-/**
- * vaQueryVendorString returns a pointer to a zero-terminated string
- * describing some aspects of the VA implemenation on a specific    
- * hardware accelerator. The format of the returned string is vendor
- * specific and at the discretion of the implementer.
- * e.g. for the Intel GMA500 implementation, an example would be:
- * "Intel GMA500 - 2.0.0.32L.0005"
- */
-const char *vaQueryVendorString (
-    VADisplay dpy
-);
-
-typedef int (*VAPrivFunc)();
-
-/**
- * Return a function pointer given a function name in the library.
- * This allows private interfaces into the library
- */ 
-VAPrivFunc vaGetLibFunc (
-    VADisplay dpy,
-    const char *func
-);
-
-/** Currently defined profiles */
-typedef enum {
-  /** \brief Profile ID used for video processing. */
-  VAProfileNone = -1,
-  VAProfileMPEG2Simple = 0,
-  VAProfileMPEG2Main = 1,
-  VAProfileMPEG4Simple = 2,
-  VAProfileMPEG4AdvancedSimple = 3,
-  VAProfileMPEG4Main = 4,
-  VAProfileH264Baseline = 5,
-  VAProfileH264Main = 6,
-  VAProfileH264High = 7,
-  VAProfileVC1Simple = 8,
-  VAProfileVC1Main = 9,
-  VAProfileVC1Advanced = 10,
-  VAProfileH263Baseline = 11,
-  VAProfileJPEGBaseline = 12,
-  VAProfileH264ConstrainedBaseline = 13,
-  VAProfileVP8Version0_3 = 14,
-  VAProfileH264MultiviewHigh = 15,
-  VAProfileH264StereoHigh = 16,
-  VAProfileHEVCMain = 17,
-  VAProfileHEVCMain10 = 18,
-  VAProfileVP9Profile0 = 19,
-  VAProfileVP9Profile1 = 20,
-  VAProfileVP9Profile2 = 21,
-  VAProfileVP9Profile3 = 22
-} VAProfile;
-
-/**
- *  Currently defined entrypoints 
- */
-typedef enum {
-  VAEntrypointVLD = 1,
-  VAEntrypointIZZ = 2,
-  VAEntrypointIDCT = 3,
-  VAEntrypointMoComp = 4,
-  VAEntrypointDeblocking = 5,
-  VAEntrypointEncSlice = 6,   /* slice level encode */
-  VAEntrypointEncPicture = 7, /* pictuer encode, JPEG, etc */
-  /*
-   * For an implementation that supports a low power/high performance variant
-   * for slice level encode, it can choose to expose the
-   * VAEntrypointEncSliceLP entrypoint. Certain encoding tools may not be
-   * available with this entrypoint (e.g. interlace, MBAFF) and the
-   * application can query the encoding configuration attributes to find
-   * out more details if this entrypoint is supported.
-   */
-  VAEntrypointEncSliceLP = 8,
-  VAEntrypointVideoProc = 10, /**< Video pre/post-processing. */
-} VAEntrypoint;
-
-/** Currently defined configuration attribute types */
-typedef enum {
-  VAConfigAttribRTFormat = 0,
-  VAConfigAttribSpatialResidual = 1,
-  VAConfigAttribSpatialClipping = 2,
-  VAConfigAttribIntraResidual = 3,
-  VAConfigAttribEncryption = 4,
-  VAConfigAttribRateControl = 5,
-
-  /** @name Attributes for decoding */
-  /**@{*/
-  /**
-   * \brief Slice Decoding mode. Read/write.
-   *
-   * This attribute determines what mode the driver supports for slice
-   * decoding, through vaGetConfigAttributes(); and what mode the user
-   * will be providing to the driver, through vaCreateConfig(), if the
-   * driver supports those. If this attribute is not set by the user then
-   * it is assumed that VA_DEC_SLICE_MODE_NORMAL mode is used.
-   *
-   * See \c VA_DEC_SLICE_MODE_xxx for the list of slice decoding modes.
-   */
-  VAConfigAttribDecSliceMode = 6,
-
-  /** @name Attributes for encoding */
-  /**@{*/
-  /**
-   * \brief Packed headers mode. Read/write.
-   *
-   * This attribute determines what packed headers the driver supports,
-   * through vaGetConfigAttributes(); and what packed headers the user
-   * will be providing to the driver, through vaCreateConfig(), if the
-   * driver supports those.
-   *
-   * See \c VA_ENC_PACKED_HEADER_xxx for the list of packed headers.
-   */
-  VAConfigAttribEncPackedHeaders = 10,
-  /**
-   * \brief Interlaced mode. Read/write.
-   *
-   * This attribute determines what kind of interlaced encoding mode
-   * the driver supports.
-   *
-   * See \c VA_ENC_INTERLACED_xxx for the list of interlaced modes.
-   */
-  VAConfigAttribEncInterlaced = 11,
-  /**
-   * \brief Maximum number of reference frames. Read-only.
-   *
-   * This attribute determines the maximum number of reference
-   * frames supported for encoding.
-   *
-   * Note: for H.264 encoding, the value represents the maximum number
-   * of reference frames for both the reference picture list 0 (bottom
-   * 16 bits) and the reference picture list 1 (top 16 bits).
-   */
-  VAConfigAttribEncMaxRefFrames = 13,
-  /**
-   * \brief Maximum number of slices per frame. Read-only.
-   *
-   * This attribute determines the maximum number of slices the
-   * driver can support to encode a single frame.
-   */
-  VAConfigAttribEncMaxSlices = 14,
-  /**
-   * \brief Slice structure. Read-only.
-   *
-   * This attribute determines slice structures supported by the
-   * driver for encoding. This attribute is a hint to the user so
-   * that he can choose a suitable surface size and how to arrange
-   * the encoding process of multiple slices per frame.
-   *
-   * More specifically, for H.264 encoding, this attribute
-   * determines the range of accepted values to
-   * VAEncSliceParameterBufferH264::macroblock_address and
-   * VAEncSliceParameterBufferH264::num_macroblocks.
-   *
-   * See \c VA_ENC_SLICE_STRUCTURE_xxx for the supported slice
-   * structure types.
-   */
-  VAConfigAttribEncSliceStructure = 15,
-  /**
-   * \brief Macroblock information. Read-only.
-   *
-   * This attribute determines whether the driver supports extra
-   * encoding information per-macroblock. e.g. QP.
-   *
-   * More specifically, for H.264 encoding, if the driver returns a non-zero
-   * value for this attribute, this means the application can create
-   * additional #VAEncMacroblockParameterBufferH264 buffers referenced
-   * through VAEncSliceParameterBufferH264::macroblock_info.
-   */
-  VAConfigAttribEncMacroblockInfo = 16,
-  /**
-   * \brief JPEG encoding attribute. Read-only.
-   *
-   * This attribute exposes a number of capabilities of the underlying
-   * JPEG implementation. The attribute value is partitioned into fields as
-   * defined in the VAConfigAttribValEncJPEG union.
-   */
-  VAConfigAttribEncJPEG = 20,
-  /**
-   * \brief Encoding quality range attribute. Read-only.
-   *
-   * This attribute conveys whether the driver supports different quality level
-   * settings for encoding. A value less than or equal to 1 means that the
-   * encoder only has a single quality setting, and a value greater than 1
-   * represents the number of quality levels that can be configured. e.g. a
-   * value of 2 means there are two distinct quality levels.
-   */
-  VAConfigAttribEncQualityRange = 21,
-  /**
-   * \brief Encoding skip frame attribute. Read-only.
-   *
-   * This attribute conveys whether the driver supports sending skip frame
-   * parameters (VAEncMiscParameterTypeSkipFrame) to the encoder's rate control,
-   * when the user has externally skipped frames.
-   */
-  VAConfigAttribEncSkipFrame = 24,
-  /**
-   * \brief Encoding region-of-interest (ROI) attribute. Read-only.
-   *
-   * This attribute conveys whether the driver supports region-of-interest (ROI)
-   * encoding, based on user provided ROI rectangles.  The attribute value is
-   * partitioned into fields as defined in the VAConfigAttribValEncROI union.
-   *
-   * If ROI encoding is supported, the ROI information is passed to the driver
-   * using VAEncMiscParameterTypeROI.
-   */
-  VAConfigAttribEncROI = 25,
-  /**@}*/
-  VAConfigAttribTypeMax
-} VAConfigAttribType;
-
-/**
- * Configuration attributes
- * If there is more than one value for an attribute, a default
- * value will be assigned to the attribute if the client does not
- * specify the attribute when creating a configuration
- */
-typedef struct _VAConfigAttrib {
-    VAConfigAttribType type;
-    unsigned int value; /* OR'd flags (bits) for this attribute */
-} VAConfigAttrib;
-
-/** attribute value for VAConfigAttribRTFormat */
-#define VA_RT_FORMAT_YUV420	0x00000001	
-#define VA_RT_FORMAT_YUV422	0x00000002
-#define VA_RT_FORMAT_YUV444	0x00000004
-#define VA_RT_FORMAT_YUV411	0x00000008
-#define VA_RT_FORMAT_YUV400	0x00000010
-/** YUV formats with more than 8 bpp */
-#define VA_RT_FORMAT_YUV420_10BPP 0x00000100
-/** RGB formats */
-#define VA_RT_FORMAT_RGB16	0x00010000
-#define VA_RT_FORMAT_RGB32	0x00020000
-/* RGBP covers RGBP and BGRP fourcc */
-#define VA_RT_FORMAT_RGBP	0x00100000
-#define VA_RT_FORMAT_PROTECTED	0x80000000
-
-/** @name Attribute values for VAConfigAttribRateControl */
-/**@{*/
-/** \brief Driver does not support any form of rate control. */
-#define VA_RC_NONE                      0x00000001
-/** \brief Constant bitrate. */
-#define VA_RC_CBR                       0x00000002
-/** \brief Variable bitrate. */
-#define VA_RC_VBR                       0x00000004
-/** \brief Video conference mode. */
-#define VA_RC_VCM                       0x00000008
-/** \brief Constant QP. */
-#define VA_RC_CQP                       0x00000010
-/** \brief Variable bitrate with peak rate higher than average bitrate. */
-#define VA_RC_VBR_CONSTRAINED           0x00000020
-/** \brief Macroblock based rate control.  Per MB control is decided
- *  internally in the encoder. It may be combined with other RC modes, except
- * CQP. */
-#define VA_RC_MB 0x00000080
-
-/**@}*/
-
-/** @name Attribute values for VAConfigAttribDecSliceMode */
-/**@{*/
-/** \brief Driver supports normal mode for slice decoding */
-#define VA_DEC_SLICE_MODE_NORMAL       0x00000001
-/** \brief Driver supports base mode for slice decoding */
-#define VA_DEC_SLICE_MODE_BASE         0x00000002
-/**@}*/
-
-/** @name Attribute values for VAConfigAttribEncPackedHeaders */
-/**@{*/
-/** \brief Driver does not support any packed headers mode. */
-#define VA_ENC_PACKED_HEADER_NONE       0x00000000
-/** \brief Driver supports packed sequence headers. e.g. SPS for H.264. */
-#define VA_ENC_PACKED_HEADER_SEQUENCE   0x00000001
-/** \brief Driver supports packed picture headers. e.g. PPS for H.264. */
-#define VA_ENC_PACKED_HEADER_PICTURE    0x00000002
-/** \brief Driver supports packed slice headers. e.g. \c slice_header() for H.264. */
-#define VA_ENC_PACKED_HEADER_SLICE      0x00000004
-/** \brief Driver supports misc packed headers. e.g. SEI for H.264. */
-#define VA_ENC_PACKED_HEADER_MISC       0x00000008
-/** \brief Driver supports raw packed header, see VAEncPackedHeaderRawData */
-#define VA_ENC_PACKED_HEADER_RAW_DATA   0x00000010
-/**@}*/
-
-/** @name Attribute values for VAConfigAttribEncInterlaced */
-/**@{*/
-/** \brief Driver does not support interlaced coding. */
-#define VA_ENC_INTERLACED_NONE          0x00000000
-/** \brief Driver supports interlaced frame coding. */
-#define VA_ENC_INTERLACED_FRAME         0x00000001
-/** \brief Driver supports interlaced field coding. */
-#define VA_ENC_INTERLACED_FIELD         0x00000002
-/** \brief Driver supports macroblock adaptive frame field coding. */
-#define VA_ENC_INTERLACED_MBAFF         0x00000004
-/** \brief Driver supports picture adaptive frame field coding. */
-#define VA_ENC_INTERLACED_PAFF          0x00000008
-/**@}*/
-
-/** @name Attribute values for VAConfigAttribEncSliceStructure */
-/**@{*/
-/** \brief Driver supports an arbitrary number of rows per slice. */
-#define VA_ENC_SLICE_STRUCTURE_ARBITRARY_ROWS           0x00000000
-/** \brief Driver supports a power-of-two number of rows per slice. */
-#define VA_ENC_SLICE_STRUCTURE_POWER_OF_TWO_ROWS        0x00000001
-/** \brief Driver supports an arbitrary number of rows per slice. */
-#define VA_ENC_SLICE_STRUCTURE_ARBITRARY_MACROBLOCKS    0x00000002
-/**@}*/
-
-/** \brief Attribute value for VAConfigAttribEncJPEG */
-typedef union _VAConfigAttribValEncJPEG {
-    struct {
-        /** \brief set to 1 for arithmatic coding. */
-        unsigned int arithmatic_coding_mode : 1;
-        /** \brief set to 1 for progressive dct. */
-        unsigned int progressive_dct_mode : 1;
-        /** \brief set to 1 for non-interleaved. */
-        unsigned int non_interleaved_mode : 1;
-        /** \brief set to 1 for differential. */
-        unsigned int differential_mode : 1;
-        unsigned int max_num_components : 3;
-        unsigned int max_num_scans : 4;
-        unsigned int max_num_huffman_tables : 3;
-        unsigned int max_num_quantization_tables : 3;
-    } bits;
-    unsigned int value;
-} VAConfigAttribValEncJPEG;
-
-/** \brief Attribute value for VAConfigAttribEncROI */
-typedef union _VAConfigAttribValEncROI {
-  struct {
-    /** \brief The number of ROI regions supported, 0 if ROI is not supported.
-     */
-    unsigned int num_roi_regions : 8;
-    /** \brief Indicates if ROI priority indication is supported when
-     * VAConfigAttribRateControl != VA_RC_CQP, else only ROI delta QP added on
-     * top of the frame level QP is supported when VAConfigAttribRateControl ==
-     * VA_RC_CQP.
-     */
-    unsigned int roi_rc_priority_support : 1;
-    unsigned int reserved : 23;
-  } bits;
-  unsigned int value;
-} VAConfigAttribValEncROI;
-
-/**
- * if an attribute is not applicable for a given
- * profile/entrypoint pair, then set the value to the following 
- */
-#define VA_ATTRIB_NOT_SUPPORTED 0x80000000
-
-/** Get maximum number of profiles supported by the implementation */
-int vaMaxNumProfiles (
-    VADisplay dpy
-);
-
-/** Get maximum number of entrypoints supported by the implementation */
-int vaMaxNumEntrypoints (
-    VADisplay dpy
-);
-
-/** Get maximum number of attributs supported by the implementation */
-int vaMaxNumConfigAttributes (
-    VADisplay dpy
-);
-
-/**
- * Query supported profiles 
- * The caller must provide a "profile_list" array that can hold at
- * least vaMaxNumProfile() entries. The actual number of profiles
- * returned in "profile_list" is returned in "num_profile".
- */
-VAStatus vaQueryConfigProfiles (
-    VADisplay dpy,
-    VAProfile *profile_list,	/* out */
-    int *num_profiles		/* out */
-);
-
-/**
- * Query supported entrypoints for a given profile 
- * The caller must provide an "entrypoint_list" array that can hold at
- * least vaMaxNumEntrypoints() entries. The actual number of entrypoints 
- * returned in "entrypoint_list" is returned in "num_entrypoints".
- */
-VAStatus vaQueryConfigEntrypoints (
-    VADisplay dpy,
-    VAProfile profile,
-    VAEntrypoint *entrypoint_list,	/* out */
-    int *num_entrypoints		/* out */
-);
-
-/**
- * Get attributes for a given profile/entrypoint pair 
- * The caller must provide an "attrib_list" with all attributes to be 
- * retrieved.  Upon return, the attributes in "attrib_list" have been 
- * updated with their value.  Unknown attributes or attributes that are 
- * not supported for the given profile/entrypoint pair will have their 
- * value set to VA_ATTRIB_NOT_SUPPORTED
- */
-VAStatus vaGetConfigAttributes (
-    VADisplay dpy,
-    VAProfile profile,
-    VAEntrypoint entrypoint,
-    VAConfigAttrib *attrib_list, /* in/out */
-    int num_attribs
-);
-
-/** Generic ID type, can be re-typed for specific implementation */
-typedef unsigned int VAGenericID;
-
-typedef VAGenericID VAConfigID;
-
-/**
- * Create a configuration for the decode pipeline 
- * it passes in the attribute list that specifies the attributes it cares 
- * about, with the rest taking default values.  
- */
-VAStatus vaCreateConfig (
-    VADisplay dpy,
-    VAProfile profile, 
-    VAEntrypoint entrypoint, 
-    VAConfigAttrib *attrib_list,
-    int num_attribs,
-    VAConfigID *config_id /* out */
-);
-
-/**
- * Free resources associdated with a given config 
- */
-VAStatus vaDestroyConfig (
-    VADisplay dpy,
-    VAConfigID config_id
-);
-
-/**
- * Query all attributes for a given configuration 
- * The profile of the configuration is returned in "profile"
- * The entrypoint of the configuration is returned in "entrypoint"
- * The caller must provide an "attrib_list" array that can hold at least 
- * vaMaxNumConfigAttributes() entries. The actual number of attributes 
- * returned in "attrib_list" is returned in "num_attribs"
- */
-VAStatus vaQueryConfigAttributes (
-    VADisplay dpy,
-    VAConfigID config_id, 
-    VAProfile *profile, 	/* out */
-    VAEntrypoint *entrypoint, 	/* out */
-    VAConfigAttrib *attrib_list,/* out */
-    int *num_attribs 		/* out */
-);
-
-
-/**
- * Contexts and Surfaces
- *
- * Context represents a "virtual" video decode pipeline. Surfaces are render 
- * targets for a given context. The data in the surfaces are not accessible  
- * to the client and the internal data format of the surface is implementatin 
- * specific. 
- *
- * Surfaces will be bound to a context when the context is created. Once
- * a surface is bound to a given context, it can not be used to create  
- * another context. The association is removed when the context is destroyed
- * 
- * Both contexts and surfaces are identified by unique IDs and its
- * implementation specific internals are kept opaque to the clients
- */
-
-typedef VAGenericID VAContextID;
-
-typedef VAGenericID VASurfaceID;
-
-#define VA_INVALID_ID		0xffffffff
-#define VA_INVALID_SURFACE	VA_INVALID_ID
-
-/** \brief Generic value types. */
-typedef enum  {
-    VAGenericValueTypeInteger = 1,      /**< 32-bit signed integer. */
-    VAGenericValueTypeFloat,            /**< 32-bit floating-point value. */
-    VAGenericValueTypePointer,          /**< Generic pointer type */
-    VAGenericValueTypeFunc              /**< Pointer to function */
-} VAGenericValueType;
-
-/** \brief Generic function type. */
-typedef void (*VAGenericFunc)(void);
-
-/** \brief Generic value. */
-typedef struct _VAGenericValue {
-    /** \brief Value type. See #VAGenericValueType. */
-    VAGenericValueType  type;
-    /** \brief Value holder. */
-    union {
-        /** \brief 32-bit signed integer. */
-        int             i;
-        /** \brief 32-bit float. */
-        float           f;
-        /** \brief Generic pointer. */
-        void           *p;
-        /** \brief Pointer to function. */
-        VAGenericFunc   fn;
-    }                   value;
-} VAGenericValue;
-
-/** @name Surface attribute flags */
-/**@{*/
-/** \brief Surface attribute is not supported. */
-#define VA_SURFACE_ATTRIB_NOT_SUPPORTED 0x00000000
-/** \brief Surface attribute can be got through vaQuerySurfaceAttributes(). */
-#define VA_SURFACE_ATTRIB_GETTABLE      0x00000001
-/** \brief Surface attribute can be set through vaCreateSurfaces(). */
-#define VA_SURFACE_ATTRIB_SETTABLE      0x00000002
-/**@}*/
-
-/** \brief Surface attribute types. */
-typedef enum {
-    VASurfaceAttribNone = 0,
-    /**
-     * \brief Pixel format (fourcc).
-     *
-     * The value is meaningful as input to vaQuerySurfaceAttributes().
-     * If zero, the driver returns the optimal pixel format for the
-     * specified config. Otherwise, if non-zero, the value represents
-     * a pixel format (FOURCC) that is kept as is on output, if the
-     * driver supports it. Otherwise, the driver sets the value to
-     * zero and drops the \c VA_SURFACE_ATTRIB_SETTABLE flag.
-     */
-    VASurfaceAttribPixelFormat,
-    /** \brief Minimal width in pixels (int, read-only). */
-    VASurfaceAttribMinWidth,
-    /** \brief Maximal width in pixels (int, read-only). */
-    VASurfaceAttribMaxWidth,
-    /** \brief Minimal height in pixels (int, read-only). */
-    VASurfaceAttribMinHeight,
-    /** \brief Maximal height in pixels (int, read-only). */
-    VASurfaceAttribMaxHeight,
-    /** \brief Surface memory type expressed in bit fields (int, read/write). */
-    VASurfaceAttribMemoryType,
-    /** \brief External buffer descriptor (pointer, write). */
-    VASurfaceAttribExternalBufferDescriptor,
-    /** \brief Surface usage hint, gives the driver a hint of intended usage 
-     *  to optimize allocation (e.g. tiling) (int, read/write). */
-    VASurfaceAttribUsageHint,
-    /** \brief Number of surface attributes. */
-    VASurfaceAttribCount
-} VASurfaceAttribType;
-
-/** \brief Surface attribute. */
-typedef struct _VASurfaceAttrib {
-    /** \brief Type. */
-    VASurfaceAttribType type;
-    /** \brief Flags. See "Surface attribute flags". */
-    unsigned int        flags;
-    /** \brief Value. See "Surface attribute types" for the expected types. */
-    VAGenericValue      value;
-} VASurfaceAttrib;
-
-/** 
- * @name VASurfaceAttribMemoryType values in bit fields. 
- * Bit 0:7 are reserved for generic types, Bit 31:28 are reserved for 
- * Linux DRM, Bit 23:20 are reserved for Android. DRM and Android specific
- * types are defined in DRM and Android header files.
- */
-/**@{*/
-/** \brief VA memory type (default) is supported. */
-#define VA_SURFACE_ATTRIB_MEM_TYPE_VA			0x00000001
-/** \brief V4L2 buffer memory type is supported. */
-#define VA_SURFACE_ATTRIB_MEM_TYPE_V4L2			0x00000002
-/** \brief User pointer memory type is supported. */
-#define VA_SURFACE_ATTRIB_MEM_TYPE_USER_PTR		0x00000004
-/**@}*/
-
-/** 
- * \brief VASurfaceAttribExternalBuffers structure for 
- * the VASurfaceAttribExternalBufferDescriptor attribute.
- */
-typedef struct _VASurfaceAttribExternalBuffers {
-    /** \brief pixel format in fourcc. */
-    unsigned int pixel_format;
-    /** \brief width in pixels. */
-    unsigned int width;
-    /** \brief height in pixels. */
-    unsigned int height;
-    /** \brief total size of the buffer in bytes. */
-    unsigned int data_size;
-    /** \brief number of planes for planar layout */
-    unsigned int num_planes;
-    /** \brief pitch for each plane in bytes */
-    unsigned int pitches[4];
-    /** \brief offset for each plane in bytes */
-    unsigned int offsets[4];
-    /** \brief buffer handles or user pointers */
-    unsigned long *buffers;
-    /** \brief number of elements in the "buffers" array */
-    unsigned int num_buffers;
-    /** \brief flags. See "Surface external buffer descriptor flags". */
-    unsigned int flags;
-    /** \brief reserved for passing private data */
-    void *private_data;
-} VASurfaceAttribExternalBuffers;
-
-/** @name VASurfaceAttribExternalBuffers flags */
-/**@{*/
-/** \brief Enable memory tiling */
-#define VA_SURFACE_EXTBUF_DESC_ENABLE_TILING	0x00000001
-/** \brief Memory is cacheable */
-#define VA_SURFACE_EXTBUF_DESC_CACHED		0x00000002
-/** \brief Memory is non-cacheable */
-#define VA_SURFACE_EXTBUF_DESC_UNCACHED		0x00000004
-/** \brief Memory is write-combined */
-#define VA_SURFACE_EXTBUF_DESC_WC		0x00000008
-/** \brief Memory is protected */
-#define VA_SURFACE_EXTBUF_DESC_PROTECTED        0x80000000
-
-/** @name VASurfaceAttribUsageHint attribute usage hint flags */
-/**@{*/
-/** \brief Surface usage not indicated. */
-#define VA_SURFACE_ATTRIB_USAGE_HINT_GENERIC 	0x00000000
-/** \brief Surface used by video decoder. */
-#define VA_SURFACE_ATTRIB_USAGE_HINT_DECODER 	0x00000001
-/** \brief Surface used by video encoder. */
-#define VA_SURFACE_ATTRIB_USAGE_HINT_ENCODER 	0x00000002
-/** \brief Surface read by video post-processing. */
-#define VA_SURFACE_ATTRIB_USAGE_HINT_VPP_READ 	0x00000004
-/** \brief Surface written by video post-processing. */
-#define VA_SURFACE_ATTRIB_USAGE_HINT_VPP_WRITE 	0x00000008
-/** \brief Surface used for display. */
-#define VA_SURFACE_ATTRIB_USAGE_HINT_DISPLAY 	0x00000010
-
-/**@}*/
-
-/**
- * \brief Queries surface attributes for the supplied config.
- *
- * Unlike vaGetSurfaceAttributes(), this function queries for all
- * supported attributes for the supplied VA @config. In particular, if
- * the underlying hardware supports the creation of VA surfaces in
- * various formats, then this function will enumerate all pixel
- * formats that are supported.
- *
- * The \c attrib_list array is allocated by the user and \c
- * num_attribs shall be initialized to the number of allocated
- * elements in that array. Upon successful return, the actual number
- * of attributes will be overwritten into \c num_attribs. Otherwise,
- * \c VA_STATUS_ERROR_MAX_NUM_EXCEEDED is returned and \c num_attribs
- * is adjusted to the number of elements that would be returned if
- * enough space was available.
- *
- * Note: it is perfectly valid to pass NULL to the \c attrib_list
- * argument when vaQuerySurfaceAttributes() is used to determine the
- * actual number of elements that need to be allocated.
- *
- * @param[in] dpy               the VA display
- * @param[in] config            the config identifying a codec or a video
- *     processing pipeline
- * @param[out] attrib_list      the output array of #VASurfaceAttrib elements
- * @param[in,out] num_attribs   the number of elements allocated on
- *      input, the number of elements actually filled in output
- */
-VAStatus
-vaQuerySurfaceAttributes(
-    VADisplay           dpy,
-    VAConfigID          config,
-    VASurfaceAttrib    *attrib_list,
-    unsigned int       *num_attribs
-);
-
-/**
- * \brief Creates an array of surfaces
- *
- * Creates an array of surfaces. The optional list of attributes shall
- * be constructed and validated through vaGetSurfaceAttributes() or
- * constructed based based on what the underlying hardware could
- * expose through vaQuerySurfaceAttributes().
- *
- * @param[in] dpy               the VA display
- * @param[in] format            the desired surface format. See \c VA_RT_FORMAT_*
- * @param[in] width             the surface width
- * @param[in] height            the surface height
- * @param[out] surfaces         the array of newly created surfaces
- * @param[in] num_surfaces      the number of surfaces to create
- * @param[in] attrib_list       the list of (optional) attributes, or \c NULL
- * @param[in] num_attribs       the number of attributes supplied in
- *     \c attrib_list, or zero
- */
-VAStatus
-vaCreateSurfaces(
-    VADisplay           dpy,
-    unsigned int        format,
-    unsigned int        width,
-    unsigned int        height,
-    VASurfaceID        *surfaces,
-    unsigned int        num_surfaces,
-    VASurfaceAttrib    *attrib_list,
-    unsigned int        num_attribs
-);
-    
-/**
- * vaDestroySurfaces - Destroy resources associated with surfaces. 
- *  Surfaces can only be destroyed after the context associated has been 
- *  destroyed.  
- *  dpy: display
- *  surfaces: array of surfaces to destroy
- *  num_surfaces: number of surfaces in the array to be destroyed.
- */
-VAStatus vaDestroySurfaces (
-    VADisplay dpy,
-    VASurfaceID *surfaces,
-    int num_surfaces
-);
-
-#define VA_PROGRESSIVE 0x1
-/**
- * vaCreateContext - Create a context
- *  dpy: display
- *  config_id: configuration for the context
- *  picture_width: coded picture width
- *  picture_height: coded picture height
- *  flag: any combination of the following:
- *    VA_PROGRESSIVE (only progressive frame pictures in the sequence when set)
- *  render_targets: render targets (surfaces) tied to the context
- *  num_render_targets: number of render targets in the above array
- *  context: created context id upon return
- */
-VAStatus vaCreateContext (
-    VADisplay dpy,
-    VAConfigID config_id,
-    int picture_width,
-    int picture_height,
-    int flag,
-    VASurfaceID *render_targets,
-    int num_render_targets,
-    VAContextID *context		/* out */
-);
-
-/**
- * vaDestroyContext - Destroy a context 
- *  dpy: display
- *  context: context to be destroyed
- */
-VAStatus vaDestroyContext (
-    VADisplay dpy,
-    VAContextID context
-);
-
-/**
- * Buffers 
- * Buffers are used to pass various types of data from the
- * client to the server. The server maintains a data store
- * for each buffer created, and the client idenfies a buffer
- * through a unique buffer id assigned by the server.
- */
-
-typedef VAGenericID VABufferID;
-
-typedef enum
-{
-    VAPictureParameterBufferType	= 0,
-    VAIQMatrixBufferType		= 1,
-    VABitPlaneBufferType		= 2,
-    VASliceGroupMapBufferType		= 3,
-    VASliceParameterBufferType		= 4,
-    VASliceDataBufferType		= 5,
-    VAMacroblockParameterBufferType	= 6,
-    VAResidualDataBufferType		= 7,
-    VADeblockingParameterBufferType	= 8,
-    VAImageBufferType			= 9,
-    VAProtectedSliceDataBufferType	= 10,
-    VAQMatrixBufferType                 = 11,
-    VAHuffmanTableBufferType            = 12,
-    VAProbabilityBufferType             = 13,
-
-/* Following are encode buffer types */
-    VAEncCodedBufferType		= 21,
-    VAEncSequenceParameterBufferType	= 22,
-    VAEncPictureParameterBufferType	= 23,
-    VAEncSliceParameterBufferType	= 24,
-    VAEncPackedHeaderParameterBufferType = 25,
-    VAEncPackedHeaderDataBufferType     = 26,
-    VAEncMiscParameterBufferType	= 27,
-    VAEncMacroblockParameterBufferType	= 28,
-    VAEncMacroblockMapBufferType        = 29,
-/* Following are video processing buffer types */
-    /**
-     * \brief Video processing pipeline parameter buffer.
-     *
-     * This buffer describes the video processing pipeline. See
-     * #VAProcPipelineParameterBuffer for details.
-     */
-    VAProcPipelineParameterBufferType   = 41,
-    /**
-     * \brief Video filter parameter buffer.
-     *
-     * This buffer describes the video filter parameters. All buffers
-     * inherit from #VAProcFilterParameterBufferBase, thus including
-     * a unique filter buffer type.
-     *
-     * The default buffer used by most filters is #VAProcFilterParameterBuffer.
-     * Filters requiring advanced parameters include, but are not limited to,
-     * deinterlacing (#VAProcFilterParameterBufferDeinterlacing),
-     * color balance (#VAProcFilterParameterBufferColorBalance), etc.
-     */
-    VAProcFilterParameterBufferType     = 42,
-    VABufferTypeMax
-} VABufferType;
-
-typedef enum {
-  VAEncMiscParameterTypeFrameRate = 0,
-  VAEncMiscParameterTypeRateControl = 1,
-  VAEncMiscParameterTypeMaxSliceSize = 2,
-  VAEncMiscParameterTypeAIR = 3,
-  /** \brief Buffer type used to express a maximum frame size (in bits). */
-  VAEncMiscParameterTypeMaxFrameSize = 4,
-  /** \brief Buffer type used for HRD parameters. */
-  VAEncMiscParameterTypeHRD = 5,
-  VAEncMiscParameterTypeQualityLevel = 6,
-  /** \brief Buffer type used for sending skip frame parameters to the encoder's
-   * rate control, when the user has externally skipped frames. */
-  VAEncMiscParameterTypeSkipFrame = 9,
-  /** \brief Buffer type used for region-of-interest (ROI) parameters. */
-  VAEncMiscParameterTypeROI = 10
-} VAEncMiscParameterType;
-
-/** \brief Packed header type. */
-typedef enum {
-    /** \brief Packed sequence header. */
-    VAEncPackedHeaderSequence   = 1,
-    /** \brief Packed picture header. */
-    VAEncPackedHeaderPicture    = 2,
-    /** \brief Packed slice header. */
-    VAEncPackedHeaderSlice      = 3,
-    /** 
-     * \brief Packed raw header. 
-     * 
-     * Packed raw data header can be used by the client to insert a header  
-     * into the bitstream data buffer at the point it is passed, the driver 
-     * will handle the raw packed header based on "has_emulation_bytes" field
-     * in the packed header parameter structure.
-     */
-    VAEncPackedHeaderRawData    = 4,
-    /** \brief Misc packed header. See codec-specific definitions. */
-    VAEncPackedHeaderMiscMask   = 0x80000000,
-} VAEncPackedHeaderType;
-
-/** \brief Packed header parameter. */
-typedef struct _VAEncPackedHeaderParameterBuffer {
-    /** Type of the packed header buffer. See #VAEncPackedHeaderType. */
-    unsigned int                type;
-    /** \brief Size of the #VAEncPackedHeaderDataBuffer in bits. */
-    unsigned int                bit_length;
-    /** \brief Flag: buffer contains start code emulation prevention bytes? */
-    unsigned char               has_emulation_bytes;
-} VAEncPackedHeaderParameterBuffer;
-
-/**
- *  For application, e.g. set a new bitrate
- *    VABufferID buf_id;
- *    VAEncMiscParameterBuffer *misc_param;
- *    VAEncMiscParameterRateControl *misc_rate_ctrl;
- * 
- *    vaCreateBuffer(dpy, context, VAEncMiscParameterBufferType,
- *              sizeof(VAEncMiscParameterBuffer) + sizeof(VAEncMiscParameterRateControl),
- *              1, NULL, &buf_id);
- *
- *    vaMapBuffer(dpy,buf_id,(void **)&misc_param);
- *    misc_param->type = VAEncMiscParameterTypeRateControl;
- *    misc_rate_ctrl= (VAEncMiscParameterRateControl *)misc_param->data;
- *    misc_rate_ctrl->bits_per_second = 6400000;
- *    vaUnmapBuffer(dpy, buf_id);
- *    vaRenderPicture(dpy, context, &buf_id, 1);
- */
-typedef struct _VAEncMiscParameterBuffer
-{
-    VAEncMiscParameterType type;
-    unsigned int data[0];
-} VAEncMiscParameterBuffer;
-
-
-/** \brief Rate control parameters */
-typedef struct _VAEncMiscParameterRateControl
-{
-    /* this is the maximum bit-rate to be constrained by the rate control implementation */
-    unsigned int bits_per_second;
-    /* this is the bit-rate the rate control is targeting, as a percentage of the maximum
-     * bit-rate for example if target_percentage is 95 then the rate control will target
-     * a bit-rate that is 95% of the maximum bit-rate
-     */
-    unsigned int target_percentage;
-    /* windows size in milliseconds. For example if this is set to 500,
-     * then the rate control will guarantee the target bit-rate over a 500 ms window
-     */
-    unsigned int window_size;
-    /* initial QP at I frames */
-    unsigned int initial_qp;
-    unsigned int min_qp;
-    unsigned int basic_unit_size;
-    union
-    {
-        struct
-        {
-            unsigned int reset : 1;
-            unsigned int disable_frame_skip : 1; /* Disable frame skip in rate control mode */
-            unsigned int disable_bit_stuffing : 1; /* Disable bit stuffing in rate control mode */
-            unsigned int
-                mb_rate_control : 4; /* Control VA_RC_MB 0: default, 1: enable,
-                                        2: disable, other: reserved*/
-        } bits;
-        unsigned int value;
-    } rc_flags;
-} VAEncMiscParameterRateControl;
-
-typedef struct _VAEncMiscParameterFrameRate
-{
-    unsigned int framerate;
-} VAEncMiscParameterFrameRate;
-
-/**
- * Allow a maximum slice size to be specified (in bits).
- * The encoder will attempt to make sure that individual slices do not exceed this size
- * Or to signal applicate if the slice size exceed this size, see "status" of VACodedBufferSegment
- */
-typedef struct _VAEncMiscParameterMaxSliceSize
-{
-    unsigned int max_slice_size;
-} VAEncMiscParameterMaxSliceSize;
-
-typedef struct _VAEncMiscParameterAIR
-{
-    unsigned int air_num_mbs;
-    unsigned int air_threshold;
-    unsigned int air_auto; /* if set to 1 then hardware auto-tune the AIR threshold */
-} VAEncMiscParameterAIR;
-
-typedef struct _VAEncMiscParameterHRD
-{
-    unsigned int initial_buffer_fullness;       /* in bits */
-    unsigned int buffer_size;                   /* in bits */
-} VAEncMiscParameterHRD;
-
-/**
- * \brief Defines a maximum frame size (in bits).
- *
- * This misc parameter buffer defines the maximum size of a frame (in
- * bits). The encoder will try to make sure that each frame does not
- * exceed this size. Otherwise, if the frame size exceeds this size,
- * the \c status flag of #VACodedBufferSegment will contain
- * #VA_CODED_BUF_STATUS_FRAME_SIZE_OVERFLOW.
- */
-typedef struct _VAEncMiscParameterBufferMaxFrameSize {
-    /** \brief Type. Shall be set to #VAEncMiscParameterTypeMaxFrameSize. */
-    VAEncMiscParameterType      type;
-    /** \brief Maximum size of a frame (in bits). */
-    unsigned int                max_frame_size;
-} VAEncMiscParameterBufferMaxFrameSize;
-
-/**
- * \brief Encoding quality level.
- *
- * The encoding quality could be set through this structure, if the implementation  
- * supports multiple quality levels. The quality level set through this structure is 
- * persistent over the entire coded sequence, or until a new structure is being sent.
- * The quality level range can be queried through the VAConfigAttribEncQualityRange 
- * attribute. A lower value means higher quality, and a value of 1 represents the highest 
- * quality. The quality level setting is used as a trade-off between quality and speed/power 
- * consumption, with higher quality corresponds to lower speed and higher power consumption. 
- */
-typedef struct _VAEncMiscParameterBufferQualityLevel {
-    /** \brief Encoding quality level setting. When set to 0, default quality
-     * level is used.
-     */
-    unsigned int                quality_level;
-} VAEncMiscParameterBufferQualityLevel;
-
-/**
- * \brief Encoding skip frame.
- *
- * The application may choose to skip frames externally to the encoder (e.g. drop completely or 
- * code as all skip's). For rate control purposes the encoder will need to know the size and number 
- * of skipped frames.  Skip frame(s) indicated through this structure is applicable only to the 
- * current frame.  It is allowed for the application to still send in packed headers for the driver to 
- * pack, although no frame will be encoded (e.g. for HW to encrypt the frame).  
- */
-typedef struct _VAEncMiscParameterSkipFrame {
-    /** \brief Indicates skip frames as below.
-      * 0: Encode as normal, no skip.
-      * 1: One or more frames were skipped prior to the current frame, encode the current frame as normal.  
-      * 2: The current frame is to be skipped, do not encode it but pack/encrypt the packed header contents
-      *    (all except VAEncPackedHeaderSlice) which could contain actual frame contents (e.g. pack the frame 
-      *    in VAEncPackedHeaderPicture).  */
-    unsigned char               skip_frame_flag;
-    /** \brief The number of frames skipped prior to the current frame.  Valid when skip_frame_flag = 1. */
-    unsigned char               num_skip_frames;
-    /** \brief When skip_frame_flag = 1, the size of the skipped frames in bits.   When skip_frame_flag = 2, 
-      * the size of the current skipped frame that is to be packed/encrypted in bits. */
-    unsigned int                size_skip_frames;
-} VAEncMiscParameterSkipFrame;
-
-/**
- * \brief Encoding region-of-interest (ROI).
- *
- * The encoding ROI can be set through VAEncMiscParameterBufferROI, if the
- * implementation supports ROI input. The ROI set through this structure is
- * applicable only to the current frame or field, so must be sent every frame or
- * field to be applied.  The number of supported ROIs can be queried through the
- * VAConfigAttribEncROI.  The encoder will use the ROI information to adjust the
- * QP values of the MB's that fall within the ROIs.
- */
-typedef struct _VAEncROI {
-  /** \brief Defines the ROI boundary in pixels, the driver will map it to
-   * appropriate codec coding units.  It is relative to frame coordinates for
-   * the frame case and to field coordinates for the field case. */
-  VARectangle roi_rectangle;
-  /** \brief When VAConfigAttribRateControl == VA_RC_CQP then roi_value specifes
-   * the delta QP that will be added on top of the frame level QP.  For other
-   * rate control modes, roi_value specifies the priority of the ROI region
-   * relative to the non-ROI region.  It can be positive (more important) or
-   * negative (less important) values and is compared with non-ROI region
-   * (taken as value 0). E.g. ROI region with roi_value -3 is less important
-   * than the non-ROI region (roi_value implied to be 0) which is less
-   * important than ROI region with roi_value +2.  For overlapping regions, the
-   * roi_value that is first in the ROI array will have priority.   */
-  char roi_value;
-} VAEncROI;
-
-typedef struct _VAEncMiscParameterBufferROI {
-  /** \brief Number of ROIs being sent.*/
-  unsigned int num_roi;
-
-  /** \brief Valid when VAConfigAttribRateControl != VA_RC_CQP, then the
-   * encoder's rate control will determine actual delta QPs.  Specifies the
-   * max/min allowed delta QPs. */
-  char max_delta_qp;
-  char min_delta_qp;
-
-  /** \brief Pointer to a VAEncROI array with num_roi elements.  It is relative
-   * to frame coordinates for the frame case and to field coordinates for the
-   * field case.*/
-  VAEncROI* roi;
-} VAEncMiscParameterBufferROI;
-
-/**
- * There will be cases where the bitstream buffer will not have enough room to
- * hold the data for the entire slice, and the following flags will be used in
- * the slice parameter to signal to the server for the possible cases. If a
- * slice parameter buffer and slice data buffer pair is sent to the server with
- * the slice data partially in the slice data buffer (BEGIN and MIDDLE cases
- * below), then a slice parameter and data buffer needs to be sent again to
- * complete this slice.
- */
-#define VA_SLICE_DATA_FLAG_ALL		0x00	/* whole slice is in the buffer */
-#define VA_SLICE_DATA_FLAG_BEGIN	0x01	/* The beginning of the slice is in the buffer but the end if not */
-#define VA_SLICE_DATA_FLAG_MIDDLE	0x02	/* Neither beginning nor end of the slice is in the buffer */
-#define VA_SLICE_DATA_FLAG_END		0x04	/* end of the slice is in the buffer */
-
-/* Codec-independent Slice Parameter Buffer base */
-typedef struct _VASliceParameterBufferBase
-{
-    unsigned int slice_data_size;	/* number of bytes in the slice data buffer for this slice */
-    unsigned int slice_data_offset;	/* the offset to the first byte of slice data */
-    unsigned int slice_data_flag;	/* see VA_SLICE_DATA_FLAG_XXX definitions */
-} VASliceParameterBufferBase;
-
-/**********************************
- * JPEG common  data structures
- **********************************/
-/**
- * \brief Huffman table for JPEG decoding.
- *
- * This structure holds the complete Huffman tables. This is an
- * aggregation of all Huffman table (DHT) segments maintained by the
- * application. i.e. up to 2 Huffman tables are stored in there for
- * baseline profile.
- *
- * The #load_huffman_table array can be used as a hint to notify the
- * VA driver implementation about which table(s) actually changed
- * since the last submission of this buffer.
- */
-typedef struct _VAHuffmanTableBufferJPEGBaseline {
-    /** \brief Specifies which #huffman_table is valid. */
-    unsigned char       load_huffman_table[2];
-    /** \brief Huffman tables indexed by table identifier (Th). */
-    struct {
-        /** @name DC table (up to 12 categories) */
-        /**@{*/
-        /** \brief Number of Huffman codes of length i + 1 (Li). */
-        unsigned char   num_dc_codes[16];
-        /** \brief Value associated with each Huffman code (Vij). */
-        unsigned char   dc_values[12];
-        /**@}*/
-        /** @name AC table (2 special codes + up to 16 * 10 codes) */
-        /**@{*/
-        /** \brief Number of Huffman codes of length i + 1 (Li). */
-        unsigned char   num_ac_codes[16];
-        /** \brief Value associated with each Huffman code (Vij). */
-        unsigned char   ac_values[162];
-        /** \brief Padding to 4-byte boundaries. Must be set to zero. */
-        unsigned char   pad[2];
-        /**@}*/
-    }                   huffman_table[2];
-} VAHuffmanTableBufferJPEGBaseline;
-
-/****************************
- * MPEG-2 data structures
- ****************************/
- 
-/* MPEG-2 Picture Parameter Buffer */
-/* 
- * For each frame or field, and before any slice data, a single
- * picture parameter buffer must be send.
- */
-typedef struct _VAPictureParameterBufferMPEG2
-{
-    unsigned short horizontal_size;
-    unsigned short vertical_size;
-    VASurfaceID forward_reference_picture;
-    VASurfaceID backward_reference_picture;
-    /* meanings of the following fields are the same as in the standard */
-    int picture_coding_type;
-    int f_code; /* pack all four fcode into this */
-    union {
-        struct {
-            unsigned int intra_dc_precision		: 2; 
-            unsigned int picture_structure		: 2; 
-            unsigned int top_field_first		: 1; 
-            unsigned int frame_pred_frame_dct		: 1; 
-            unsigned int concealment_motion_vectors	: 1;
-            unsigned int q_scale_type			: 1;
-            unsigned int intra_vlc_format		: 1;
-            unsigned int alternate_scan			: 1;
-            unsigned int repeat_first_field		: 1;
-            unsigned int progressive_frame		: 1;
-            unsigned int is_first_field			: 1; /* indicate whether the current field
-                                                              * is the first field for field picture
-                                                              */
-        } bits;
-        unsigned int value;
-    } picture_coding_extension;
-} VAPictureParameterBufferMPEG2;
-
-/** MPEG-2 Inverse Quantization Matrix Buffer */
-typedef struct _VAIQMatrixBufferMPEG2
-{
-    /** \brief Same as the MPEG-2 bitstream syntax element. */
-    int load_intra_quantiser_matrix;
-    /** \brief Same as the MPEG-2 bitstream syntax element. */
-    int load_non_intra_quantiser_matrix;
-    /** \brief Same as the MPEG-2 bitstream syntax element. */
-    int load_chroma_intra_quantiser_matrix;
-    /** \brief Same as the MPEG-2 bitstream syntax element. */
-    int load_chroma_non_intra_quantiser_matrix;
-    /** \brief Luminance intra matrix, in zig-zag scan order. */
-    unsigned char intra_quantiser_matrix[64];
-    /** \brief Luminance non-intra matrix, in zig-zag scan order. */
-    unsigned char non_intra_quantiser_matrix[64];
-    /** \brief Chroma intra matrix, in zig-zag scan order. */
-    unsigned char chroma_intra_quantiser_matrix[64];
-    /** \brief Chroma non-intra matrix, in zig-zag scan order. */
-    unsigned char chroma_non_intra_quantiser_matrix[64];
-} VAIQMatrixBufferMPEG2;
-
-/** MPEG-2 Slice Parameter Buffer */
-typedef struct _VASliceParameterBufferMPEG2
-{
-    unsigned int slice_data_size;/* number of bytes in the slice data buffer for this slice */
-    unsigned int slice_data_offset;/* the offset to the first byte of slice data */
-    unsigned int slice_data_flag; /* see VA_SLICE_DATA_FLAG_XXX defintions */
-    unsigned int macroblock_offset;/* the offset to the first bit of MB from the first byte of slice data */
-    unsigned int slice_horizontal_position;
-    unsigned int slice_vertical_position;
-    int quantiser_scale_code;
-    int intra_slice_flag;
-} VASliceParameterBufferMPEG2;
-
-/** MPEG-2 Macroblock Parameter Buffer */
-typedef struct _VAMacroblockParameterBufferMPEG2
-{
-    unsigned short macroblock_address;
-    /* 
-     * macroblock_address (in raster scan order)
-     * top-left: 0
-     * bottom-right: picture-height-in-mb*picture-width-in-mb - 1
-     */
-    unsigned char macroblock_type;  /* see definition below */
-    union {
-        struct {
-            unsigned int frame_motion_type		: 2; 
-            unsigned int field_motion_type		: 2; 
-            unsigned int dct_type			: 1; 
-        } bits;
-        unsigned int value;
-    } macroblock_modes;
-    unsigned char motion_vertical_field_select; 
-    /* 
-     * motion_vertical_field_select:
-     * see section 6.3.17.2 in the spec
-     * only the lower 4 bits are used
-     * bit 0: first vector forward
-     * bit 1: first vector backward
-     * bit 2: second vector forward
-     * bit 3: second vector backward
-     */
-    short PMV[2][2][2]; /* see Table 7-7 in the spec */
-    unsigned short coded_block_pattern;
-    /* 
-     * The bitplanes for coded_block_pattern are described 
-     * in Figure 6.10-12 in the spec
-     */
-     
-    /* Number of skipped macroblocks after this macroblock */
-    unsigned short num_skipped_macroblocks;
-} VAMacroblockParameterBufferMPEG2;
-
-/* 
- * OR'd flags for macroblock_type (section 6.3.17.1 in the spec)
- */
-#define VA_MB_TYPE_MOTION_FORWARD	0x02
-#define VA_MB_TYPE_MOTION_BACKWARD	0x04
-#define VA_MB_TYPE_MOTION_PATTERN	0x08
-#define VA_MB_TYPE_MOTION_INTRA		0x10
-
-/**
- * MPEG-2 Residual Data Buffer 
- * For each macroblock, there wil be 64 shorts (16-bit) in the 
- * residual data buffer
- */
-
-/****************************
- * MPEG-4 Part 2 data structures
- ****************************/
- 
-/* MPEG-4 Picture Parameter Buffer */
-/* 
- * For each frame or field, and before any slice data, a single
- * picture parameter buffer must be send.
- */
-typedef struct _VAPictureParameterBufferMPEG4
-{
-    unsigned short vop_width;
-    unsigned short vop_height;
-    VASurfaceID forward_reference_picture;
-    VASurfaceID backward_reference_picture;
-    union {
-        struct {
-            unsigned int short_video_header		: 1; 
-            unsigned int chroma_format			: 2; 
-            unsigned int interlaced			: 1; 
-            unsigned int obmc_disable			: 1; 
-            unsigned int sprite_enable			: 2; 
-            unsigned int sprite_warping_accuracy	: 2; 
-            unsigned int quant_type			: 1; 
-            unsigned int quarter_sample			: 1; 
-            unsigned int data_partitioned		: 1; 
-            unsigned int reversible_vlc			: 1; 
-            unsigned int resync_marker_disable		: 1; 
-        } bits;
-        unsigned int value;
-    } vol_fields;
-    unsigned char no_of_sprite_warping_points;
-    short sprite_trajectory_du[3];
-    short sprite_trajectory_dv[3];
-    unsigned char quant_precision;
-    union {
-        struct {
-            unsigned int vop_coding_type		: 2; 
-            unsigned int backward_reference_vop_coding_type	: 2; 
-            unsigned int vop_rounding_type		: 1; 
-            unsigned int intra_dc_vlc_thr		: 3; 
-            unsigned int top_field_first		: 1; 
-            unsigned int alternate_vertical_scan_flag	: 1; 
-        } bits;
-        unsigned int value;
-    } vop_fields;
-    unsigned char vop_fcode_forward;
-    unsigned char vop_fcode_backward;
-    unsigned short vop_time_increment_resolution;
-    /* short header related */
-    unsigned char num_gobs_in_vop;
-    unsigned char num_macroblocks_in_gob;
-    /* for direct mode prediction */
-    short TRB;
-    short TRD;
-} VAPictureParameterBufferMPEG4;
-
-/** MPEG-4 Inverse Quantization Matrix Buffer */
-typedef struct _VAIQMatrixBufferMPEG4
-{
-    /** Same as the MPEG-4:2 bitstream syntax element. */
-    int load_intra_quant_mat;
-    /** Same as the MPEG-4:2 bitstream syntax element. */
-    int load_non_intra_quant_mat;
-    /** The matrix for intra blocks, in zig-zag scan order. */
-    unsigned char intra_quant_mat[64];
-    /** The matrix for non-intra blocks, in zig-zag scan order. */
-    unsigned char non_intra_quant_mat[64];
-} VAIQMatrixBufferMPEG4;
-
-/** MPEG-4 Slice Parameter Buffer */
-typedef struct _VASliceParameterBufferMPEG4
-{
-    unsigned int slice_data_size;/* number of bytes in the slice data buffer for this slice */
-    unsigned int slice_data_offset;/* the offset to the first byte of slice data */
-    unsigned int slice_data_flag; /* see VA_SLICE_DATA_FLAG_XXX defintions */
-    unsigned int macroblock_offset;/* the offset to the first bit of MB from the first byte of slice data */
-    unsigned int macroblock_number;
-    int quant_scale;
-} VASliceParameterBufferMPEG4;
-
-/**
- VC-1 data structures
-*/
-
-typedef enum   /* see 7.1.1.32 */
-{
-    VAMvMode1Mv                        = 0,
-    VAMvMode1MvHalfPel                 = 1,
-    VAMvMode1MvHalfPelBilinear         = 2,
-    VAMvModeMixedMv                    = 3,
-    VAMvModeIntensityCompensation      = 4 
-} VAMvModeVC1;
-
-/** VC-1 Picture Parameter Buffer */
-/* 
- * For each picture, and before any slice data, a picture parameter
- * buffer must be send. Multiple picture parameter buffers may be
- * sent for a single picture. In that case picture parameters will
- * apply to all slice data that follow it until a new picture
- * parameter buffer is sent.
- *
- * Notes:
- *   pic_quantizer_type should be set to the applicable quantizer
- *   type as defined by QUANTIZER (J.1.19) and either
- *   PQUANTIZER (7.1.1.8) or PQINDEX (7.1.1.6)
- */
-typedef struct _VAPictureParameterBufferVC1
-{
-    VASurfaceID forward_reference_picture;
-    VASurfaceID backward_reference_picture;
-    /* if out-of-loop post-processing is done on the render
-       target, then we need to keep the in-loop decoded 
-       picture as a reference picture */
-    VASurfaceID inloop_decoded_picture;
-
-    /* sequence layer for AP or meta data for SP and MP */
-    union {
-        struct {
-            unsigned int pulldown	: 1; /* SEQUENCE_LAYER::PULLDOWN */
-            unsigned int interlace	: 1; /* SEQUENCE_LAYER::INTERLACE */
-            unsigned int tfcntrflag	: 1; /* SEQUENCE_LAYER::TFCNTRFLAG */
-            unsigned int finterpflag	: 1; /* SEQUENCE_LAYER::FINTERPFLAG */
-            unsigned int psf		: 1; /* SEQUENCE_LAYER::PSF */
-            unsigned int multires	: 1; /* METADATA::MULTIRES */
-            unsigned int overlap	: 1; /* METADATA::OVERLAP */
-            unsigned int syncmarker	: 1; /* METADATA::SYNCMARKER */
-            unsigned int rangered	: 1; /* METADATA::RANGERED */
-            unsigned int max_b_frames	: 3; /* METADATA::MAXBFRAMES */
-            unsigned int profile	: 2; /* SEQUENCE_LAYER::PROFILE or The MSB of METADATA::PROFILE */
-        } bits;
-        unsigned int value;
-    } sequence_fields;
-
-    unsigned short coded_width;		/* ENTRY_POINT_LAYER::CODED_WIDTH */
-    unsigned short coded_height;	/* ENTRY_POINT_LAYER::CODED_HEIGHT */
-    union {
-	struct {
-            unsigned int broken_link	: 1; /* ENTRY_POINT_LAYER::BROKEN_LINK */
-            unsigned int closed_entry	: 1; /* ENTRY_POINT_LAYER::CLOSED_ENTRY */
-            unsigned int panscan_flag	: 1; /* ENTRY_POINT_LAYER::PANSCAN_FLAG */
-            unsigned int loopfilter	: 1; /* ENTRY_POINT_LAYER::LOOPFILTER */
-	} bits;
-	unsigned int value;
-    } entrypoint_fields;
-    unsigned char conditional_overlap_flag; /* ENTRY_POINT_LAYER::CONDOVER */
-    unsigned char fast_uvmc_flag;	/* ENTRY_POINT_LAYER::FASTUVMC */
-    union {
-        struct {
-            unsigned int luma_flag	: 1; /* ENTRY_POINT_LAYER::RANGE_MAPY_FLAG */
-            unsigned int luma		: 3; /* ENTRY_POINT_LAYER::RANGE_MAPY */
-            unsigned int chroma_flag	: 1; /* ENTRY_POINT_LAYER::RANGE_MAPUV_FLAG */
-            unsigned int chroma		: 3; /* ENTRY_POINT_LAYER::RANGE_MAPUV */
-        } bits;
-        unsigned int value;
-    } range_mapping_fields;
-
-    unsigned char b_picture_fraction;	/* PICTURE_LAYER::BFRACTION */
-    unsigned char cbp_table;		/* PICTURE_LAYER::CBPTAB/ICBPTAB */
-    unsigned char mb_mode_table;	/* PICTURE_LAYER::MBMODETAB */
-    unsigned char range_reduction_frame;/* PICTURE_LAYER::RANGEREDFRM */
-    unsigned char rounding_control;	/* PICTURE_LAYER::RNDCTRL */
-    unsigned char post_processing;	/* PICTURE_LAYER::POSTPROC */
-    unsigned char picture_resolution_index;	/* PICTURE_LAYER::RESPIC */
-    unsigned char luma_scale;		/* PICTURE_LAYER::LUMSCALE */
-    unsigned char luma_shift;		/* PICTURE_LAYER::LUMSHIFT */
-    union {
-        struct {
-            unsigned int picture_type		: 3; /* PICTURE_LAYER::PTYPE */
-            unsigned int frame_coding_mode	: 3; /* PICTURE_LAYER::FCM */
-            unsigned int top_field_first	: 1; /* PICTURE_LAYER::TFF */
-            unsigned int is_first_field		: 1; /* set to 1 if it is the first field */
-            unsigned int intensity_compensation	: 1; /* PICTURE_LAYER::INTCOMP */
-        } bits;
-        unsigned int value;
-    } picture_fields;
-    union {
-        struct {
-            unsigned int mv_type_mb	: 1; 	/* PICTURE::MVTYPEMB */
-            unsigned int direct_mb	: 1; 	/* PICTURE::DIRECTMB */
-            unsigned int skip_mb	: 1; 	/* PICTURE::SKIPMB */
-            unsigned int field_tx	: 1; 	/* PICTURE::FIELDTX */
-            unsigned int forward_mb	: 1;	/* PICTURE::FORWARDMB */
-            unsigned int ac_pred	: 1;	/* PICTURE::ACPRED */
-            unsigned int overflags	: 1;	/* PICTURE::OVERFLAGS */
-        } flags;
-        unsigned int value;
-    } raw_coding;
-    union {
-        struct {
-            unsigned int bp_mv_type_mb   : 1;    /* PICTURE::MVTYPEMB */
-            unsigned int bp_direct_mb    : 1;    /* PICTURE::DIRECTMB */
-            unsigned int bp_skip_mb      : 1;    /* PICTURE::SKIPMB */  
-            unsigned int bp_field_tx     : 1;    /* PICTURE::FIELDTX */ 
-            unsigned int bp_forward_mb   : 1;    /* PICTURE::FORWARDMB */
-            unsigned int bp_ac_pred      : 1;    /* PICTURE::ACPRED */   
-            unsigned int bp_overflags    : 1;    /* PICTURE::OVERFLAGS */
-        } flags;
-        unsigned int value;
-    } bitplane_present; /* signal what bitplane is being passed via the bitplane buffer */
-    union {
-        struct {
-            unsigned int reference_distance_flag : 1;/* PICTURE_LAYER::REFDIST_FLAG */
-            unsigned int reference_distance	: 5;/* PICTURE_LAYER::REFDIST */
-            unsigned int num_reference_pictures: 1;/* PICTURE_LAYER::NUMREF */
-            unsigned int reference_field_pic_indicator	: 1;/* PICTURE_LAYER::REFFIELD */
-        } bits;
-        unsigned int value;
-    } reference_fields;
-    union {
-        struct {
-            unsigned int mv_mode		: 3; /* PICTURE_LAYER::MVMODE */
-            unsigned int mv_mode2		: 3; /* PICTURE_LAYER::MVMODE2 */
-            unsigned int mv_table		: 3; /* PICTURE_LAYER::MVTAB/IMVTAB */
-            unsigned int two_mv_block_pattern_table: 2; /* PICTURE_LAYER::2MVBPTAB */
-            unsigned int four_mv_switch		: 1; /* PICTURE_LAYER::4MVSWITCH */
-            unsigned int four_mv_block_pattern_table : 2; /* PICTURE_LAYER::4MVBPTAB */
-            unsigned int extended_mv_flag	: 1; /* ENTRY_POINT_LAYER::EXTENDED_MV */
-            unsigned int extended_mv_range	: 2; /* PICTURE_LAYER::MVRANGE */
-            unsigned int extended_dmv_flag	: 1; /* ENTRY_POINT_LAYER::EXTENDED_DMV */
-            unsigned int extended_dmv_range	: 2; /* PICTURE_LAYER::DMVRANGE */
-        } bits;
-        unsigned int value;
-    } mv_fields;
-    union {
-        struct {
-            unsigned int dquant	: 2; 	/* ENTRY_POINT_LAYER::DQUANT */
-            unsigned int quantizer     : 2; 	/* ENTRY_POINT_LAYER::QUANTIZER */
-            unsigned int half_qp	: 1; 	/* PICTURE_LAYER::HALFQP */
-            unsigned int pic_quantizer_scale : 5;/* PICTURE_LAYER::PQUANT */
-            unsigned int pic_quantizer_type : 1;/* PICTURE_LAYER::PQUANTIZER */
-            unsigned int dq_frame	: 1; 	/* VOPDQUANT::DQUANTFRM */
-            unsigned int dq_profile	: 2; 	/* VOPDQUANT::DQPROFILE */
-            unsigned int dq_sb_edge	: 2; 	/* VOPDQUANT::DQSBEDGE */
-            unsigned int dq_db_edge 	: 2; 	/* VOPDQUANT::DQDBEDGE */
-            unsigned int dq_binary_level : 1; 	/* VOPDQUANT::DQBILEVEL */
-            unsigned int alt_pic_quantizer : 5;/* VOPDQUANT::ALTPQUANT */
-        } bits;
-        unsigned int value;
-    } pic_quantizer_fields;
-    union {
-        struct {
-            unsigned int variable_sized_transform_flag	: 1;/* ENTRY_POINT_LAYER::VSTRANSFORM */
-            unsigned int mb_level_transform_type_flag	: 1;/* PICTURE_LAYER::TTMBF */
-            unsigned int frame_level_transform_type	: 2;/* PICTURE_LAYER::TTFRM */
-            unsigned int transform_ac_codingset_idx1	: 2;/* PICTURE_LAYER::TRANSACFRM */
-            unsigned int transform_ac_codingset_idx2	: 2;/* PICTURE_LAYER::TRANSACFRM2 */
-            unsigned int intra_transform_dc_table	: 1;/* PICTURE_LAYER::TRANSDCTAB */
-        } bits;
-        unsigned int value;
-    } transform_fields;
-} VAPictureParameterBufferVC1;
-
-/** VC-1 Bitplane Buffer
-There will be at most three bitplanes coded in any picture header. To send 
-the bitplane data more efficiently, each byte is divided in two nibbles, with
-each nibble carrying three bitplanes for one macroblock.  The following table
-shows the bitplane data arrangement within each nibble based on the picture
-type.
-
-Picture Type	Bit3		Bit2		Bit1		Bit0
-I or BI				OVERFLAGS	ACPRED		FIELDTX
-P				MYTYPEMB	SKIPMB		DIRECTMB
-B				FORWARDMB	SKIPMB		DIRECTMB
-
-Within each byte, the lower nibble is for the first MB and the upper nibble is 
-for the second MB.  E.g. the lower nibble of the first byte in the bitplane
-buffer is for Macroblock #1 and the upper nibble of the first byte is for 
-Macroblock #2 in the first row.
-*/
-
-/* VC-1 Slice Parameter Buffer */
-typedef struct _VASliceParameterBufferVC1
-{
-    unsigned int slice_data_size;/* number of bytes in the slice data buffer for this slice */
-    unsigned int slice_data_offset;/* the offset to the first byte of slice data */
-    unsigned int slice_data_flag; /* see VA_SLICE_DATA_FLAG_XXX defintions */
-    unsigned int macroblock_offset;/* the offset to the first bit of MB from the first byte of slice data */
-    unsigned int slice_vertical_position;
-} VASliceParameterBufferVC1;
-
-/* VC-1 Slice Data Buffer */
-/* 
-This is simplely a buffer containing raw bit-stream bytes 
-*/
-
-/****************************
- * H.264/AVC data structures
- ****************************/
-
-typedef struct _VAPictureH264
-{
-    VASurfaceID picture_id;
-    unsigned int frame_idx;
-    unsigned int flags;
-    signed int TopFieldOrderCnt;
-    signed int BottomFieldOrderCnt;
-} VAPictureH264;
-/* flags in VAPictureH264 could be OR of the following */
-#define VA_PICTURE_H264_INVALID			0x00000001
-#define VA_PICTURE_H264_TOP_FIELD		0x00000002
-#define VA_PICTURE_H264_BOTTOM_FIELD		0x00000004
-#define VA_PICTURE_H264_SHORT_TERM_REFERENCE	0x00000008
-#define VA_PICTURE_H264_LONG_TERM_REFERENCE	0x00000010
-
-/** H.264 Picture Parameter Buffer */
-/* 
- * For each picture, and before any slice data, a single
- * picture parameter buffer must be send.
- */
-typedef struct _VAPictureParameterBufferH264
-{
-    VAPictureH264 CurrPic;
-    VAPictureH264 ReferenceFrames[16];	/* in DPB */
-    unsigned short picture_width_in_mbs_minus1;
-    unsigned short picture_height_in_mbs_minus1;
-    unsigned char bit_depth_luma_minus8;
-    unsigned char bit_depth_chroma_minus8;
-    unsigned char num_ref_frames;
-    union {
-        struct {
-            unsigned int chroma_format_idc			: 2; 
-            unsigned int residual_colour_transform_flag		: 1; 
-            unsigned int gaps_in_frame_num_value_allowed_flag	: 1; 
-            unsigned int frame_mbs_only_flag			: 1; 
-            unsigned int mb_adaptive_frame_field_flag		: 1; 
-            unsigned int direct_8x8_inference_flag		: 1; 
-            unsigned int MinLumaBiPredSize8x8			: 1; /* see A.3.3.2 */
-            unsigned int log2_max_frame_num_minus4		: 4;
-            unsigned int pic_order_cnt_type			: 2;
-            unsigned int log2_max_pic_order_cnt_lsb_minus4	: 4;
-            unsigned int delta_pic_order_always_zero_flag	: 1;
-        } bits;
-        unsigned int value;
-    } seq_fields;
-    unsigned char num_slice_groups_minus1;
-    unsigned char slice_group_map_type;
-    unsigned short slice_group_change_rate_minus1;
-    signed char pic_init_qp_minus26;
-    signed char pic_init_qs_minus26;
-    signed char chroma_qp_index_offset;
-    signed char second_chroma_qp_index_offset;
-    union {
-        struct {
-            unsigned int entropy_coding_mode_flag	: 1;
-            unsigned int weighted_pred_flag		: 1;
-            unsigned int weighted_bipred_idc		: 2;
-            unsigned int transform_8x8_mode_flag	: 1;
-            unsigned int field_pic_flag			: 1;
-            unsigned int constrained_intra_pred_flag	: 1;
-            unsigned int pic_order_present_flag			: 1;
-            unsigned int deblocking_filter_control_present_flag : 1;
-            unsigned int redundant_pic_cnt_present_flag		: 1;
-            unsigned int reference_pic_flag			: 1; /* nal_ref_idc != 0 */
-        } bits;
-        unsigned int value;
-    } pic_fields;
-    unsigned short frame_num;
-} VAPictureParameterBufferH264;
-
-/** H.264 Inverse Quantization Matrix Buffer */
-typedef struct _VAIQMatrixBufferH264
-{
-    /** \brief 4x4 scaling list, in raster scan order. */
-    unsigned char ScalingList4x4[6][16];
-    /** \brief 8x8 scaling list, in raster scan order. */
-    unsigned char ScalingList8x8[2][64];
-} VAIQMatrixBufferH264;
-
-/**
- * H.264 Slice Group Map Buffer 
- * When VAPictureParameterBufferH264::num_slice_group_minus1 is not equal to 0,
- * A slice group map buffer should be sent for each picture if required. The buffer
- * is sent only when there is a change in the mapping values.
- * The slice group map buffer map "map units" to slice groups as specified in 
- * section 8.2.2 of the H.264 spec. The buffer will contain one byte for each macroblock 
- * in raster scan order
- */ 
-
-/** H.264 Slice Parameter Buffer */
-typedef struct _VASliceParameterBufferH264
-{
-    unsigned int slice_data_size;/* number of bytes in the slice data buffer for this slice */
-    /** \brief Byte offset to the NAL Header Unit for this slice. */
-    unsigned int slice_data_offset;
-    unsigned int slice_data_flag; /* see VA_SLICE_DATA_FLAG_XXX defintions */
-    /**
-     * \brief Bit offset from NAL Header Unit to the begining of slice_data().
-     *
-     * This bit offset is relative to and includes the NAL unit byte
-     * and represents the number of bits parsed in the slice_header()
-     * after the removal of any emulation prevention bytes in
-     * there. However, the slice data buffer passed to the hardware is
-     * the original bitstream, thus including any emulation prevention
-     * bytes.
-     */
-    unsigned short slice_data_bit_offset;
-    unsigned short first_mb_in_slice;
-    unsigned char slice_type;
-    unsigned char direct_spatial_mv_pred_flag;
-    unsigned char num_ref_idx_l0_active_minus1;
-    unsigned char num_ref_idx_l1_active_minus1;
-    unsigned char cabac_init_idc;
-    char slice_qp_delta;
-    unsigned char disable_deblocking_filter_idc;
-    char slice_alpha_c0_offset_div2;
-    char slice_beta_offset_div2;
-    VAPictureH264 RefPicList0[32];	/* See 8.2.4.2 */
-    VAPictureH264 RefPicList1[32];	/* See 8.2.4.2 */
-    unsigned char luma_log2_weight_denom;
-    unsigned char chroma_log2_weight_denom;
-    unsigned char luma_weight_l0_flag;
-    short luma_weight_l0[32];
-    short luma_offset_l0[32];
-    unsigned char chroma_weight_l0_flag;
-    short chroma_weight_l0[32][2];
-    short chroma_offset_l0[32][2];
-    unsigned char luma_weight_l1_flag;
-    short luma_weight_l1[32];
-    short luma_offset_l1[32];
-    unsigned char chroma_weight_l1_flag;
-    short chroma_weight_l1[32][2];
-    short chroma_offset_l1[32][2];
-} VASliceParameterBufferH264;
-
-/****************************
- * Common encode data structures 
- ****************************/
-typedef enum
-{
-    VAEncPictureTypeIntra		= 0,
-    VAEncPictureTypePredictive		= 1,
-    VAEncPictureTypeBidirectional	= 2,
-} VAEncPictureType;
-
-/* Encode Slice Parameter Buffer */
-typedef struct _VAEncSliceParameterBuffer
-{
-    unsigned int start_row_number;	/* starting MB row number for this slice */
-    unsigned int slice_height;	/* slice height measured in MB */
-    union {
-        struct {
-            unsigned int is_intra	: 1;
-            unsigned int disable_deblocking_filter_idc : 2;
-            unsigned int uses_long_term_ref		:1;
-            unsigned int is_long_term_ref		:1;
-        } bits;
-        unsigned int value;
-    } slice_flags;
-} VAEncSliceParameterBuffer;
-
-
-/****************************
- * H.263 specific encode data structures
- ****************************/
-
-typedef struct _VAEncSequenceParameterBufferH263
-{
-    unsigned int intra_period;
-    unsigned int bits_per_second;
-    unsigned int frame_rate;
-    unsigned int initial_qp;
-    unsigned int min_qp;
-} VAEncSequenceParameterBufferH263;
-
-typedef struct _VAEncPictureParameterBufferH263
-{
-    VASurfaceID reference_picture;
-    VASurfaceID reconstructed_picture;
-    VABufferID coded_buf;
-    unsigned short picture_width;
-    unsigned short picture_height;
-    VAEncPictureType picture_type;
-} VAEncPictureParameterBufferH263;
-
-/****************************
- * MPEG-4 specific encode data structures
- ****************************/
-
-typedef struct _VAEncSequenceParameterBufferMPEG4
-{
-    unsigned char profile_and_level_indication;
-    unsigned int intra_period;
-    unsigned int video_object_layer_width;
-    unsigned int video_object_layer_height;
-    unsigned int vop_time_increment_resolution;
-    unsigned int fixed_vop_rate;
-    unsigned int fixed_vop_time_increment;
-    unsigned int bits_per_second;
-    unsigned int frame_rate;
-    unsigned int initial_qp;
-    unsigned int min_qp;
-} VAEncSequenceParameterBufferMPEG4;
-
-typedef struct _VAEncPictureParameterBufferMPEG4
-{
-    VASurfaceID reference_picture;
-    VASurfaceID reconstructed_picture;
-    VABufferID coded_buf;
-    unsigned short picture_width;
-    unsigned short picture_height;
-    unsigned int modulo_time_base; /* number of 1s */
-    unsigned int vop_time_increment;
-    VAEncPictureType picture_type;
-} VAEncPictureParameterBufferMPEG4;
-
-
-
-/** Buffer functions */
-
-/**
- * Creates a buffer for "num_elements" elements of "size" bytes and 
- * initalize with "data".
- * if "data" is null, then the contents of the buffer data store
- * are undefined.
- * Basically there are two ways to get buffer data to the server side. One is 
- * to call vaCreateBuffer() with a non-null "data", which results the data being
- * copied to the data store on the server side.  A different method that 
- * eliminates this copy is to pass null as "data" when calling vaCreateBuffer(),
- * and then use vaMapBuffer() to map the data store from the server side to the
- * client address space for access.
- *  Note: image buffers are created by the library, not the client. Please see 
- *        vaCreateImage on how image buffers are managed.
- */
-VAStatus vaCreateBuffer (
-    VADisplay dpy,
-    VAContextID context,
-    VABufferType type,	/* in */
-    unsigned int size,	/* in */
-    unsigned int num_elements, /* in */
-    void *data,		/* in */
-    VABufferID *buf_id	/* out */
-);
-
-/**
- * Convey to the server how many valid elements are in the buffer. 
- * e.g. if multiple slice parameters are being held in a single buffer,
- * this will communicate to the server the number of slice parameters
- * that are valid in the buffer.
- */
-VAStatus vaBufferSetNumElements (
-    VADisplay dpy,
-    VABufferID buf_id,	/* in */
-    unsigned int num_elements /* in */
-);
-
-
-/**
- * device independent data structure for codedbuffer
- */
-
-/* 
- * FICTURE_AVE_QP(bit7-0): The average Qp value used during this frame
- * LARGE_SLICE(bit8):At least one slice in the current frame was large
- *              enough for the encoder to attempt to limit its size.
- * SLICE_OVERFLOW(bit9): At least one slice in the current frame has
- *              exceeded the maximum slice size specified.
- * BITRATE_OVERFLOW(bit10): The peak bitrate was exceeded for this frame.
- * BITRATE_HIGH(bit11): The frame size got within the safety margin of the maximum size (VCM only)
- * AIR_MB_OVER_THRESHOLD: the number of MBs adapted to Intra MB
- */
-#define VA_CODED_BUF_STATUS_PICTURE_AVE_QP_MASK         0xff
-#define VA_CODED_BUF_STATUS_LARGE_SLICE_MASK            0x100
-#define VA_CODED_BUF_STATUS_SLICE_OVERFLOW_MASK         0x200
-#define VA_CODED_BUF_STATUS_BITRATE_OVERFLOW		0x400
-#define VA_CODED_BUF_STATUS_BITRATE_HIGH		0x800
-/**
- * \brief The frame has exceeded the maximum requested size.
- *
- * This flag indicates that the encoded frame size exceeds the value
- * specified through a misc parameter buffer of type
- * #VAEncMiscParameterTypeMaxFrameSize.
- */
-#define VA_CODED_BUF_STATUS_FRAME_SIZE_OVERFLOW         0x1000
-#define VA_CODED_BUF_STATUS_AIR_MB_OVER_THRESHOLD	0xff0000
-
-/**
- * \brief The coded buffer segment contains a single NAL unit. 
- *
- * This flag indicates that the coded buffer segment contains a
- * single NAL unit. This flag might be useful to the user for 
- * processing the coded buffer.
- */
-#define VA_CODED_BUF_STATUS_SINGLE_NALU                 0x10000000	
-
-/**
- * \brief Coded buffer segment.
- *
- * #VACodedBufferSegment is an element of a linked list describing
- * some information on the coded buffer. The coded buffer segment
- * could contain either a single NAL unit, or more than one NAL unit. 
- * It is recommended (but not required) to return a single NAL unit 
- * in a coded buffer segment, and the implementation should set the 
- * VA_CODED_BUF_STATUS_SINGLE_NALU status flag if that is the case.
- */
-typedef  struct _VACodedBufferSegment  {
-    /**
-     * \brief Size of the data buffer in this segment (in bytes).
-     */
-    unsigned int        size;
-    /** \brief Bit offset into the data buffer where the video data starts. */
-    unsigned int        bit_offset;
-    /** \brief Status set by the driver. See \c VA_CODED_BUF_STATUS_*. */
-    unsigned int        status;
-    /** \brief Reserved for future use. */
-    unsigned int        reserved;
-    /** \brief Pointer to the start of the data buffer. */
-    void               *buf;
-    /**
-     * \brief Pointer to the next #VACodedBufferSegment element,
-     * or \c NULL if there is none.
-     */
-    void               *next;
-} VACodedBufferSegment;
-     
-/**
- * Map data store of the buffer into the client's address space
- * vaCreateBuffer() needs to be called with "data" set to NULL before
- * calling vaMapBuffer()
- *
- * if buffer type is VAEncCodedBufferType, pbuf points to link-list of
- * VACodedBufferSegment, and the list is terminated if "next" is NULL
- */
-VAStatus vaMapBuffer (
-    VADisplay dpy,
-    VABufferID buf_id,	/* in */
-    void **pbuf 	/* out */
-);
-
-/**
- * After client making changes to a mapped data store, it needs to
- * "Unmap" it to let the server know that the data is ready to be
- * consumed by the server
- */
-VAStatus vaUnmapBuffer (
-    VADisplay dpy,
-    VABufferID buf_id	/* in */
-);
-
-/**
- * After this call, the buffer is deleted and this buffer_id is no longer valid
- * Only call this if the buffer is not going to be passed to vaRenderBuffer
- */
-VAStatus vaDestroyBuffer (
-    VADisplay dpy,
-    VABufferID buffer_id
-);
-
-/** \brief VA buffer information */
-typedef struct {
-    /** \brief Buffer handle */
-    uintptr_t           handle;
-    /** \brief Buffer type (See \ref VABufferType). */
-    uint32_t            type;
-    /**
-     * \brief Buffer memory type (See \ref VASurfaceAttribMemoryType).
-     *
-     * On input to vaAcquireBufferHandle(), this field can serve as a hint
-     * to specify the set of memory types the caller is interested in.
-     * On successful return from vaAcquireBufferHandle(), the field is
-     * updated with the best matching memory type.
-     */
-    uint32_t            mem_type;
-    /** \brief Size of the underlying buffer. */
-    size_t              mem_size;
-} VABufferInfo;
-
-/**
- * \brief Acquires buffer handle for external API usage
- *
- * Locks the VA buffer object \ref buf_id for external API usage like
- * EGL or OpenCL (OCL). This function is a synchronization point. This
- * means that any pending operation is guaranteed to be completed
- * prior to returning from the function.
- *
- * If the referenced VA buffer object is the backing store of a VA
- * surface, then this function acts as if vaSyncSurface() on the
- * parent surface was called first.
- *
- * The \ref VABufferInfo argument shall be zero'ed on input. On
- * successful output, the data structure is filled in with all the
- * necessary buffer level implementation details like handle, type,
- * memory type and memory size.
- *
- * Note: the external API implementation, or the application, can
- * express the memory types it is interested in by filling in the \ref
- * mem_type field accordingly. On successful output, the memory type
- * that fits best the request and that was used is updated in the \ref
- * VABufferInfo data structure. If none of the supplied memory types
- * is supported, then a \ref VA_STATUS_ERROR_UNSUPPORTED_MEMORY_TYPE
- * error is returned.
- *
- * The \ref VABufferInfo data is valid until vaReleaseBufferHandle()
- * is called. Besides, no additional operation is allowed on any of
- * the buffer parent object until vaReleaseBufferHandle() is called.
- * e.g. decoding into a VA surface backed with the supplied VA buffer
- * object \ref buf_id would fail with a \ref VA_STATUS_ERROR_SURFACE_BUSY
- * error.
- *
- * Possible errors:
- * - \ref VA_STATUS_ERROR_UNIMPLEMENTED: the VA driver implementation
- *   does not support this interface
- * - \ref VA_STATUS_ERROR_INVALID_DISPLAY: an invalid display was supplied
- * - \ref VA_STATUS_ERROR_INVALID_BUFFER: an invalid buffer was supplied
- * - \ref VA_STATUS_ERROR_UNSUPPORTED_BUFFERTYPE: the implementation
- *   does not support exporting buffers of the specified type
- * - \ref VA_STATUS_ERROR_UNSUPPORTED_MEMORY_TYPE: none of the requested
- *   memory types in \ref VABufferInfo.mem_type was supported
- *
- * @param[in] dpy               the VA display
- * @param[in] buf_id            the VA buffer
- * @param[in,out] buf_info      the associated VA buffer information
- * @return VA_STATUS_SUCCESS if successful
- */
-VAStatus
-vaAcquireBufferHandle(VADisplay dpy, VABufferID buf_id, VABufferInfo *buf_info);
-
-/**
- * \brief Releases buffer after usage from external API
- *
- * Unlocks the VA buffer object \ref buf_id from external API usage like
- * EGL or OpenCL (OCL). This function is a synchronization point. This
- * means that any pending operation is guaranteed to be completed
- * prior to returning from the function.
- *
- * The \ref VABufferInfo argument shall point to the original data
- * structure that was obtained from vaAcquireBufferHandle(), unaltered.
- * This is necessary so that the VA driver implementation could
- * deallocate any resources that were needed.
- *
- * In any case, returning from this function invalidates any contents
- * in \ref VABufferInfo. i.e. the underlyng buffer handle is no longer
- * valid. Therefore, VA driver implementations are free to reset this
- * data structure to safe defaults.
- *
- * Possible errors:
- * - \ref VA_STATUS_ERROR_UNIMPLEMENTED: the VA driver implementation
- *   does not support this interface
- * - \ref VA_STATUS_ERROR_INVALID_DISPLAY: an invalid display was supplied
- * - \ref VA_STATUS_ERROR_INVALID_BUFFER: an invalid buffer was supplied
- * - \ref VA_STATUS_ERROR_UNSUPPORTED_BUFFERTYPE: the implementation
- *   does not support exporting buffers of the specified type
- *
- * @param[in] dpy               the VA display
- * @param[in] buf_id            the VA buffer
- * @return VA_STATUS_SUCCESS if successful
- */
-VAStatus
-vaReleaseBufferHandle(VADisplay dpy, VABufferID buf_id);
-
-/*
-Render (Decode) Pictures
-
-A picture represents either a frame or a field.
-
-The Begin/Render/End sequence sends the decode buffers to the server
-*/
-
-/**
- * Get ready to decode a picture to a target surface
- */
-VAStatus vaBeginPicture (
-    VADisplay dpy,
-    VAContextID context,
-    VASurfaceID render_target
-);
-
-/**
- * Send decode buffers to the server.
- * Buffers are automatically destroyed afterwards
- */
-VAStatus vaRenderPicture (
-    VADisplay dpy,
-    VAContextID context,
-    VABufferID *buffers,
-    int num_buffers
-);
-
-/**
- * Make the end of rendering for a picture. 
- * The server should start processing all pending operations for this 
- * surface. This call is non-blocking. The client can start another 
- * Begin/Render/End sequence on a different render target.
- */
-VAStatus vaEndPicture (
-    VADisplay dpy,
-    VAContextID context
-);
-
-/*
-
-Synchronization 
-
-*/
-
-/**
- * This function blocks until all pending operations on the render target
- * have been completed.  Upon return it is safe to use the render target for a 
- * different picture. 
- */
-VAStatus vaSyncSurface (
-    VADisplay dpy,
-    VASurfaceID render_target
-);
-
-typedef enum
-{
-    VASurfaceRendering	= 1, /* Rendering in progress */ 
-    VASurfaceDisplaying	= 2, /* Displaying in progress (not safe to render into it) */ 
-                             /* this status is useful if surface is used as the source */
-                             /* of an overlay */
-    VASurfaceReady	= 4, /* not being rendered or displayed */
-    VASurfaceSkipped	= 8  /* Indicate a skipped frame during encode */
-} VASurfaceStatus;
-
-/**
- * Find out any pending ops on the render target 
- */
-VAStatus vaQuerySurfaceStatus (
-    VADisplay dpy,
-    VASurfaceID render_target,
-    VASurfaceStatus *status	/* out */
-);
-
-typedef enum
-{
-    VADecodeSliceMissing            = 0,
-    VADecodeMBError                 = 1,
-} VADecodeErrorType;
-
-/**
- * Client calls vaQuerySurfaceError with VA_STATUS_ERROR_DECODING_ERROR, server side returns
- * an array of structure VASurfaceDecodeMBErrors, and the array is terminated by setting status=-1
-*/
-typedef struct _VASurfaceDecodeMBErrors
-{
-    int status; /* 1 if hardware has returned detailed info below, -1 means this record is invalid */
-    unsigned int start_mb; /* start mb address with errors */
-    unsigned int end_mb;  /* end mb address with errors */
-    VADecodeErrorType decode_error_type;
-} VASurfaceDecodeMBErrors;
-
-/**
- * After the application gets VA_STATUS_ERROR_DECODING_ERROR after calling vaSyncSurface(),
- * it can call vaQuerySurfaceError to find out further details on the particular error.
- * VA_STATUS_ERROR_DECODING_ERROR should be passed in as "error_status",
- * upon the return, error_info will point to an array of _VASurfaceDecodeMBErrors structure,
- * which is allocated and filled by libVA with detailed information on the missing or error macroblocks.
- * The array is terminated if "status==-1" is detected.
- */
-VAStatus vaQuerySurfaceError(
-    VADisplay dpy,
-    VASurfaceID surface,
-    VAStatus error_status,
-    void **error_info
-);
-
-/**
- * Images and Subpictures
- * VAImage is used to either get the surface data to client memory, or 
- * to copy image data in client memory to a surface. 
- * Both images, subpictures and surfaces follow the same 2D coordinate system where origin 
- * is at the upper left corner with positive X to the right and positive Y down
- */
-#define VA_FOURCC(ch0, ch1, ch2, ch3) \
-    ((unsigned long)(unsigned char) (ch0) | ((unsigned long)(unsigned char) (ch1) << 8) | \
-    ((unsigned long)(unsigned char) (ch2) << 16) | ((unsigned long)(unsigned char) (ch3) << 24 ))
-
-/* 
- * Pre-defined fourcc codes
- */
-#define VA_FOURCC_NV12		0x3231564E
-#define VA_FOURCC_AI44		0x34344149
-#define VA_FOURCC_RGBA		0x41424752
-#define VA_FOURCC_RGBX		0x58424752
-#define VA_FOURCC_BGRA		0x41524742
-#define VA_FOURCC_BGRX		0x58524742
-#define VA_FOURCC_ARGB		0x42475241
-#define VA_FOURCC_XRGB		0x42475258
-#define VA_FOURCC_ABGR          0x52474241
-#define VA_FOURCC_XBGR          0x52474258
-#define VA_FOURCC_UYVY          0x59565955
-#define VA_FOURCC_YUY2          0x32595559
-#define VA_FOURCC_AYUV          0x56555941
-#define VA_FOURCC_NV11          0x3131564e
-#define VA_FOURCC_YV12          0x32315659
-#define VA_FOURCC_P208          0x38303250
-#define VA_FOURCC_IYUV          0x56555949
-#define VA_FOURCC_YV24          0x34325659
-#define VA_FOURCC_YV32          0x32335659
-#define VA_FOURCC_Y800          0x30303859
-#define VA_FOURCC_IMC3          0x33434D49
-#define VA_FOURCC_411P          0x50313134
-#define VA_FOURCC_422H          0x48323234
-#define VA_FOURCC_422V          0x56323234
-#define VA_FOURCC_444P          0x50343434
-#define VA_FOURCC_RGBP          0x50424752
-#define VA_FOURCC_BGRP          0x50524742
-#define VA_FOURCC_411R          0x52313134 /* rotated 411P */
-/**
- * Planar YUV 4:2:2.
- * 8-bit Y plane, followed by 8-bit 2x1 subsampled V and U planes
- */
-#define VA_FOURCC_YV16 0x36315659
-/**
- * 10-bit and 16-bit Planar YUV 4:2:0.
- */
-#define VA_FOURCC_P010 0x30313050
-#define VA_FOURCC_P016 0x36313050
-
-/* byte order */
-#define VA_LSB_FIRST		1
-#define VA_MSB_FIRST		2
-
-typedef struct _VAImageFormat
-{
-    unsigned int	fourcc;
-    unsigned int	byte_order; /* VA_LSB_FIRST, VA_MSB_FIRST */
-    unsigned int	bits_per_pixel;
-    /* for RGB formats */
-    unsigned int	depth; /* significant bits per pixel */
-    unsigned int	red_mask;
-    unsigned int	green_mask;
-    unsigned int	blue_mask;
-    unsigned int	alpha_mask;
-} VAImageFormat;
-
-typedef VAGenericID VAImageID;
-
-typedef struct _VAImage
-{
-    VAImageID		image_id; /* uniquely identify this image */
-    VAImageFormat	format;
-    VABufferID		buf;	/* image data buffer */
-    /*
-     * Image data will be stored in a buffer of type VAImageBufferType to facilitate
-     * data store on the server side for optimal performance. The buffer will be 
-     * created by the CreateImage function, and proper storage allocated based on the image
-     * size and format. This buffer is managed by the library implementation, and 
-     * accessed by the client through the buffer Map/Unmap functions.
-     */
-    unsigned short	width; 
-    unsigned short	height;
-    unsigned int	data_size;
-    unsigned int	num_planes;	/* can not be greater than 3 */
-    /* 
-     * An array indicating the scanline pitch in bytes for each plane.
-     * Each plane may have a different pitch. Maximum 3 planes for planar formats
-     */
-    unsigned int	pitches[3];
-    /* 
-     * An array indicating the byte offset from the beginning of the image data 
-     * to the start of each plane.
-     */
-    unsigned int	offsets[3];
-
-    /* The following fields are only needed for paletted formats */
-    int num_palette_entries;   /* set to zero for non-palette images */
-    /* 
-     * Each component is one byte and entry_bytes indicates the number of components in 
-     * each entry (eg. 3 for YUV palette entries). set to zero for non-palette images   
-     */
-    int entry_bytes; 
-    /*
-     * An array of ascii characters describing the order of the components within the bytes.
-     * Only entry_bytes characters of the string are used.
-     */
-    char component_order[4];
-} VAImage;
-
-/** Get maximum number of image formats supported by the implementation */
-int vaMaxNumImageFormats (
-    VADisplay dpy
-);
-
-/**
- * Query supported image formats 
- * The caller must provide a "format_list" array that can hold at
- * least vaMaxNumImageFormats() entries. The actual number of formats
- * returned in "format_list" is returned in "num_formats".
- */
-VAStatus vaQueryImageFormats (
-    VADisplay dpy,
-    VAImageFormat *format_list,	/* out */
-    int *num_formats		/* out */
-);
-
-/**
- * Create a VAImage structure
- * The width and height fields returned in the VAImage structure may get 
- * enlarged for some YUV formats. Upon return from this function, 
- * image->buf has been created and proper storage allocated by the library. 
- * The client can access the image through the Map/Unmap calls.
- */
-VAStatus vaCreateImage (
-    VADisplay dpy,
-    VAImageFormat *format,
-    int width,
-    int height,
-    VAImage *image	/* out */
-);
-
-/**
- * Should call DestroyImage before destroying the surface it is bound to
- */
-VAStatus vaDestroyImage (
-    VADisplay dpy,
-    VAImageID image
-);
-
-VAStatus vaSetImagePalette (
-    VADisplay dpy,
-    VAImageID image,
-    /* 
-     * pointer to an array holding the palette data.  The size of the array is 
-     * num_palette_entries * entry_bytes in size.  The order of the components 
-     * in the palette is described by the component_order in VAImage struct    
-     */
-    unsigned char *palette 
-);
-
-/**
- * Retrive surface data into a VAImage
- * Image must be in a format supported by the implementation
- */
-VAStatus vaGetImage (
-    VADisplay dpy,
-    VASurfaceID surface,
-    int x,	/* coordinates of the upper left source pixel */
-    int y,
-    unsigned int width, /* width and height of the region */
-    unsigned int height,
-    VAImageID image
-);
-
-/**
- * Copy data from a VAImage to a surface
- * Image must be in a format supported by the implementation
- * Returns a VA_STATUS_ERROR_SURFACE_BUSY if the surface
- * shouldn't be rendered into when this is called
- */
-VAStatus vaPutImage (
-    VADisplay dpy,
-    VASurfaceID surface,
-    VAImageID image,
-    int src_x,
-    int src_y,
-    unsigned int src_width,
-    unsigned int src_height,
-    int dest_x,
-    int dest_y,
-    unsigned int dest_width,
-    unsigned int dest_height
-);
-
-/**
- * Derive an VAImage from an existing surface.
- * This interface will derive a VAImage and corresponding image buffer from
- * an existing VA Surface. The image buffer can then be mapped/unmapped for
- * direct CPU access. This operation is only possible on implementations with
- * direct rendering capabilities and internal surface formats that can be
- * represented with a VAImage. When the operation is not possible this interface
- * will return VA_STATUS_ERROR_OPERATION_FAILED. Clients should then fall back
- * to using vaCreateImage + vaPutImage to accomplish the same task in an
- * indirect manner.
- *
- * Implementations should only return success when the resulting image buffer
- * would be useable with vaMap/Unmap.
- *
- * When directly accessing a surface special care must be taken to insure
- * proper synchronization with the graphics hardware. Clients should call
- * vaQuerySurfaceStatus to insure that a surface is not the target of concurrent
- * rendering or currently being displayed by an overlay.
- *
- * Additionally nothing about the contents of a surface should be assumed
- * following a vaPutSurface. Implementations are free to modify the surface for
- * scaling or subpicture blending within a call to vaPutImage.
- *
- * Calls to vaPutImage or vaGetImage using the same surface from which the image
- * has been derived will return VA_STATUS_ERROR_SURFACE_BUSY. vaPutImage or
- * vaGetImage with other surfaces is supported.
- *
- * An image created with vaDeriveImage should be freed with vaDestroyImage. The
- * image and image buffer structures will be destroyed; however, the underlying
- * surface will remain unchanged until freed with vaDestroySurfaces.
- */
-VAStatus vaDeriveImage (
-    VADisplay dpy,
-    VASurfaceID surface,
-    VAImage *image	/* out */
-);
-
-/**
- * Subpictures 
- * Subpicture is a special type of image that can be blended 
- * with a surface during vaPutSurface(). Subpicture can be used to render
- * DVD sub-titles or closed captioning text etc.  
- */
-
-typedef VAGenericID VASubpictureID;
-
-/** Get maximum number of subpicture formats supported by the implementation */
-int vaMaxNumSubpictureFormats (
-    VADisplay dpy
-);
-
-/** flags for subpictures */
-#define VA_SUBPICTURE_CHROMA_KEYING			0x0001
-#define VA_SUBPICTURE_GLOBAL_ALPHA			0x0002
-#define VA_SUBPICTURE_DESTINATION_IS_SCREEN_COORD	0x0004
-/**
- * Query supported subpicture formats 
- * The caller must provide a "format_list" array that can hold at
- * least vaMaxNumSubpictureFormats() entries. The flags arrary holds the flag 
- * for each format to indicate additional capabilities for that format. The actual 
- * number of formats returned in "format_list" is returned in "num_formats".
- *  flags: returned value to indicate addtional capabilities
- *         VA_SUBPICTURE_CHROMA_KEYING - supports chroma-keying
- *         VA_SUBPICTURE_GLOBAL_ALPHA - supports global alpha
- * 	   VA_SUBPICTURE_DESTINATION_IS_SCREEN_COORD - supports unscaled screen relative subpictures for On Screen Display
- */
-
-VAStatus vaQuerySubpictureFormats (
-    VADisplay dpy,
-    VAImageFormat *format_list,	/* out */
-    unsigned int *flags,	/* out */
-    unsigned int *num_formats	/* out */
-);
-
-/**
- * Subpictures are created with an image associated. 
- */
-VAStatus vaCreateSubpicture (
-    VADisplay dpy,
-    VAImageID image,
-    VASubpictureID *subpicture	/* out */
-);
-
-/**
- * Destroy the subpicture before destroying the image it is assocated to
- */
-VAStatus vaDestroySubpicture (
-    VADisplay dpy,
-    VASubpictureID subpicture
-);
-
-/**
- * Bind an image to the subpicture. This image will now be associated with 
- * the subpicture instead of the one at creation.
- */
-VAStatus vaSetSubpictureImage (
-    VADisplay dpy,
-    VASubpictureID subpicture,
-    VAImageID image
-);
-
-/**
- * If chromakey is enabled, then the area where the source value falls within
- * the chromakey [min, max] range is transparent
- * The chromakey component format is the following:
- *  For RGB: [0:7] Red [8:15] Blue [16:23] Green   
- *  For YUV: [0:7] V [8:15] U [16:23] Y
- * The chromakey mask can be used to mask out certain components for chromakey
- * comparision
- */
-VAStatus vaSetSubpictureChromakey (
-    VADisplay dpy,
-    VASubpictureID subpicture,
-    unsigned int chromakey_min,
-    unsigned int chromakey_max,
-    unsigned int chromakey_mask
-);
-
-/**
- * Global alpha value is between 0 and 1. A value of 1 means fully opaque and 
- * a value of 0 means fully transparent. If per-pixel alpha is also specified then
- * the overall alpha is per-pixel alpha multiplied by the global alpha
- */
-VAStatus vaSetSubpictureGlobalAlpha (
-    VADisplay dpy,
-    VASubpictureID subpicture,
-    float global_alpha 
-);
-
-/**
- * vaAssociateSubpicture associates the subpicture with target_surfaces.
- * It defines the region mapping between the subpicture and the target  
- * surfaces through source and destination rectangles (with the same width and height).
- * Both will be displayed at the next call to vaPutSurface.  Additional
- * associations before the call to vaPutSurface simply overrides the association.
- */
-VAStatus vaAssociateSubpicture (
-    VADisplay dpy,
-    VASubpictureID subpicture,
-    VASurfaceID *target_surfaces,
-    int num_surfaces,
-    short src_x, /* upper left offset in subpicture */
-    short src_y,
-    unsigned short src_width,
-    unsigned short src_height,
-    short dest_x, /* upper left offset in surface */
-    short dest_y,
-    unsigned short dest_width,
-    unsigned short dest_height,
-    /*
-     * whether to enable chroma-keying, global-alpha, or screen relative mode
-     * see VA_SUBPICTURE_XXX values
-     */
-    unsigned int flags
-);
-
-/**
- * vaDeassociateSubpicture removes the association of the subpicture with target_surfaces.
- */
-VAStatus vaDeassociateSubpicture (
-    VADisplay dpy,
-    VASubpictureID subpicture,
-    VASurfaceID *target_surfaces,
-    int num_surfaces
-);
-
-/**
- * Display attributes
- * Display attributes are used to control things such as contrast, hue, saturation,
- * brightness etc. in the rendering process.  The application can query what
- * attributes are supported by the driver, and then set the appropriate attributes
- * before calling vaPutSurface()
- */
-/* PowerVR IEP Lite attributes */
-typedef enum
-{
-    VADISPLAYATTRIB_BLE_OFF              = 0x00,
-    VADISPLAYATTRIB_BLE_LOW,
-    VADISPLAYATTRIB_BLE_MEDIUM,
-    VADISPLAYATTRIB_BLE_HIGH,
-    VADISPLAYATTRIB_BLE_NONE,
-} VADisplayAttribBLEMode;
-
-/** attribute value for VADisplayAttribRotation   */
-#define VA_ROTATION_NONE        0x00000000
-#define VA_ROTATION_90          0x00000001
-#define VA_ROTATION_180         0x00000002
-#define VA_ROTATION_270         0x00000003
-
-/** attribute value for VADisplayAttribOutOfLoopDeblock */
-#define VA_OOL_DEBLOCKING_FALSE 0x00000000
-#define VA_OOL_DEBLOCKING_TRUE  0x00000001
-
-/** Render mode */
-#define VA_RENDER_MODE_UNDEFINED           0
-#define VA_RENDER_MODE_LOCAL_OVERLAY       1
-#define VA_RENDER_MODE_LOCAL_GPU           2
-#define VA_RENDER_MODE_EXTERNAL_OVERLAY    4
-#define VA_RENDER_MODE_EXTERNAL_GPU        8
-
-/** Render device */
-#define VA_RENDER_DEVICE_UNDEFINED  0
-#define VA_RENDER_DEVICE_LOCAL      1
-#define VA_RENDER_DEVICE_EXTERNAL   2
-
-/** Currently defined display attribute types */
-typedef enum
-{
-    VADisplayAttribBrightness		= 0,
-    VADisplayAttribContrast		= 1,
-    VADisplayAttribHue			= 2,
-    VADisplayAttribSaturation		= 3,
-    /* client can specifiy a background color for the target window
-     * the new feature of video conference,
-     * the uncovered area of the surface is filled by this color
-     * also it will blend with the decoded video color
-     */
-    VADisplayAttribBackgroundColor      = 4,
-    /*
-     * this is a gettable only attribute. For some implementations that use the
-     * hardware overlay, after PutSurface is called, the surface can not be    
-     * re-used until after the subsequent PutSurface call. If this is the case 
-     * then the value for this attribute will be set to 1 so that the client   
-     * will not attempt to re-use the surface right after returning from a call
-     * to PutSurface.
-     *
-     * Don't use it, use flag VASurfaceDisplaying of vaQuerySurfaceStatus since
-     * driver may use overlay or GPU alternatively
-     */
-    VADisplayAttribDirectSurface       = 5,
-    VADisplayAttribRotation            = 6,	
-    VADisplayAttribOutofLoopDeblock    = 7,
-
-    /* PowerVR IEP Lite specific attributes */
-    VADisplayAttribBLEBlackMode        = 8,
-    VADisplayAttribBLEWhiteMode        = 9,
-    VADisplayAttribBlueStretch         = 10,
-    VADisplayAttribSkinColorCorrection = 11,
-    /*
-     * For type VADisplayAttribCSCMatrix, "value" field is a pointer to the color
-     * conversion matrix. Each element in the matrix is float-point
-     */
-    VADisplayAttribCSCMatrix           = 12,
-    /* specify the constant color used to blend with video surface
-     * Cd = Cv*Cc*Ac + Cb *(1 - Ac) C means the constant RGB
-     *      d: the final color to overwrite into the frame buffer 
-     *      v: decoded video after color conversion, 
-     *      c: video color specified by VADisplayAttribBlendColor
-     *      b: background color of the drawable
-     */
-    VADisplayAttribBlendColor          = 13,
-    /*
-     * Indicate driver to skip painting color key or not.
-     * only applicable if the render is overlay
-     */
-    VADisplayAttribOverlayAutoPaintColorKey   = 14,
-    /*
-     * customized overlay color key, the format is RGB888
-     * [23:16] = Red, [15:08] = Green, [07:00] = Blue.
-     */
-    VADisplayAttribOverlayColorKey	= 15,
-    /*
-     * The hint for the implementation of vaPutSurface
-     * normally, the driver could use an overlay or GPU to render the surface on the screen
-     * this flag provides APP the flexibity to switch the render dynamically
-     */
-    VADisplayAttribRenderMode           = 16,
-    /*
-     * specify if vaPutSurface needs to render into specified monitors
-     * one example is that one external monitor (e.g. HDMI) is enabled, 
-     * but the window manager is not aware of it, and there is no associated drawable
-     */
-    VADisplayAttribRenderDevice        = 17,
-    /*
-     * specify vaPutSurface render area if there is no drawable on the monitor
-     */
-    VADisplayAttribRenderRect          = 18,
-} VADisplayAttribType;
-
-/* flags for VADisplayAttribute */
-#define VA_DISPLAY_ATTRIB_NOT_SUPPORTED	0x0000
-#define VA_DISPLAY_ATTRIB_GETTABLE	0x0001
-#define VA_DISPLAY_ATTRIB_SETTABLE	0x0002
-
-typedef struct _VADisplayAttribute
-{
-    VADisplayAttribType type;
-    int min_value;
-    int max_value;
-    int value;	/* used by the set/get attribute functions */
-/* flags can be VA_DISPLAY_ATTRIB_GETTABLE or VA_DISPLAY_ATTRIB_SETTABLE or OR'd together */
-    unsigned int flags;
-} VADisplayAttribute;
-
-/** Get maximum number of display attributs supported by the implementation */
-int vaMaxNumDisplayAttributes (
-    VADisplay dpy
-);
-
-/**
- * Query display attributes 
- * The caller must provide a "attr_list" array that can hold at
- * least vaMaxNumDisplayAttributes() entries. The actual number of attributes
- * returned in "attr_list" is returned in "num_attributes".
- */
-VAStatus vaQueryDisplayAttributes (
-    VADisplay dpy,
-    VADisplayAttribute *attr_list,	/* out */
-    int *num_attributes			/* out */
-);
-
-/**
- * Get display attributes 
- * This function returns the current attribute values in "attr_list".
- * Only attributes returned with VA_DISPLAY_ATTRIB_GETTABLE set in the "flags" field
- * from vaQueryDisplayAttributes() can have their values retrieved.  
- */
-VAStatus vaGetDisplayAttributes (
-    VADisplay dpy,
-    VADisplayAttribute *attr_list,	/* in/out */
-    int num_attributes
-);
-
-/**
- * Set display attributes 
- * Only attributes returned with VA_DISPLAY_ATTRIB_SETTABLE set in the "flags" field
- * from vaQueryDisplayAttributes() can be set.  If the attribute is not settable or 
- * the value is out of range, the function returns VA_STATUS_ERROR_ATTR_NOT_SUPPORTED
- */
-VAStatus vaSetDisplayAttributes (
-    VADisplay dpy,
-    VADisplayAttribute *attr_list,
-    int num_attributes
-);
-
-/****************************
- * HEVC data structures
- ****************************/
-/** 
- * \brief Description of picture properties of those in DPB surfaces.
- *
- * If only progressive scan is supported, each surface contains one whole 
- * frame picture.
- * Otherwise, each surface contains two fields of whole picture.
- * In this case, two entries of ReferenceFrames[] may share same picture_id
- * value.
- */
-typedef struct _VAPictureHEVC
-{
-    /** \brief reconstructed picture buffer surface index 
-     * invalid when taking value VA_INVALID_SURFACE.
-     */
-    VASurfaceID             picture_id;
-    /** \brief picture order count. 
-     * in HEVC, POCs for top and bottom fields of same picture should
-     * take different values.
-     */
-    int32_t                 pic_order_cnt;
-    /* described below */
-    uint32_t                flags;
-} VAPictureHEVC;
-
-/* flags in VAPictureHEVC could be OR of the following */
-#define VA_PICTURE_HEVC_INVALID                 0x00000001
-/** \brief indication of interlace scan picture. 
- * should take same value for all the pictures in sequence.
- */ 
-#define VA_PICTURE_HEVC_FIELD_PIC               0x00000002
-/** \brief polarity of the field picture.
- * top field takes even lines of buffer surface.
- * bottom field takes odd lines of buffer surface.
- */
-#define VA_PICTURE_HEVC_BOTTOM_FIELD            0x00000004
-/** \brief Long term reference picture */
-#define VA_PICTURE_HEVC_LONG_TERM_REFERENCE     0x00000008
-/**
- * VA_PICTURE_HEVC_RPS_ST_CURR_BEFORE, VA_PICTURE_HEVC_RPS_ST_CURR_AFTER
- * and VA_PICTURE_HEVC_RPS_LT_CURR of any picture in ReferenceFrames[] should 
- * be exclusive. No more than one of them can be set for any picture.
- * Sum of NumPocStCurrBefore, NumPocStCurrAfter and NumPocLtCurr
- * equals NumPocTotalCurr, which should be equal to or smaller than 8.
- * Application should provide valid values for both short format and long format.
- * The pictures in DPB with any of these three flags turned on are referred by
- * the current picture.
- */
-/** \brief RefPicSetStCurrBefore of HEVC spec variable 
- * Number of ReferenceFrames[] entries with this bit set equals 
- * NumPocStCurrBefore.
- */
-#define VA_PICTURE_HEVC_RPS_ST_CURR_BEFORE      0x00000010
-/** \brief RefPicSetStCurrAfter of HEVC spec variable
- * Number of ReferenceFrames[] entries with this bit set equals 
- * NumPocStCurrAfter.
- */
-#define VA_PICTURE_HEVC_RPS_ST_CURR_AFTER       0x00000020
-/** \brief RefPicSetLtCurr of HEVC spec variable
- * Number of ReferenceFrames[] entries with this bit set equals 
- * NumPocLtCurr.
- */
-#define VA_PICTURE_HEVC_RPS_LT_CURR             0x00000040
-
-#include <va/va_dec_hevc.h>
-#include <va/va_dec_jpeg.h>
-#include <va/va_dec_vp8.h>
-#include <va/va_dec_vp9.h>
-#include <va/va_enc_h264.h>
-#include <va/va_enc_hevc.h>
-#include <va/va_enc_jpeg.h>
-#include <va/va_enc_mpeg2.h>
-#include <va/va_enc_vp8.h>
-#include <va/va_enc_vp9.h>
-#include <va/va_vpp.h>
-
-/**@}*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _VA_H_ */
diff --git a/third_party/libva/va/va_android.h b/third_party/libva/va/va_android.h
deleted file mode 100644
index 796ab63..0000000
--- a/third_party/libva/va/va_android.h
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#ifndef _VA_ANDROID_H_
-#define _VA_ANDROID_H_
-
-#include <va/va.h>
-
-/** \brief Android Gralloc buffer memory type. */
-#define VA_SURFACE_ATTRIB_MEM_TYPE_ANDROID_GRALLOC	0x00100000
-/** \brief Android ION buffer memory type. */
-#define VA_SURFACE_ATTRIB_MEM_TYPE_ANDROID_ION		0x00200000
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
- * Returns a suitable VADisplay for VA API
- */
-VADisplay vaGetDisplay (
-    void *android_dpy
-);
-
-#ifdef __cplusplus
-}
-#endif
-
-#ifdef __cplusplus
-#ifdef ANDROID
-#include <surfaceflinger/ISurface.h>
-using namespace android;
-
-/*
- * Output rendering
- * Following is the rendering interface for Android system, 
- * to get the decode output surface to an ISurface object.
- * It basically performs a de-interlacing (if needed), 
- * color space conversion and scaling to the destination
- * rectangle
- */
-VAStatus vaPutSurface (
-    VADisplay dpy,
-    VASurfaceID surface,	
-    sp<ISurface> draw, /* Android Window/Surface */
-    short srcx,
-    short srcy,
-    unsigned short srcw,
-    unsigned short srch,
-    short destx,
-    short desty,
-    unsigned short destw,
-    unsigned short desth,
-    VARectangle *cliprects, /* client supplied destination clip list */
-    unsigned int number_cliprects, /* number of clip rects in the clip list */
-    unsigned int flags /* PutSurface flags */
-);
-
-#endif /* ANDROID */
-#endif /* __cplusplus */
-
-#endif /* _VA_ANDROID_H_ */
diff --git a/third_party/libva/va/va_backend.h b/third_party/libva/va/va_backend.h
deleted file mode 100644
index 7ab52d2..0000000
--- a/third_party/libva/va/va_backend.h
+++ /dev/null
@@ -1,562 +0,0 @@
-/*
- * Copyright (c) 2007 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/*
- * Video Decode Acceleration -Backend API
- */
-
-#ifndef _VA_BACKEND_H_
-#define _VA_BACKEND_H_
-
-#include <va/va.h>
-#include <linux/videodev2.h>
-
-typedef struct VADriverContext *VADriverContextP;
-typedef struct VADisplayContext *VADisplayContextP;
-
-/** \brief VA display types. */
-enum {
-    /** \brief Mask to major identifier for VA display type. */
-    VA_DISPLAY_MAJOR_MASK = 0xf0,
-
-    /** \brief VA/X11 API is used, through vaGetDisplay() entry-point. */
-    VA_DISPLAY_X11      = 0x10,
-    /** \brief VA/GLX API is used, through vaGetDisplayGLX() entry-point. */
-    VA_DISPLAY_GLX      = (VA_DISPLAY_X11 | (1 << 0)),
-    /** \brief VA/Android API is used, through vaGetDisplay() entry-point. */
-    VA_DISPLAY_ANDROID  = 0x20,
-    /** \brief VA/DRM API is used, through vaGetDisplayDRM() entry-point. */
-    VA_DISPLAY_DRM      = 0x30,
-    /** \brief VA/DRM API is used, with a render-node device path */
-    VA_DISPLAY_DRM_RENDERNODES = (VA_DISPLAY_DRM | (1 << 0)),
-    /** \brief VA/Wayland API is used, through vaGetDisplayWl() entry-point. */
-    VA_DISPLAY_WAYLAND  = 0x40,
-};
-
-struct VADriverVTable
-{
-	VAStatus (*vaTerminate) ( VADriverContextP ctx );
-
-	VAStatus (*vaQueryConfigProfiles) (
-		VADriverContextP ctx,
-		VAProfile *profile_list,	/* out */
-		int *num_profiles			/* out */
-	);
-
-	VAStatus (*vaQueryConfigEntrypoints) (
-		VADriverContextP ctx,
-		VAProfile profile,
-		VAEntrypoint  *entrypoint_list,	/* out */
-		int *num_entrypoints			/* out */
-	);
-
-	VAStatus (*vaGetConfigAttributes) (
-		VADriverContextP ctx,
-		VAProfile profile,
-		VAEntrypoint entrypoint,
-		VAConfigAttrib *attrib_list,	/* in/out */
-		int num_attribs
-	);
-
-	VAStatus (*vaCreateConfig) (
-		VADriverContextP ctx,
-		VAProfile profile, 
-		VAEntrypoint entrypoint, 
-		VAConfigAttrib *attrib_list,
-		int num_attribs,
-		VAConfigID *config_id		/* out */
-	);
-
-	VAStatus (*vaDestroyConfig) (
-		VADriverContextP ctx,
-		VAConfigID config_id
-	);
-
-	VAStatus (*vaQueryConfigAttributes) (
-		VADriverContextP ctx,
-		VAConfigID config_id, 
-		VAProfile *profile,		/* out */
-		VAEntrypoint *entrypoint, 	/* out */
-		VAConfigAttrib *attrib_list,	/* out */
-		int *num_attribs		/* out */
-	);
-
-	VAStatus (*vaCreateSurfaces) (
-		VADriverContextP ctx,
-		int width,
-		int height,
-		int format,
-		int num_surfaces,
-		VASurfaceID *surfaces		/* out */
-	);
-
-	VAStatus (*vaDestroySurfaces) (
-		VADriverContextP ctx,
-		VASurfaceID *surface_list,
-		int num_surfaces
-	);
-
-	VAStatus (*vaCreateContext) (
-		VADriverContextP ctx,
-		VAConfigID config_id,
-		int picture_width,
-		int picture_height,
-		int flag,
-		VASurfaceID *render_targets,
-		int num_render_targets,
-		VAContextID *context		/* out */
-	);
-
-	VAStatus (*vaDestroyContext) (
-		VADriverContextP ctx,
-		VAContextID context
-	);
-
-	VAStatus (*vaCreateBuffer) (
-		VADriverContextP ctx,
-		VAContextID context,		/* in */
-		VABufferType type,		/* in */
-		unsigned int size,		/* in */
-		unsigned int num_elements,	/* in */
-		void *data,			/* in */
-		VABufferID *buf_id		/* out */
-	);
-
-	VAStatus (*vaBufferSetNumElements) (
-		VADriverContextP ctx,
-		VABufferID buf_id,	/* in */
-		unsigned int num_elements	/* in */
-	);
-
-	VAStatus (*vaMapBuffer) (
-		VADriverContextP ctx,
-		VABufferID buf_id,	/* in */
-		void **pbuf         /* out */
-	);
-
-	VAStatus (*vaUnmapBuffer) (
-		VADriverContextP ctx,
-		VABufferID buf_id	/* in */
-	);
-
-	VAStatus (*vaDestroyBuffer) (
-		VADriverContextP ctx,
-		VABufferID buffer_id
-	);
-
-	VAStatus (*vaBeginPicture) (
-		VADriverContextP ctx,
-		VAContextID context,
-		VASurfaceID render_target
-	);
-
-	VAStatus (*vaRenderPicture) (
-		VADriverContextP ctx,
-		VAContextID context,
-		VABufferID *buffers,
-		int num_buffers
-	);
-
-	VAStatus (*vaEndPicture) (
-		VADriverContextP ctx,
-		VAContextID context
-	);
-
-	VAStatus (*vaSyncSurface) (
-		VADriverContextP ctx,
-		VASurfaceID render_target
-	);
-
-	VAStatus (*vaQuerySurfaceStatus) (
-		VADriverContextP ctx,
-		VASurfaceID render_target,
-		VASurfaceStatus *status	/* out */
-	);
-
-	VAStatus (*vaQuerySurfaceError) (
-		VADriverContextP ctx,
-		VASurfaceID render_target,
-                VAStatus error_status,
-                void **error_info /*out*/
-	);
-
-	VAStatus (*vaPutSurface) (
-    		VADriverContextP ctx,
-		VASurfaceID surface,
-		void* draw, /* Drawable of window system */
-		short srcx,
-		short srcy,
-		unsigned short srcw,
-		unsigned short srch,
-		short destx,
-		short desty,
-		unsigned short destw,
-		unsigned short desth,
-		VARectangle *cliprects, /* client supplied clip list */
-		unsigned int number_cliprects, /* number of clip rects in the clip list */
-		unsigned int flags /* de-interlacing flags */
-	);
-
-	VAStatus (*vaQueryImageFormats) (
-		VADriverContextP ctx,
-		VAImageFormat *format_list,        /* out */
-		int *num_formats           /* out */
-	);
-
-	VAStatus (*vaCreateImage) (
-		VADriverContextP ctx,
-		VAImageFormat *format,
-		int width,
-		int height,
-		VAImage *image     /* out */
-	);
-
-	VAStatus (*vaDeriveImage) (
-		VADriverContextP ctx,
-		VASurfaceID surface,
-		VAImage *image     /* out */
-	);
-
-	VAStatus (*vaDestroyImage) (
-		VADriverContextP ctx,
-		VAImageID image
-	);
-	
-	VAStatus (*vaSetImagePalette) (
-	        VADriverContextP ctx,
-	        VAImageID image,
-	        /*
-                 * pointer to an array holding the palette data.  The size of the array is
-                 * num_palette_entries * entry_bytes in size.  The order of the components
-                 * in the palette is described by the component_order in VAImage struct
-                 */
-                unsigned char *palette
-	);
-	
-	VAStatus (*vaGetImage) (
-		VADriverContextP ctx,
-		VASurfaceID surface,
-		int x,     /* coordinates of the upper left source pixel */
-		int y,
-		unsigned int width, /* width and height of the region */
-		unsigned int height,
-		VAImageID image
-	);
-
-	VAStatus (*vaPutImage) (
-		VADriverContextP ctx,
-		VASurfaceID surface,
-		VAImageID image,
-		int src_x,
-		int src_y,
-		unsigned int src_width,
-		unsigned int src_height,
-		int dest_x,
-		int dest_y,
-		unsigned int dest_width,
-		unsigned int dest_height
-	);
-
-	VAStatus (*vaQuerySubpictureFormats) (
-		VADriverContextP ctx,
-		VAImageFormat *format_list,        /* out */
-		unsigned int *flags,       /* out */
-		unsigned int *num_formats  /* out */
-	);
-
-	VAStatus (*vaCreateSubpicture) (
-		VADriverContextP ctx,
-		VAImageID image,
-		VASubpictureID *subpicture   /* out */
-	);
-
-	VAStatus (*vaDestroySubpicture) (
-		VADriverContextP ctx,
-		VASubpictureID subpicture
-	);
-
-        VAStatus (*vaSetSubpictureImage) (
-                VADriverContextP ctx,
-                VASubpictureID subpicture,
-                VAImageID image
-        );
-
-	VAStatus (*vaSetSubpictureChromakey) (
-		VADriverContextP ctx,
-		VASubpictureID subpicture,
-		unsigned int chromakey_min,
-		unsigned int chromakey_max,
-		unsigned int chromakey_mask
-	);
-
-	VAStatus (*vaSetSubpictureGlobalAlpha) (
-		VADriverContextP ctx,
-		VASubpictureID subpicture,
-		float global_alpha 
-	);
-
-	VAStatus (*vaAssociateSubpicture) (
-		VADriverContextP ctx,
-		VASubpictureID subpicture,
-		VASurfaceID *target_surfaces,
-		int num_surfaces,
-		short src_x, /* upper left offset in subpicture */
-		short src_y,
-		unsigned short src_width,
-		unsigned short src_height,
-		short dest_x, /* upper left offset in surface */
-		short dest_y,
-		unsigned short dest_width,
-		unsigned short dest_height,
-		/*
-		 * whether to enable chroma-keying or global-alpha
-		 * see VA_SUBPICTURE_XXX values
-		 */
-		unsigned int flags
-	);
-
-	VAStatus (*vaDeassociateSubpicture) (
-		VADriverContextP ctx,
-		VASubpictureID subpicture,
-		VASurfaceID *target_surfaces,
-		int num_surfaces
-	);
-
-	VAStatus (*vaQueryDisplayAttributes) (
-		VADriverContextP ctx,
-		VADisplayAttribute *attr_list,	/* out */
-		int *num_attributes		/* out */
-        );
-
-	VAStatus (*vaGetDisplayAttributes) (
-		VADriverContextP ctx,
-		VADisplayAttribute *attr_list,	/* in/out */
-		int num_attributes
-        );
-        
-        VAStatus (*vaSetDisplayAttributes) (
-		VADriverContextP ctx,
-                VADisplayAttribute *attr_list,
-                int num_attributes
-        );
-
-        /* used by va trace */        
-        VAStatus (*vaBufferInfo) (
-                   VADriverContextP ctx,      /* in */
-                   VABufferID buf_id,         /* in */
-                   VABufferType *type,        /* out */
-                   unsigned int *size,        /* out */
-                   unsigned int *num_elements /* out */
-        );
-
-        /* lock/unlock surface for external access */    
-        VAStatus (*vaLockSurface) (
-		VADriverContextP ctx,
-                VASurfaceID surface,
-                unsigned int *fourcc, /* out  for follow argument */
-                unsigned int *luma_stride,
-                unsigned int *chroma_u_stride,
-                unsigned int *chroma_v_stride,
-                unsigned int *luma_offset,
-                unsigned int *chroma_u_offset,
-                unsigned int *chroma_v_offset,
-                unsigned int *buffer_name, /* if it is not NULL, assign the low lever
-                                            * surface buffer name
-                                            */
-                void **buffer /* if it is not NULL, map the surface buffer for
-                                * CPU access
-                                */
-        );
-    
-        VAStatus (*vaUnlockSurface) (
-		VADriverContextP ctx,
-                VASurfaceID surface
-        );
-
-        /* DEPRECATED */
-        VAStatus
-        (*vaGetSurfaceAttributes)(
-            VADriverContextP    dpy,
-            VAConfigID          config,
-            VASurfaceAttrib    *attrib_list,
-            unsigned int        num_attribs
-        );
-
-        VAStatus
-        (*vaCreateSurfaces2)(
-            VADriverContextP    ctx,
-            unsigned int        format,
-            unsigned int        width,
-            unsigned int        height,
-            VASurfaceID        *surfaces,
-            unsigned int        num_surfaces,
-            VASurfaceAttrib    *attrib_list,
-            unsigned int        num_attribs
-        );
-
-        VAStatus
-        (*vaQuerySurfaceAttributes)(
-            VADriverContextP    dpy,
-            VAConfigID          config,
-            VASurfaceAttrib    *attrib_list,
-            unsigned int       *num_attribs
-        );
-
-        VAStatus
-        (*vaAcquireBufferHandle)(
-            VADriverContextP    ctx,
-            VABufferID          buf_id,         /* in */
-            VABufferInfo *      buf_info        /* in/out */
-        );
-
-        VAStatus
-        (*vaReleaseBufferHandle)(
-            VADriverContextP    ctx,
-            VABufferID          buf_id          /* in */
-        );
-};
-
-struct VADriverContext
-{
-    void *pDriverData;
-
-    /**
-     * The core VA implementation hooks.
-     *
-     * This structure is allocated from libva with calloc().
-     */
-    struct VADriverVTable *vtable;
-
-    /**
-     * The VA/GLX implementation hooks.
-     *
-     * This structure is intended for drivers that implement the
-     * VA/GLX API. The driver implementation is responsible for the
-     * allocation and deallocation of this structure.
-     */
-    struct VADriverVTableGLX *vtable_glx;
-
-    /**
-     * The VA/EGL implementation hooks.
-     *
-     * This structure is intended for drivers that implement the
-     * VA/EGL API. The driver implementation is responsible for the
-     * allocation and deallocation of this structure.
-     */
-    struct VADriverVTableEGL *vtable_egl;
-
-    /**
-     * The third-party/private implementation hooks.
-     *
-     * This structure is intended for drivers that implement the
-     * private API. The driver implementation is responsible for the
-     * allocation and deallocation of this structure.
-     */
-    void *vtable_tpi;
-
-    void *native_dpy;
-    int x11_screen;
-    int version_major;
-    int version_minor;
-    int max_profiles;
-    int max_entrypoints;
-    int max_attributes;
-    int max_image_formats;
-    int max_subpic_formats;
-    int max_display_attributes;
-    const char *str_vendor;
-
-    void *handle;			/* dlopen handle */
-
-    /**
-     * \brief DRM state.
-     *
-     * This field holds driver specific data for DRM-based
-     * drivers. This structure is allocated from libva with
-     * calloc(). Do not deallocate from within VA driver
-     * implementations.
-     *
-     * All structures shall be derived from struct drm_state. So, for
-     * instance, this field holds a dri_state structure for VA/X11
-     * drivers that use the DRM protocol.
-     */
-    void *drm_state;
-
-    void *glx;				/* opaque for GLX code */
-
-    /** \brief VA display type. */
-    unsigned long display_type;
-
-    /**
-     * The VA/Wayland implementation hooks.
-     *
-     * This structure is intended for drivers that implement the
-     * VA/Wayland API. libVA allocates this structure with calloc()
-     * and owns the resulting memory.
-     */
-    struct VADriverVTableWayland *vtable_wayland;
-
-    /**
-     * \brief The VA/VPP implementation hooks.
-     *
-     * This structure is allocated from libva with calloc().
-     */
-    struct VADriverVTableVPP *vtable_vpp;
-
-    char *override_driver_name;
-
-    unsigned long reserved[41];         /* reserve for future add-ins, decrease the subscript accordingly */
-};
-
-#define VA_DISPLAY_MAGIC 0x56414430 /* VAD0 */
-struct VADisplayContext
-{
-    int vadpy_magic;
-    
-    VADisplayContextP pNext;
-    VADriverContextP pDriverContext;
-
-    int (*vaIsValid) (
-	VADisplayContextP ctx
-    );
-
-    void (*vaDestroy) (
-	VADisplayContextP ctx
-    );
-
-    VAStatus (*vaGetDriverName) (
-	VADisplayContextP ctx,
-	char **driver_name
-    );
-
-    void *opaque; /* opaque for display extensions (e.g. GLX) */
-    void *vatrace; /* opaque for VA trace context */
-    void *vafool; /* opaque for VA fool context */
-};
-
-typedef VAStatus (*VADriverInit) (
-    VADriverContextP driver_context
-);
-
-#endif /* _VA_BACKEND_H_ */
diff --git a/third_party/libva/va/va_backend_tpi.h b/third_party/libva/va/va_backend_tpi.h
deleted file mode 100644
index 141eb75..0000000
--- a/third_party/libva/va/va_backend_tpi.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (c) 2007 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/*
- * Video Decode Acceleration -Backend API
- */
-
-#ifndef _VA_BACKEND_TPI_H_
-#define _VA_BACKEND_TPI_H_
-
-#include <va/va.h>
-#include <va/va_backend.h>
-#include <va/va_tpi.h>
-
-struct VADriverVTableTPI
-{
-    VAStatus (*vaCreateSurfacesWithAttribute) (
-        VADisplay dpy,
-        int width,
-        int height,
-        int format,
-        int num_surfaces,
-        VASurfaceID *surfaces,       /* out */
-        VASurfaceAttributeTPI *attribute_tpi
-        );
-    
-
-    VAStatus (*vaPutSurfaceBuf) (
-        VADriverContextP ctx,
-        VASurfaceID surface,
-        unsigned char* data,
-        int* data_len,
-        short srcx,
-        short srcy,
-        unsigned short srcw,
-        unsigned short srch,
-        short destx,
-        short desty,
-        unsigned short destw,
-        unsigned short desth,
-        VARectangle *cliprects, /* client supplied clip list */
-        unsigned int number_cliprects, /* number of clip rects in the clip list */
-        unsigned int flags /* de-interlacing flags */
-        );
-};
-
-
-#endif /* _VA_BACKEND_TPI_H_ */
diff --git a/third_party/libva/va/va_backend_vpp.h b/third_party/libva/va/va_backend_vpp.h
deleted file mode 100644
index b776ef6..0000000
--- a/third_party/libva/va/va_backend_vpp.h
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright (c) 2007-2011 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef VA_BACKEND_VPP_H
-#define VA_BACKEND_VPP_H
-
-#include <va/va_vpp.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** \brief VTable version for VA/VPP hooks. */
-#define VA_DRIVER_VTABLE_VPP_VERSION 1
-
-struct VADriverVTableVPP {
-    unsigned int            version;
-
-    VAStatus
-    (*vaQueryVideoProcFilters)(
-        VADriverContextP    ctx,
-        VAContextID         context,
-        VAProcFilterType   *filters,
-        unsigned int       *num_filters
-    );
-
-    VAStatus
-    (*vaQueryVideoProcFilterCaps)(
-        VADriverContextP    ctx,
-        VAContextID         context,
-        VAProcFilterType    type,
-        void               *filter_caps,
-        unsigned int       *num_filter_caps
-    );
-
-    VAStatus
-    (*vaQueryVideoProcPipelineCaps)(
-        VADriverContextP    ctx,
-        VAContextID         context,
-        VABufferID         *filters,
-        unsigned int        num_filters,
-        VAProcPipelineCaps *pipeline_caps
-    );
-};
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* VA_BACKEND_VPP_H */
diff --git a/third_party/libva/va/va_compat.h b/third_party/libva/va/va_compat.h
deleted file mode 100644
index 41a3f73..0000000
--- a/third_party/libva/va/va_compat.h
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Copyright (c) 2007-2011 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * \file va_compat.h
- * \brief The Compatibility API
- *
- * This file contains the \ref api_compat "Compatibility API".
- */
-
-#ifndef VA_COMPAT_H
-#define VA_COMPAT_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * \defgroup api_compat Compatibility API
- *
- * The Compatibility API allows older programs that are not ported to
- * the current API to still build and run correctly. In particular,
- * this exposes older API to allow for backwards source compatibility.
- *
- * @{
- */
-
-/**
- * Makes a string literal out of the macro argument
- */
-#define VA_CPP_HELPER_STRINGIFY(x) \
-    VA_CPP_HELPER_STRINGIFY_(x)
-#define VA_CPP_HELPER_STRINGIFY_(x) \
-    #x
-
-/**
- * Concatenates two macro arguments at preprocessing time.
- */
-#define VA_CPP_HELPER_CONCAT(a, b) \
-    VA_CPP_HELPER_CONCAT_(a, b)
-#define VA_CPP_HELPER_CONCAT_(a, b) \
-    a ## b
-
-/**
- * Generates the number of macro arguments at preprocessing time.
- * <http://groups.google.com/group/comp.std.c/browse_thread/thread/77ee8c8f92e4a3fb/346fc464319b1ee5>
- *
- * Note: this doesn't work for macros with no arguments
- */
-#define VA_CPP_HELPER_N_ARGS(...) \
-    VA_CPP_HELPER_N_ARGS_(__VA_ARGS__, VA_CPP_HELPER_N_ARGS_LIST_REV())
-#define VA_CPP_HELPER_N_ARGS_(...) \
-    VA_CPP_HELPER_N_ARGS_LIST(__VA_ARGS__)
-#define VA_CPP_HELPER_N_ARGS_LIST(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a12, a13, a14, a15, a16, N, ...) N
-#define VA_CPP_HELPER_N_ARGS_LIST_REV() \
-    15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0
-
-/**
- * Generates a versioned function alias.
- *
- * VA_CPP_HELPER_ALIAS(vaSomeFunction, 0,32,0) will generate
- *   .symber vaSomeFunction_0_32_0, vaSomeFunction@VA_API_0.32.0
- */
-#define VA_CPP_HELPER_ALIAS(func, major, minor, micro) \
-    VA_CPP_HELPER_ALIAS_(func, major, minor, micro, "@")
-#define VA_CPP_HELPER_ALIAS_DEFAULT(func, major, minor, micro) \
-    VA_CPP_HELPER_ALIAS_(func, major, minor, micro, "@@")
-#define VA_CPP_HELPER_ALIAS_(func, major, minor, micro, binding)        \
-    asm(".symver " #func "_" #major "_" #minor "_" #micro ", "          \
-        #func binding "VA_API_" #major "." #minor "." #micro)
-
-/* vaCreateSurfaces() */
-
-#ifndef VA_COMPAT_DISABLED
-#define vaCreateSurfaces(dpy, ...)                                      \
-    VA_CPP_HELPER_CONCAT(vaCreateSurfaces,                              \
-                         VA_CPP_HELPER_N_ARGS(dpy, __VA_ARGS__))        \
-    (dpy, __VA_ARGS__)
-#endif
-
-#define vaCreateSurfaces6(dpy, width, height, format, num_surfaces, surfaces) \
-    (vaCreateSurfaces)(dpy, format, width, height, surfaces, num_surfaces, \
-                       NULL, 0)
-
-#define vaCreateSurfaces8(dpy, format, width, height, surfaces, num_surfaces, attribs, num_attribs) \
-    (vaCreateSurfaces)(dpy, format, width, height, surfaces, num_surfaces, \
-                       attribs, num_attribs)
-
-/*@}*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* VA_COMPAT_H */
diff --git a/third_party/libva/va/va_dec_hevc.h b/third_party/libva/va/va_dec_hevc.h
deleted file mode 100644
index d61a283..0000000
--- a/third_party/libva/va/va_dec_hevc.h
+++ /dev/null
@@ -1,427 +0,0 @@
-/*
- * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * \file va_dec_hevc.h
- * \brief The HEVC decoding API
- *
- * This file contains the \ref api_dec_hevc "HEVC decoding API".
- */
-
-#ifndef VA_DEC_HEVC_H
-#define VA_DEC_HEVC_H
-
-#include <stdint.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * \defgroup api_dec_hevc HEVC decoding API
- *
- * This HEVC decoding API supports Main and Main Still Picture profiles.
- * And it supports both short slice format and long slice format.
- *
- * @{
- */
-
-/**
- * \brief HEVC Decoding Picture Parameter Buffer Structure
- *
- * This structure conveys picture level parameters and should be sent once
- * per frame.
- *
- */
-typedef struct  _VAPictureParameterBufferHEVC
-{
-    /** \brief buffer description of decoded current picture
-     * only VA_PICTURE_HEVC_FIELD_PIC and VA_PICTURE_HEVC_BOTTOM_FIELD
-     * of "flags" fields are meaningful.
-     */
-    VAPictureHEVC           CurrPic;
-    /** \brief buffer description of reference frames in DPB */
-    VAPictureHEVC           ReferenceFrames[15];
-    /** \brief picture width, shall be integer multiple of minimum CB size. */
-    uint16_t                pic_width_in_luma_samples;
-    /** \brief picture height, shall be integer multiple of minimum CB size. */
-    uint16_t                pic_height_in_luma_samples;
-
-
-    union
-    {
-        struct
-        {
-        /** following flags have same syntax and semantic as those in HEVC spec */
-            uint32_t        chroma_format_idc                           : 2;
-            uint32_t        separate_colour_plane_flag                  : 1;
-            uint32_t        pcm_enabled_flag                            : 1;
-            uint32_t        scaling_list_enabled_flag                   : 1;
-            uint32_t        transform_skip_enabled_flag                 : 1;
-            uint32_t        amp_enabled_flag                            : 1;
-            uint32_t        strong_intra_smoothing_enabled_flag         : 1;
-            uint32_t        sign_data_hiding_enabled_flag               : 1;
-            uint32_t        constrained_intra_pred_flag                 : 1;
-            uint32_t        cu_qp_delta_enabled_flag                    : 1;
-            uint32_t        weighted_pred_flag                          : 1;
-            uint32_t        weighted_bipred_flag                        : 1;
-            uint32_t        transquant_bypass_enabled_flag              : 1;
-            uint32_t        tiles_enabled_flag                          : 1;
-            uint32_t        entropy_coding_sync_enabled_flag            : 1;
-            uint32_t        pps_loop_filter_across_slices_enabled_flag  : 1;
-            uint32_t        loop_filter_across_tiles_enabled_flag       : 1;
-            uint32_t        pcm_loop_filter_disabled_flag               : 1;
-            /** set based on sps_max_num_reorder_pics of current temporal layer. */
-            uint32_t        NoPicReorderingFlag                         : 1;
-            /** picture has no B slices */
-            uint32_t        NoBiPredFlag                                : 1;
-
-            uint32_t        ReservedBits                                : 11;
-        } bits;
-        uint32_t            value;
-    } pic_fields;
-
-    /** following parameters have same syntax with those in HEVC spec */
-    /** \brief DPB size for current temporal layer */
-    uint8_t                 sps_max_dec_pic_buffering_minus1;
-    uint8_t                 bit_depth_luma_minus8;
-    uint8_t                 bit_depth_chroma_minus8;
-    uint8_t                 pcm_sample_bit_depth_luma_minus1;
-    uint8_t                 pcm_sample_bit_depth_chroma_minus1;
-    uint8_t                 log2_min_luma_coding_block_size_minus3;
-    uint8_t                 log2_diff_max_min_luma_coding_block_size;
-    uint8_t                 log2_min_transform_block_size_minus2;
-    uint8_t                 log2_diff_max_min_transform_block_size;
-    uint8_t                 log2_min_pcm_luma_coding_block_size_minus3;
-    uint8_t                 log2_diff_max_min_pcm_luma_coding_block_size;
-    uint8_t                 max_transform_hierarchy_depth_intra;
-    uint8_t                 max_transform_hierarchy_depth_inter;
-    int8_t                  init_qp_minus26;
-    uint8_t                 diff_cu_qp_delta_depth;
-    int8_t                  pps_cb_qp_offset;
-    int8_t                  pps_cr_qp_offset;
-    uint8_t                 log2_parallel_merge_level_minus2;
-    uint8_t                 num_tile_columns_minus1;
-    uint8_t                 num_tile_rows_minus1;
-    /**
-     * when uniform_spacing_flag equals 1, application should populate
-     * column_width_minus[], and row_height_minus1[] with approperiate values.
-     */
-    uint16_t                column_width_minus1[19];
-    uint16_t                row_height_minus1[21];
-
-    /**
-     *  The Following Parameters are needed for Short Slice Format Only.
-     *  Only format decoding can ignore them.
-     */
-
-    /**
-     * \brief Parameters needed for parsing slice segment headers
-     */
-    union
-    {
-        struct
-        {
-            /** following parameters have same syntax with those in HEVC spec */
-            uint32_t        lists_modification_present_flag             : 1;
-            uint32_t        long_term_ref_pics_present_flag             : 1;
-            uint32_t        sps_temporal_mvp_enabled_flag               : 1;
-            uint32_t        cabac_init_present_flag                     : 1;
-            uint32_t        output_flag_present_flag                    : 1;
-            uint32_t        dependent_slice_segments_enabled_flag       : 1;
-            uint32_t        pps_slice_chroma_qp_offsets_present_flag    : 1;
-            uint32_t        sample_adaptive_offset_enabled_flag         : 1;
-            uint32_t        deblocking_filter_override_enabled_flag     : 1;
-            uint32_t        pps_disable_deblocking_filter_flag          : 1;
-            uint32_t        slice_segment_header_extension_present_flag : 1;
-
-            /** current picture with NUT between 16 and 21 inclusive */
-            uint32_t        RapPicFlag                                  : 1;
-            /** current picture with NUT between 19 and 20 inclusive */
-            uint32_t        IdrPicFlag                                  : 1;
-            /** current picture has only intra slices */
-            uint32_t        IntraPicFlag                                : 1;
-
-            uint32_t        ReservedBits                                : 18;
-        } bits;
-        uint32_t            value;
-    } slice_parsing_fields;
-
-    /** following parameters have same syntax with those in HEVC spec */
-    uint8_t                 log2_max_pic_order_cnt_lsb_minus4;
-    uint8_t                 num_short_term_ref_pic_sets;
-    uint8_t                 num_long_term_ref_pic_sps;
-    uint8_t                 num_ref_idx_l0_default_active_minus1;
-    uint8_t                 num_ref_idx_l1_default_active_minus1;
-    int8_t                  pps_beta_offset_div2;
-    int8_t                  pps_tc_offset_div2;
-    uint8_t                 num_extra_slice_header_bits;
-
-    /**
-     * \brief number of bits that structure
-     * short_term_ref_pic_set( num_short_term_ref_pic_sets ) takes in slice
-     * segment header when short_term_ref_pic_set_sps_flag equals 0.
-     * if short_term_ref_pic_set_sps_flag equals 1, the value should be 0.
-     * the bit count is calculated after emulation prevention bytes are removed
-     * from bit streams.
-     * This variable is used for accelorater to skip parsing the
-     * short_term_ref_pic_set( num_short_term_ref_pic_sets ) structure.
-     */
-    uint32_t                st_rps_bits;
-
-} VAPictureParameterBufferHEVC;
-
-
-
-/**
- * \brief HEVC Slice Parameter Buffer Structure For Short Format
- *
- * VASliceParameterBufferBaseHEVC structure should be accompanied by a
- * slice data buffer, which holds the whole raw slice NAL unit bit streams
- * including start code prefix and emulation prevention bytes not removed.
- *
- * This structure conveys parameters related to slice segment header and should
- * be sent once per slice.
- *
- * For long format, this data structure is not sent by application.
- *
- */
-typedef struct  _VASliceParameterBufferBaseHEVC
-{
-    /** @name Codec-independent Slice Parameter Buffer base. */
-
-    /**@{*/
-
-    /** \brief Number of bytes in the slice data buffer for this slice
-     *  counting from and including NAL unit header.
-     */
-    uint32_t                slice_data_size;
-    /** \brief The offset to the NAL unit header for this slice */
-    uint32_t                slice_data_offset;
-    /** \brief Slice data buffer flags. See \c VA_SLICE_DATA_FLAG_XXX. */
-    uint16_t                slice_data_flag;
-    /**@}*/
-
-} VASliceParameterBufferBaseHEVC;
-
-
-
-
-/**
- * \brief HEVC Slice Parameter Buffer Structure For Long Format
- *
- * VASliceParameterBufferHEVC structure should be accompanied by a
- * slice data buffer, which holds the whole raw slice NAL unit bit streams
- * including start code prefix and emulation prevention bytes not removed.
- *
- * This structure conveys parameters related to slice segment header and should
- * be sent once per slice.
- *
- * For short format, this data structure is not sent by application.
- *
- */
-typedef struct  _VASliceParameterBufferHEVC
-{
-    /** @name Codec-independent Slice Parameter Buffer base. */
-
-    /**@{*/
-
-    /** \brief Number of bytes in the slice data buffer for this slice
-     * counting from and including NAL unit header.
-     */
-    uint32_t                slice_data_size;
-    /** \brief The offset to the NAL unit header for this slice */
-    uint32_t                slice_data_offset;
-    /** \brief Slice data buffer flags. See \c VA_SLICE_DATA_FLAG_XXX. */
-    uint16_t                slice_data_flag;
-    /**
-     * \brief Byte offset from NAL unit header to the begining of slice_data().
-     *
-     * This byte offset is relative to and includes the NAL unit header
-     * and represents the number of bytes parsed in the slice_header()
-     * after the removal of any emulation prevention bytes in
-     * there. However, the slice data buffer passed to the hardware is
-     * the original bitstream, thus including any emulation prevention
-     * bytes.
-     */
-    uint32_t                slice_data_byte_offset;
-    /** HEVC syntax element. */
-    uint32_t                slice_segment_address;
-    /** \brief index into ReferenceFrames[]
-     * RefPicList[0][] corresponds to RefPicList0[] of HEVC variable.
-     * RefPicList[1][] corresponds to RefPicList1[] of HEVC variable.
-     * value range [0..14, 0xFF], where 0xFF indicates invalid entry.
-     */
-    uint8_t                 RefPicList[2][15];
-    union
-    {
-        uint32_t            value;
-        struct
-        {
-            /** current slice is last slice of picture. */
-            uint32_t        LastSliceOfPic                              : 1;
-    /** HEVC syntax element. */
-            uint32_t        dependent_slice_segment_flag                : 1;
-    /** HEVC syntax element. */
-            uint32_t        slice_type                                  : 2;
-    /** HEVC syntax element. */
-            uint32_t        color_plane_id                              : 2;
-    /** HEVC syntax element. */
-            uint32_t        slice_sao_luma_flag                         : 1;
-    /** HEVC syntax element. */
-            uint32_t        slice_sao_chroma_flag                       : 1;
-    /** HEVC syntax element. */
-            uint32_t        mvd_l1_zero_flag                            : 1;
-    /** HEVC syntax element. */
-            uint32_t        cabac_init_flag                             : 1;
-    /** HEVC syntax element. */
-            uint32_t        slice_temporal_mvp_enabled_flag             : 1;
-    /** HEVC syntax element. */
-            uint32_t        slice_deblocking_filter_disabled_flag       : 1;
-    /** HEVC syntax element. */
-            uint32_t        collocated_from_l0_flag                     : 1;
-    /** HEVC syntax element. */
-            uint32_t        slice_loop_filter_across_slices_enabled_flag : 1;
-            uint32_t        reserved                                    : 18;
-        } fields;
-    } LongSliceFlags;
-
-    /** HEVC syntax element. Collocated Reference Picture Index.
-     * index to RefPicList[0][] or RefPicList[1][].
-     * when slice_temporal_mvp_enabled_flag equals 0, it should take value 0xFF.
-     * value range [0..14, 0xFF].
-     */
-    uint8_t                 collocated_ref_idx;
-    /** HEVC syntax element.
-     * if num_ref_idx_active_override_flag equals 0, host decoder should
-     * set its value to num_ref_idx_l0_default_minus1.
-     */
-    uint8_t                 num_ref_idx_l0_active_minus1;
-    /** HEVC syntax element.
-     * if num_ref_idx_active_override_flag equals 0, host decoder should
-     * set its value to num_ref_idx_l1_default_minus1.
-     */
-    uint8_t                 num_ref_idx_l1_active_minus1;
-    /** HEVC syntax element. */
-    int8_t                  slice_qp_delta;
-    /** HEVC syntax element. */
-    int8_t                  slice_cb_qp_offset;
-    /** HEVC syntax element. */
-    int8_t                  slice_cr_qp_offset;
-    /** HEVC syntax element. */
-    int8_t                  slice_beta_offset_div2;
-    /** HEVC syntax element. */
-    int8_t                  slice_tc_offset_div2;
-    /** HEVC syntax element. */
-    uint8_t                 luma_log2_weight_denom;
-    /** HEVC syntax element. */
-    int8_t                  delta_chroma_log2_weight_denom;
-    /** HEVC syntax element. */
-    int8_t                  delta_luma_weight_l0[15];
-    /** HEVC syntax element. */
-    int8_t                  luma_offset_l0[15];
-    /** HEVC syntax element. */
-    int8_t                  delta_chroma_weight_l0[15][2];
-    /** corresponds to HEVC spec variable of the same name. */
-    int8_t                  ChromaOffsetL0[15][2];
-    /** HEVC syntax element. */
-    int8_t                  delta_luma_weight_l1[15];
-    /** HEVC syntax element. */
-    int8_t                  luma_offset_l1[15];
-    /** HEVC syntax element. */
-    int8_t                  delta_chroma_weight_l1[15][2];
-    /** corresponds to HEVC spec variable of the same name. */
-    int8_t                  ChromaOffsetL1[15][2];
-    /** HEVC syntax element. */
-    uint8_t                 five_minus_max_num_merge_cand;
-    /**@}*/
-
-} VASliceParameterBufferHEVC;
-
-
-
-/**
- * \brief HEVC Inverse Quantization Matrix Buffer Structure
- *
- * This structure is sent once per frame,
- * and only when scaling_list_enabled_flag = 1.
- * When sps_scaling_list_data_present_flag = 0, app still
- * needs to send in this structure with default matrix values.
- *
- * Matrix entries are in raster scan order which follows HEVC spec.
- */
-typedef struct _VAIQMatrixBufferHEVC
-{
-    /**
-     * \brief scaling lists,
-     * corresponds to same HEVC spec syntax element
-     * ScalingList[ i ][ MatrixID ][ j ].
-     *
-     * \brief 4x4 scaling,
-     * correspongs i = 0, MatrixID is in the range of 0 to 5,
-     * inclusive. And j is in the range of 0 to 15, inclusive.
-     */
-    uint8_t                 ScalingList4x4[6][16];
-    /**
-     * \brief 8x8 scaling,
-     * correspongs i = 1, MatrixID is in the range of 0 to 5,
-     * inclusive. And j is in the range of 0 to 63, inclusive.
-     */
-    uint8_t                 ScalingList8x8[6][64];
-    /**
-     * \brief 16x16 scaling,
-     * correspongs i = 2, MatrixID is in the range of 0 to 5,
-     * inclusive. And j is in the range of 0 to 63, inclusive.
-     */
-    uint8_t                 ScalingList16x16[6][64];
-    /**
-     * \brief 32x32 scaling,
-     * correspongs i = 3, MatrixID is in the range of 0 to 1,
-     * inclusive. And j is in the range of 0 to 63, inclusive.
-     */
-    uint8_t                 ScalingList32x32[2][64];
-    /**
-     * \brief DC values of the 16x16 scaling lists,
-     * corresponds to HEVC spec syntax
-     * scaling_list_dc_coef_minus8[ sizeID - 2 ][ matrixID ] + 8
-     * with sizeID = 2 and matrixID in the range of 0 to 5, inclusive.
-     */
-    uint8_t                 ScalingListDC16x16[6];
-    /**
-     * \brief DC values of the 32x32 scaling lists,
-     * corresponds to HEVC spec syntax
-     * scaling_list_dc_coef_minus8[ sizeID - 2 ][ matrixID ] + 8
-     * with sizeID = 3 and matrixID in the range of 0 to 1, inclusive.
-     */
-    uint8_t                 ScalingListDC32x32[2];
-} VAIQMatrixBufferHEVC;
-
-
-/**@}*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* VA_DEC_HEVC_H */
diff --git a/third_party/libva/va/va_dec_jpeg.h b/third_party/libva/va/va_dec_jpeg.h
deleted file mode 100644
index 644ce3b..0000000
--- a/third_party/libva/va/va_dec_jpeg.h
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- * Copyright (c) 2007-2012 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * \file va_dec_jpeg.h
- * \brief The JPEG decoding API
- *
- * This file contains the \ref api_dec_jpeg "JPEG decoding API".
- */
-
-#ifndef VA_DEC_JPEG_H
-#define VA_DEC_JPEG_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <va/va.h>
-
-/**
- * \defgroup api_dec_jpeg JPEG decoding API
- *
- * This JPEG decoding API supports Baseline profile only.
- *
- * @{
- */
-
-/**
- * \brief Picture parameter for JPEG decoding.
- *
- * This structure holds information from the frame header, along with
- * definitions from additional segments.
- */
-typedef struct _VAPictureParameterBufferJPEGBaseline {
-    /** \brief Picture width in pixels. */
-    unsigned short      picture_width;
-    /** \brief Picture height in pixels. */
-    unsigned short      picture_height;
-
-    struct {
-        /** \brief Component identifier (Ci). */
-        unsigned char   component_id;
-        /** \brief Horizontal sampling factor (Hi). */
-        unsigned char   h_sampling_factor;
-        /** \brief Vertical sampling factor (Vi). */
-        unsigned char   v_sampling_factor;
-        /* \brief Quantization table selector (Tqi). */
-        unsigned char   quantiser_table_selector;
-    }                   components[255];
-    /** \brief Number of components in frame (Nf). */
-    unsigned char       num_components;
-} VAPictureParameterBufferJPEGBaseline;
-
-/**
- * \brief Quantization table for JPEG decoding.
- *
- * This structure holds the complete quantization tables. This is an
- * aggregation of all quantization table (DQT) segments maintained by
- * the application. i.e. up to 4 quantization tables are stored in
- * there for baseline profile.
- *
- * The #load_quantization_table array can be used as a hint to notify
- * the VA driver implementation about which table(s) actually changed
- * since the last submission of this buffer.
- *
- * The #quantiser_table values are specified in zig-zag scan order.
- */
-typedef struct _VAIQMatrixBufferJPEGBaseline {
-    /** \brief Specifies which #quantiser_table is valid. */
-    unsigned char       load_quantiser_table[4];
-    /** \brief Quanziation tables indexed by table identifier (Tqi). */
-    unsigned char       quantiser_table[4][64];
-} VAIQMatrixBufferJPEGBaseline;
-
-/**
- * \brief Slice parameter for JPEG decoding.
- *
- * This structure holds information from the scan header, along with
- * definitions from additional segments. The associated slice data
- * buffer holds all entropy coded segments (ECS) in the scan.
- */
-typedef struct _VASliceParameterBufferJPEGBaseline {
-    /** @name Codec-independent Slice Parameter Buffer base. */
-    /**@{*/
-    /** \brief Number of bytes in the slice data buffer for this slice. */
-    unsigned int        slice_data_size;
-    /** \brief The offset to the first byte of the first MCU. */
-    unsigned int        slice_data_offset;
-    /** \brief Slice data buffer flags. See \c VA_SLICE_DATA_FLAG_xxx. */
-    unsigned int        slice_data_flag;
-    /**@}*/
-
-    /** \brief Scan horizontal position. */
-    unsigned int        slice_horizontal_position;
-    /** \brief Scan vertical position. */
-    unsigned int        slice_vertical_position;
-
-    struct {
-        /** \brief Scan component selector (Csj). */
-        unsigned char   component_selector;
-        /** \brief DC entropy coding table selector (Tdj). */
-        unsigned char   dc_table_selector;
-        /** \brief AC entropy coding table selector (Taj). */
-        unsigned char   ac_table_selector;
-    }                   components[4];
-    /** \brief Number of components in scan (Ns). */
-    unsigned char       num_components;
-
-    /** \brief Restart interval definition (Ri). */
-    unsigned short      restart_interval;
-    /** \brief Number of MCUs in a scan. */
-    unsigned int        num_mcus;
-} VASliceParameterBufferJPEGBaseline;
-
-/**@}*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* VA_DEC_JPEG_H */
diff --git a/third_party/libva/va/va_dec_vp8.h b/third_party/libva/va/va_dec_vp8.h
deleted file mode 100644
index 32830cb..0000000
--- a/third_party/libva/va/va_dec_vp8.h
+++ /dev/null
@@ -1,243 +0,0 @@
-/*
- * Copyright (c) 2007-2012 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * \file va_dec_vp.h
- * \brief VP8 decoding API
- *
- * This file contains the \ref api_dec_vp8 "VP8 decoding API".
- */
-
-#ifndef VA_DEC_VP8_H
-#define VA_DEC_VP8_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * \defgroup api_dec_vp8 VP8 decoding API
- *
- * @{
- */
-
-/**
- * \brief VPX Bool Coder Context structure 
- *
- * This common structure is defined for potential sharing by other VP formats
- *
- */
-typedef struct _VABoolCoderContextVPX
-{
-    /* partition 0 "range" */
-    unsigned char range;
-    /* partition 0 "value" */
-    unsigned char value;
-    /*
-     * 'partition 0 number of shifts before an output byte is available'
-     * it is the number of remaining bits in 'value' for decoding, range [0, 7].
-     */
-
-    unsigned char count;
-} VABoolCoderContextVPX;
-
-/**
- * \brief VP8 Decoding Picture Parameter Buffer Structure
- *
- * This structure conveys frame level parameters and should be sent once
- * per frame.
- *
- */
-typedef struct  _VAPictureParameterBufferVP8
-{
-    /* frame width in pixels */
-    unsigned int frame_width;
-    /* frame height in pixels */
-    unsigned int frame_height;
-
-    /* specifies the "last" reference frame */
-    VASurfaceID last_ref_frame;
-    /* specifies the "golden" reference frame */
-    VASurfaceID golden_ref_frame;
-    /* specifies the "alternate" referrence frame */
-    VASurfaceID alt_ref_frame;
-    /* specifies the out-of-loop deblocked frame, not used currently */
-    VASurfaceID out_of_loop_frame;
-
-    union {
-        struct {
-	    /* same as key_frame in bitstream syntax, 0 means a key frame */
-            unsigned int key_frame			: 1; 
-	    /* same as version in bitstream syntax */
-            unsigned int version			: 3;
-	    /* same as segmentation_enabled in bitstream syntax */
-            unsigned int segmentation_enabled		: 1;
-	    /* same as update_mb_segmentation_map in bitstream syntax */
-            unsigned int update_mb_segmentation_map	: 1;
-	    /* same as update_segment_feature_data in bitstream syntax */
-            unsigned int update_segment_feature_data	: 1;
-	    /* same as filter_type in bitstream syntax */
-            unsigned int filter_type			: 1; 
-	    /* same as sharpness_level in bitstream syntax */
-            unsigned int sharpness_level		: 3; 
-	    /* same as loop_filter_adj_enable in bitstream syntax */
-            unsigned int loop_filter_adj_enable		: 1; 
-	    /* same as mode_ref_lf_delta_update in bitstream syntax */
-            unsigned int mode_ref_lf_delta_update	: 1; 
-	    /* same as sign_bias_golden in bitstream syntax */
-            unsigned int sign_bias_golden		: 1; 
-	    /* same as sign_bias_alternate in bitstream syntax */
-            unsigned int sign_bias_alternate		: 1; 
-	    /* same as mb_no_coeff_skip in bitstream syntax */
-            unsigned int mb_no_coeff_skip		: 1; 
-	    /* flag to indicate that loop filter should be disabled */
-            unsigned int loop_filter_disable		: 1; 
-        } bits;
-        unsigned int value;
-    } pic_fields;
-
-    /*
-     * probabilities of the segment_id decoding tree and same as 
-     * mb_segment_tree_probs in the spec.
-     */
-    unsigned char mb_segment_tree_probs[3];
-
-    /* Post-adjustment loop filter levels for the 4 segments */
-    unsigned char loop_filter_level[4];
-    /* loop filter deltas for reference frame based MB level adjustment */
-    char loop_filter_deltas_ref_frame[4];
-    /* loop filter deltas for coding mode based MB level adjustment */
-    char loop_filter_deltas_mode[4];
-
-    /* same as prob_skip_false in bitstream syntax */
-    unsigned char prob_skip_false;
-    /* same as prob_intra in bitstream syntax */
-    unsigned char prob_intra;
-    /* same as prob_last in bitstream syntax */
-    unsigned char prob_last;
-    /* same as prob_gf in bitstream syntax */
-    unsigned char prob_gf;
-
-    /* 
-     * list of 4 probabilities of the luma intra prediction mode decoding
-     * tree and same as y_mode_probs in frame header
-     */
-    unsigned char y_mode_probs[4]; 
-    /*
-     * list of 3 probabilities of the chroma intra prediction mode decoding
-     * tree and same as uv_mode_probs in frame header
-     */
-    unsigned char uv_mode_probs[3];
-    /* 
-     * updated mv decoding probabilities and same as mv_probs in 
-     * frame header
-     */
-    unsigned char mv_probs[2][19];
-
-    VABoolCoderContextVPX bool_coder_ctx;
-
-} VAPictureParameterBufferVP8;
-
-/**
- * \brief VP8 Slice Parameter Buffer Structure
- *
- * This structure conveys parameters related to data partitions and should be 
- * sent once per frame. Slice data buffer of VASliceDataBufferType is used
- * to send the partition data.
- *
- */
-typedef struct  _VASliceParameterBufferVP8
-{
-    /*
-     * number of bytes in the slice data buffer for the partitions 
-     */
-    unsigned int slice_data_size;
-    /*
-     * offset to the first byte of partition data (control partition)
-     */
-    unsigned int slice_data_offset;
-    /*
-     * see VA_SLICE_DATA_FLAG_XXX definitions
-     */
-    unsigned int slice_data_flag; 
-    /*
-     * offset to the first bit of MB from the first byte of partition data(slice_data_offset)
-     */
-    unsigned int macroblock_offset;
-
-    /*
-     * Partitions
-     * (1<<log2_nbr_of_dct_partitions)+1, count both control partition (frame header) and toke partition
-     */
-    unsigned char num_of_partitions;
-    /*
-     * partition_size[0] is remaining bytes of control partition after parsed by application.
-     * exclude current byte for the remaining bits in bool_coder_ctx.
-     * exclude the uncompress data chunk since first_part_size 'excluding the uncompressed data chunk'
-     */
-    unsigned int partition_size[9];
-} VASliceParameterBufferVP8;
-
-/**
- * \brief VP8 Coefficient Probability Data Buffer Structure
- *
- * Contains the contents of the token probability table, which may be 
- * incrementally modified in the frame header. There are four dimensions to 
- * the token probability array. The outermost dimension is indexed by the 
- * type of plane being decoded; the next dimension is selected by the 
- * position of the coefficient being decoded; the third dimension, * roughly 
- * speaking, measures the "local complexity" or extent to which nearby 
- * coefficients are non-zero; the fourth, and final, dimension of the token 
- * probability array is indexed by the position in the token tree structure, 
- * as are all tree probability arrays. This structure is sent once per frame.
- *
- */
-typedef struct _VAProbabilityDataBufferVP8
-{
-    unsigned char dct_coeff_probs[4][8][3][11];
-} VAProbabilityDataBufferVP8;
-
-/**
- * \brief VP8 Inverse Quantization Matrix Buffer Structure
- *
- * Contains quantization indices for yac(0),ydc(1),y2dc(2),y2ac(3),uvdc(4),
- * uvac(5) for each segment (0-3). When segmentation is disabled, only  
- * quantization_index[0][] will be used. This structure is sent once per frame.
- */
-typedef struct _VAIQMatrixBufferVP8
-{
-    /* 
-     * array first dimensional is segment and 2nd dimensional is Q index
-     * all Q indexs should be clipped to be range [0, 127]
-     */
-    unsigned short quantization_index[4][6];
-} VAIQMatrixBufferVP8;
-
-/**@}*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* VA_DEC_VP8_H */
diff --git a/third_party/libva/va/va_dec_vp9.h b/third_party/libva/va/va_dec_vp9.h
deleted file mode 100644
index eff80e1..0000000
--- a/third_party/libva/va/va_dec_vp9.h
+++ /dev/null
@@ -1,321 +0,0 @@
-/*
- * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * \file va_dec_vp9.h
- * \brief The VP9 decoding API
- *
- * This file contains the \ref api_dec_vp9 "VP9 decoding API".
- */
-
-#ifndef VA_DEC_VP9_H
-#define VA_DEC_VP9_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * \defgroup api_dec_vp9 VP9 decoding API
- *
- * This VP9 decoding API supports 8-bit 420 format only.
- *
- * @{
- */
-
-
-
-
-/**
- * \brief VP9 Decoding Picture Parameter Buffer Structure
- *
- * This structure conveys picture level parameters.
- * App should send a surface with this data structure down to VAAPI once
- * per frame.
- *
- */
-typedef struct  _VADecPictureParameterBufferVP9
-{
-    /**@{*/
-
-    /** \brief picture width
-     *  Picture original resolution. The value may not be multiple of 8.
-     */
-    uint16_t                frame_width;
-    /** \brief picture height
-     *  Picture original resolution. The value may not be multiple of 8.
-     */
-    uint16_t                frame_height;
-
-    /** \brief Surface indices of reference frames in DPB.
-     *
-     *  Each entry of the list specifies the surface index of the picture
-     *  that is referred by current picture or will be referred by any future
-     *  picture.
-     *  Application who calls this API should update this list based on the
-     *  refreshing information from VP9 bitstream.
-     */
-    VASurfaceID             reference_frames[8];
-
-    union
-    {
-        struct
-        {
-            /** \brief flags for current picture
-             *  same syntax and semantic as those in VP9 code
-             */
-            uint32_t        subsampling_x                               : 1;
-            uint32_t        subsampling_y                               : 1;
-            uint32_t        frame_type                                  : 1;
-            uint32_t        show_frame                                  : 1;
-            uint32_t        error_resilient_mode                        : 1;
-            uint32_t        intra_only                                  : 1;
-            uint32_t        allow_high_precision_mv                     : 1;
-            uint32_t        mcomp_filter_type                           : 3;
-            uint32_t        frame_parallel_decoding_mode                : 1;
-            uint32_t        reset_frame_context                         : 2;
-            uint32_t        refresh_frame_context                       : 1;
-            uint32_t        frame_context_idx                           : 2;
-            uint32_t        segmentation_enabled                        : 1;
-
-            /** \brief corresponds to variable temporal_update in VP9 code.
-             */
-            uint32_t        segmentation_temporal_update                : 1;
-            /** \brief corresponds to variable update_mb_segmentation_map
-             *  in VP9 code.
-             */
-            uint32_t        segmentation_update_map                     : 1;
-
-            /** \brief Index of reference_frames[] and points to the
-             *  LAST reference frame.
-             *  It corresponds to active_ref_idx[0] in VP9 code.
-             */
-            uint32_t        last_ref_frame                              : 3;
-            /** \brief Sign Bias of the LAST reference frame.
-             *  It corresponds to ref_frame_sign_bias[LAST_FRAME] in VP9 code.
-             */
-            uint32_t        last_ref_frame_sign_bias                    : 1;
-            /** \brief Index of reference_frames[] and points to the
-             *  GOLDERN reference frame.
-             *  It corresponds to active_ref_idx[1] in VP9 code.
-             */
-            uint32_t        golden_ref_frame                            : 3;
-            /** \brief Sign Bias of the GOLDERN reference frame.
-             *  Corresponds to ref_frame_sign_bias[GOLDERN_FRAME] in VP9 code.
-             */
-            uint32_t        golden_ref_frame_sign_bias                  : 1;
-            /** \brief Index of reference_frames[] and points to the
-             *  ALTERNATE reference frame.
-             *  Corresponds to active_ref_idx[2] in VP9 code.
-             */
-            uint32_t        alt_ref_frame                               : 3;
-            /** \brief Sign Bias of the ALTERNATE reference frame.
-             *  Corresponds to ref_frame_sign_bias[ALTREF_FRAME] in VP9 code.
-             */
-            uint32_t        alt_ref_frame_sign_bias                     : 1;
-            /** \brief Lossless Mode
-             *  LosslessFlag = base_qindex == 0 &&
-             *                 y_dc_delta_q == 0 &&
-             *                 uv_dc_delta_q == 0 &&
-             *                 uv_ac_delta_q == 0;
-             *  Where base_qindex, y_dc_delta_q, uv_dc_delta_q and uv_ac_delta_q
-             *  are all variables in VP9 code.
-             */
-            uint32_t        lossless_flag                               : 1;
-        } bits;
-        uint32_t            value;
-    } pic_fields;
-
-    /* following parameters have same syntax with those in VP9 code */
-    uint8_t                 filter_level;
-    uint8_t                 sharpness_level;
-
-    /** \brief number of tile rows specified by (1 << log2_tile_rows).
-     *  It corresponds the variable with same name in VP9 code.
-     */
-    uint8_t                 log2_tile_rows;
-    /** \brief number of tile columns specified by (1 << log2_tile_columns).
-     *  It corresponds the variable with same name in VP9 code.
-     */
-    uint8_t                 log2_tile_columns;
-    /** \brief Number of bytes taken up by the uncompressed frame header,
-     *  which corresponds to byte length of function
-     *  read_uncompressed_header() in VP9 code.
-     *  Specifically, it is the byte count from bit stream buffer start to
-     *  the last byte of uncompressed frame header.
-     *  If there are other meta data in the buffer before uncompressed header,
-     *  its size should be also included here.
-     */
-    uint8_t                 frame_header_length_in_bytes;
-
-    /** \brief The byte count of compressed header the bitstream buffer,
-     *  which corresponds to syntax first_partition_size in code.
-     */
-    uint16_t                first_partition_size;
-
-    /** These values are segment probabilities with same names in VP9
-     *  function setup_segmentation(). They should be parsed directly from
-     *  bitstream by application.
-     */
-    uint8_t                 mb_segment_tree_probs[7];
-    uint8_t                 segment_pred_probs[3];
-
-    /** \brief VP9 Profile definition
-     *  value range [0..3].
-     */
-    uint8_t                 profile;
-
-    /** \brief VP9 bit depth per sample
-     *  same for both luma and chroma samples.
-     */
-    uint8_t bit_depth;
-
-    /**@}*/
-
-} VADecPictureParameterBufferVP9;
-
-
-
-/**
- * \brief VP9 Segmentation Parameter Data Structure
- *
- * This structure conveys per segment parameters.
- * 8 of this data structure will be included in VASegmentationParameterBufferVP9
- * and sent to API in a single buffer.
- *
- */
-typedef struct  _VASegmentParameterVP9
-{
-    /**@{*/
-
-    union
-    {
-        struct
-        {
-            /** \brief Indicates if per segment reference frame indicator
-             *  is enabled.
-             *  Corresponding to variable feature_enabled when
-             *  j == SEG_LVL_REF_FRAME in function setup_segmentation() VP9 code.
-             */
-            uint16_t        segment_reference_enabled                   : 1;
-            /** \brief Specifies per segment reference indication.
-             *  0: reserved
-             *  1: Last ref
-             *  2: golden
-             *  3: altref
-             *  Value can be derived from variable data when
-             *  j == SEG_LVL_REF_FRAME in function setup_segmentation() VP9 code.
-             */
-            uint16_t        segment_reference                           : 2;
-            /** \brief Indicates if per segment skip feature is enabled.
-             *  Corresponding to variable feature_enabled when
-             *  j == SEG_LVL_SKIP in function setup_segmentation() VP9 code.
-             */
-            uint16_t        segment_reference_skipped                   : 1;
-        } fields;
-        uint16_t            value;
-    } segment_flags;
-
-    /** \brief Specifies the filter level information per segment.
-     *  The value corresponds to variable lfi->lvl[seg][ref][mode] in VP9 code,
-     *  where m is [ref], and n is [mode] in FilterLevel[m][n].
-     */
-    uint8_t                 filter_level[4][2];
-    /** \brief Specifies per segment Luma AC quantization scale.
-     *  Corresponding to y_dequant[qindex][1] in vp9_mb_init_quantizer()
-     *  function of VP9 code.
-     */
-    int16_t                 luma_ac_quant_scale;
-    /** \brief Specifies per segment Luma DC quantization scale.
-     *  Corresponding to y_dequant[qindex][0] in vp9_mb_init_quantizer()
-     *  function of VP9 code.
-     */
-    int16_t                 luma_dc_quant_scale;
-    /** \brief Specifies per segment Chroma AC quantization scale.
-     *  Corresponding to uv_dequant[qindex][1] in vp9_mb_init_quantizer()
-     *  function of VP9 code.
-     */
-    int16_t                 chroma_ac_quant_scale;
-    /** \brief Specifies per segment Chroma DC quantization scale.
-     *  Corresponding to uv_dequant[qindex][0] in vp9_mb_init_quantizer()
-     *  function of VP9 code.
-     */
-    int16_t                 chroma_dc_quant_scale;
-
-    /**@}*/
-
-} VASegmentParameterVP9;
-
-
-
-/**
- * \brief VP9 Slice Parameter Buffer Structure
- *
- * This structure conveys parameters related to segmentation data and should be
- * sent once per frame.
- *
- * When segmentation is disabled, only SegParam[0] has valid values,
- * all other entries should be populated with 0.
- * Otherwise, all eight entries should be valid.
- *
- * Slice data buffer of VASliceDataBufferType is used
- * to send the bitstream which should include whole or part of partition 0
- * (at least compressed header) to the end of frame.
- *
- */
-typedef struct _VASliceParameterBufferVP9
-{
-    /**@{*/
-    /** \brief The byte count of current frame in the bitstream buffer,
-     *  starting from first byte of the buffer.
-     *  It uses the name slice_data_size to be consitent with other codec,
-     *  but actually means frame_data_size.
-     */
-    uint32_t slice_data_size;
-    /**
-     * offset to the first byte of partition data (control partition)
-     */
-    uint32_t slice_data_offset;
-    /**
-     * see VA_SLICE_DATA_FLAG_XXX definitions
-     */
-    uint32_t slice_data_flag;
-
-    /**
-     * \brief per segment information
-     */
-    VASegmentParameterVP9   seg_param[8];
-
-    /**@}*/
-
-} VASliceParameterBufferVP9;
-
-
-/**@}*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* VA_DEC_VP9_H */
diff --git a/third_party/libva/va/va_drmcommon.h b/third_party/libva/va/va_drmcommon.h
deleted file mode 100644
index 76820a3..0000000
--- a/third_party/libva/va/va_drmcommon.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * va_drmcommon.h - Common utilities for DRM-based drivers
- *
- * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef VA_DRM_COMMON_H
-#define VA_DRM_COMMON_H
-
-/** \brief DRM authentication type. */
-enum {
-    /** \brief Disconnected. */
-    VA_DRM_AUTH_NONE    = 0,
-    /**
-     * \brief Connected. Authenticated with DRI1 protocol.
-     *
-     * @deprecated
-     * This is a deprecated authentication type. All DRI-based drivers have
-     * been migrated to use the DRI2 protocol. Newly written drivers shall
-     * use DRI2 protocol only, or a custom authentication means. e.g. opt
-     * for authenticating on the VA driver side, instead of libva side.
-     */
-    VA_DRM_AUTH_DRI1    = 1,
-    /**
-     * \brief Connected. Authenticated with DRI2 protocol.
-     *
-     * This is only useful to VA/X11 drivers. The libva-x11 library provides
-     * a helper function VA_DRI2Authenticate() for authenticating the
-     * connection. However, DRI2 conformant drivers don't need to call that
-     * function since authentication happens on the libva side, implicitly.
-     */
-    VA_DRM_AUTH_DRI2    = 2,
-    /**
-     * \brief Connected. Authenticated with some alternate raw protocol.
-     *
-     * This authentication mode is mainly used in non-VA/X11 drivers.
-     * Authentication happens through some alternative method, at the
-     * discretion of the VA driver implementation.
-     */
-    VA_DRM_AUTH_CUSTOM  = 3
-};
-
-/** \brief Base DRM state. */
-struct drm_state {
-    /** \brief DRM connection descriptor. */
-    int         fd;
-    /** \brief DRM authentication type. */
-    int         auth_type;
-};
-
-/** \brief Kernel DRM buffer memory type.  */
-#define VA_SURFACE_ATTRIB_MEM_TYPE_KERNEL_DRM		0x10000000
-/** \brief DRM PRIME memory type. */
-#define VA_SURFACE_ATTRIB_MEM_TYPE_DRM_PRIME		0x20000000
-
-#endif /* VA_DRM_COMMON_H */
diff --git a/third_party/libva/va/va_enc_h264.h b/third_party/libva/va/va_enc_h264.h
deleted file mode 100644
index 8ec18ea..0000000
--- a/third_party/libva/va/va_enc_h264.h
+++ /dev/null
@@ -1,543 +0,0 @@
-/*
- * Copyright (c) 2007-2011 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * \file va_enc_h264.h
- * \brief The H.264 encoding API
- *
- * This file contains the \ref api_enc_h264 "H.264 encoding API".
- */
-
-#ifndef VA_ENC_H264_H
-#define VA_ENC_H264_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * \defgroup api_enc_h264 H.264 encoding API
- *
- * @{
- */
-
-/**
- * @name Picture flags
- *
- * Those flags flags are meant to signal when a picture marks the end
- * of a sequence, a stream, or even both at once.
- *
- * @{
- */
-/**
- * \brief Marks the last picture in the sequence.
- *
- * i.e. the driver appends \c end_of_seq() NAL unit to the encoded frame.
- */
-#define H264_LAST_PICTURE_EOSEQ     0x01
-/**
- * \brief Marks the last picture in the stream.
- *
- * i.e. the driver appends \c end_of_stream() NAL unit to the encoded frame.
- */
-#define H264_LAST_PICTURE_EOSTREAM  0x02
-/**@}*/
-
-/**
- * \brief Packed header types specific to H.264 encoding.
- *
- * Types of packed headers generally used for H.264 encoding. Each
- * associated packed header data buffer shall contain the start code
- * prefix 0x000001 followed by the complete NAL unit, thus also
- * including the \c nal_unit_type.
- *
- * Note: the start code prefix can contain an arbitrary number of leading
- * zeros. The driver will skip them for emulation prevention bytes insertion,
- * if necessary.
- */
-typedef enum {
-    /**
-     * \brief Packed Sequence Parameter Set (SPS).
-     *
-     * The corresponding packed header data buffer shall contain the
-     * complete seq_parameter_set_rbsp() syntax element.
-     *
-     * Note: packed \c nal_unit_type shall be equal to 7.
-     */
-    VAEncPackedHeaderH264_SPS   = VAEncPackedHeaderSequence,
-    /**
-     * \brief Packed Picture Parameter Set (PPS).
-     *
-     * The corresponding packed header data buffer shall contain the
-     * complete pic_parameter_set_rbsp() syntax element.
-     *
-     * Note: packed \c nal_unit_type shall be equal to 8.
-     */
-    VAEncPackedHeaderH264_PPS   = VAEncPackedHeaderPicture,
-    /**
-     * \brief Packed slice header.
-     *
-     * The corresponding packed header data buffer shall contain the
-     * \c slice_header() syntax element only, along with any start
-     * code prefix and NAL unit type preceeding it. i.e. this means
-     * that the buffer does not contain any of the \c slice_data() or
-     * the \c rbsp_slice_trailing_bits().
-     *
-     * Note: packed \c nal_unit_type shall be equal to 1 (non-IDR
-     * picture), or 5 (IDR picture).
-     */
-    VAEncPackedHeaderH264_Slice = VAEncPackedHeaderSlice,
-    /**
-     * \brief Packed Supplemental Enhancement Information (SEI).
-     *
-     * The corresponding packed header data buffer shall contain the
-     * complete sei_rbsp() syntax element, thus including several
-     * sei_message() elements if necessary.
-     *
-     * Note: packed \c nal_unit_type shall be equal to 6.
-     */
-    VAEncPackedHeaderH264_SEI   = (VAEncPackedHeaderMiscMask | 1),
-} VAEncPackedHeaderTypeH264;
-
-/**
- * \brief Sequence parameter for H.264 encoding in baseline, main & high
- * profiles.
- *
- * This structure holds information for \c seq_parameter_set_data() as
- * defined by the H.264 specification.
- *
- * If packed sequence headers mode is used, i.e. if the encoding
- * pipeline was configured with the #VA_ENC_PACKED_HEADER_SEQUENCE
- * flag, then the driver expects two more buffers to be provided to
- * the same \c vaRenderPicture() as this buffer:
- * - a #VAEncPackedHeaderParameterBuffer with type set to
- *   VAEncPackedHeaderType::VAEncPackedHeaderSequence ;
- * - a #VAEncPackedHeaderDataBuffer which holds the actual packed
- *   header data.
- *
- * If \c seq_scaling_matrix_present_flag is set to \c 1, then a
- * #VAIQMatrixBufferH264 buffer shall also be provided within the same
- * \c vaRenderPicture() call as this sequence parameter buffer.
- */
-typedef struct _VAEncSequenceParameterBufferH264 {
-    /** \brief Same as the H.264 bitstream syntax element. */
-    unsigned char   seq_parameter_set_id;
-    /** \brief Same as the H.264 bitstream syntax element. */
-    unsigned char   level_idc;
-    /** \brief Period between I frames. */
-    unsigned int    intra_period;
-    /** \brief Period between IDR frames. */
-    unsigned int    intra_idr_period;
-    /** \brief Period between I/P frames. */
-    unsigned int    ip_period;
-    /**
-     * \brief Initial bitrate set for this sequence in CBR or VBR modes.
-     *
-     * This field represents the initial bitrate value for this
-     * sequence if CBR or VBR mode is used, i.e. if the encoder
-     * pipeline was created with a #VAConfigAttribRateControl
-     * attribute set to either \ref VA_RC_CBR or \ref VA_RC_VBR.
-     *
-     * The bitrate can be modified later on through
-     * #VAEncMiscParameterRateControl buffers.
-     */
-    unsigned int    bits_per_second;
-    /** \brief Same as the H.264 bitstream syntax element. */
-    unsigned int    max_num_ref_frames;
-    /** \brief Picture width in macroblocks. */
-    unsigned short  picture_width_in_mbs;
-    /** \brief Picture height in macroblocks. */
-    unsigned short  picture_height_in_mbs;
-
-    union {
-        struct {
-            /** \brief Same as the H.264 bitstream syntax element. */
-            unsigned int chroma_format_idc                      : 2;
-            /** \brief Same as the H.264 bitstream syntax element. */
-            unsigned int frame_mbs_only_flag                    : 1;
-            /** \brief Same as the H.264 bitstream syntax element. */
-            unsigned int mb_adaptive_frame_field_flag           : 1;
-            /** \brief Same as the H.264 bitstream syntax element. */
-            unsigned int seq_scaling_matrix_present_flag        : 1;
-            /** \brief Same as the H.264 bitstream syntax element. */
-            unsigned int direct_8x8_inference_flag              : 1;
-            /** \brief Same as the H.264 bitstream syntax element. */
-            unsigned int log2_max_frame_num_minus4              : 4;
-            /** \brief Same as the H.264 bitstream syntax element. */
-            unsigned int pic_order_cnt_type                     : 2;
-            /** \brief Same as the H.264 bitstream syntax element. */
-            unsigned int log2_max_pic_order_cnt_lsb_minus4      : 4;
-            /** \brief Same as the H.264 bitstream syntax element. */
-            unsigned int delta_pic_order_always_zero_flag       : 1;
-        } bits;
-        unsigned int value;
-    } seq_fields;
-
-    /** \brief Same as the H.264 bitstream syntax element. */
-    unsigned char   bit_depth_luma_minus8;
-    /** \brief Same as the H.264 bitstream syntax element. */
-    unsigned char   bit_depth_chroma_minus8;
-
-    /** if pic_order_cnt_type == 1 */
-    /**@{*/
-    /** \brief Same as the H.264 bitstream syntax element. */
-    unsigned char   num_ref_frames_in_pic_order_cnt_cycle;
-    /** \brief Same as the H.264 bitstream syntax element. */
-    int             offset_for_non_ref_pic;
-    /** \brief Same as the H.264 bitstream syntax element. */
-    int             offset_for_top_to_bottom_field;
-    /** \brief Same as the H.264 bitstream syntax element. */
-    int             offset_for_ref_frame[256];
-    /**@}*/
-
-    /** @name Cropping (optional) */
-    /**@{*/
-    /** \brief Same as the H.264 bitstream syntax element. */
-    unsigned char   frame_cropping_flag;
-    /** \brief Same as the H.264 bitstream syntax element. */
-    unsigned int    frame_crop_left_offset;
-    /** \brief Same as the H.264 bitstream syntax element. */
-    unsigned int    frame_crop_right_offset;
-    /** \brief Same as the H.264 bitstream syntax element. */
-    unsigned int    frame_crop_top_offset;
-    /** \brief Same as the H.264 bitstream syntax element. */
-    unsigned int    frame_crop_bottom_offset;
-    /**@}*/
-
-    /** @name VUI parameters (optional) */
-    /**@{*/
-    /** \brief Same as the H.264 bitstream syntax element. */
-    unsigned char   vui_parameters_present_flag;
-    union {
-        struct {
-            /** \brief Same as the H.264 bitstream syntax element. */
-            unsigned int aspect_ratio_info_present_flag         : 1;
-            /** \brief Same as the H.264 bitstream syntax element. */
-            unsigned int timing_info_present_flag               : 1;
-            /** \brief Same as the H.264 bitstream syntax element. */
-            unsigned int bitstream_restriction_flag             : 1;
-            /** \brief Range: 0 to 16, inclusive. */
-            unsigned int log2_max_mv_length_horizontal          : 5;
-            /** \brief Range: 0 to 16, inclusive. */
-            unsigned int log2_max_mv_length_vertical            : 5;
-        } bits;
-        unsigned int value;
-    } vui_fields;
-    /** \brief Same as the H.264 bitstream syntax element. */
-    unsigned char   aspect_ratio_idc;
-    /** \brief Same as the H.264 bitstream syntax element. */
-    unsigned int    sar_width;
-    /** \brief Same as the H.264 bitstream syntax element. */
-    unsigned int    sar_height;
-    /** \brief Same as the H.264 bitstream syntax element. */
-    unsigned int    num_units_in_tick;
-    /** \brief Same as the H.264 bitstream syntax element. */
-    unsigned int    time_scale;
-    /**@}*/
-} VAEncSequenceParameterBufferH264;
-
-/**
- * \brief Picture parameter for H.264 encoding in baseline, main & high 
- * profiles.
- *
- * This structure holds information for \c pic_parameter_set_rbsp() as
- * defined by the H.264 specification.
- *
- * If packed picture headers mode is used, i.e. if the encoding
- * pipeline was configured with the #VA_ENC_PACKED_HEADER_PICTURE
- * flag, then the driver expects two more buffers to be provided to
- * the same \c vaRenderPicture() as this buffer:
- * - a #VAEncPackedHeaderParameterBuffer with type set to
- *   VAEncPackedHeaderType::VAEncPackedHeaderPicture ;
- * - a #VAEncPackedHeaderDataBuffer which holds the actual packed
- *   header data.
- *
- * If \c pic_scaling_matrix_present_flag is set to \c 1, then a
- * #VAIQMatrixBufferH264 buffer shall also be provided within the same
- * \c vaRenderPicture() call as this picture parameter buffer.
- */
-typedef struct _VAEncPictureParameterBufferH264 {
-    /**
-     * \brief Information about the picture to be encoded.
-     *
-     * See #VAPictureH264 for further description of each field.
-     * Note that CurrPic.picture_id represents the reconstructed
-     * (decoded) picture. User provides a scratch VA surface ID here.
-     */
-    VAPictureH264   CurrPic;
-    /**
-     * \brief Decoded Picture Buffer (DPB).
-     *
-     * This array represents the list of reconstructed (decoded)
-     * frames used as reference. It is important to keep track of
-     * reconstructed frames so that they can be used later on as
-     * reference for P or B-frames encoding.
-     */
-    VAPictureH264   ReferenceFrames[16];
-    /**
-     * \brief Output encoded bitstream.
-     *
-     * \ref coded_buf has type #VAEncCodedBufferType. It should be
-     * large enough to hold the compressed NAL slice and possibly SPS
-     * and PPS NAL units.
-     */
-    VABufferID      coded_buf;
-
-    /** \brief The picture parameter set referred to in the slice header. */
-    unsigned char   pic_parameter_set_id;
-    /** \brief The active sequence parameter set. Range: 0 to 31, inclusive. */
-    unsigned char   seq_parameter_set_id;
-
-    /**
-     * \brief OR'd flags describing whether the picture is the last one or not.
-     *
-     * This fields holds 0 if the picture to be encoded is not the last
-     * one in the stream or sequence. Otherwise, it is a combination of
-     * \ref H264_LAST_PICTURE_EOSEQ or \ref H264_LAST_PICTURE_EOSTREAM.
-     */
-    unsigned char   last_picture;
-
-    /** \brief The picture identifier.
-     *   Range: 0 to \f$2^{log2\_max\_frame\_num\_minus4 + 4} - 1\f$, inclusive.
-     */
-    unsigned short  frame_num;
-
-    /** \brief \c pic_init_qp_minus26 + 26. */
-    unsigned char   pic_init_qp;
-    /** \brief Maximum reference index for reference picture list 0.
-     *   Range: 0 to 31, inclusive.
-     */
-    unsigned char   num_ref_idx_l0_active_minus1;
-    /** \brief Maximum reference index for reference picture list 1.
-     *  Range: 0 to 31, inclusive.
-     */
-    unsigned char   num_ref_idx_l1_active_minus1;
-
-    /** \brief Range: -12 to 12, inclusive. */
-    signed char     chroma_qp_index_offset;
-    /** \brief Range: -12 to 12, inclusive. */
-    signed char     second_chroma_qp_index_offset;
-
-    union {
-        struct {
-            /** \brief Is picture an IDR picture? */
-            unsigned int idr_pic_flag                           : 1;
-            /** \brief Is picture a reference picture? */
-            unsigned int reference_pic_flag                     : 2;
-            /** \brief Selects CAVLC (0) or CABAC (1) entropy coding mode. */
-            unsigned int entropy_coding_mode_flag               : 1;
-            /** \brief Is weighted prediction applied to P slices? */
-            unsigned int weighted_pred_flag                     : 1;
-            /** \brief Range: 0 to 2, inclusive. */
-            unsigned int weighted_bipred_idc                    : 2;
-            /** \brief Same as the H.264 bitstream syntax element. */
-            unsigned int constrained_intra_pred_flag            : 1;
-            /** \brief Same as the H.264 bitstream syntax element. */
-            unsigned int transform_8x8_mode_flag                : 1;
-            /** \brief Same as the H.264 bitstream syntax element. */
-            unsigned int deblocking_filter_control_present_flag : 1;
-            /** \brief Same as the H.264 bitstream syntax element. */
-            unsigned int redundant_pic_cnt_present_flag         : 1;
-            /** \brief Same as the H.264 bitstream syntax element. */
-            unsigned int pic_order_present_flag                 : 1;
-            /** \brief Same as the H.264 bitstream syntax element. */
-            unsigned int pic_scaling_matrix_present_flag        : 1;
-        } bits;
-        unsigned int value;
-    } pic_fields;
-} VAEncPictureParameterBufferH264;
-
-/**
- * \brief Slice parameter for H.264 encoding in baseline, main & high profiles.
- *
- * This structure holds information for \c
- * slice_layer_without_partitioning_rbsp() as defined by the H.264
- * specification.
- *
- * If packed slice headers mode is used, i.e. if the encoding
- * pipeline was configured with the #VA_ENC_PACKED_HEADER_SLICE
- * flag, then the driver expects two more buffers to be provided to
- * the same \c vaRenderPicture() as this buffer:
- * - a #VAEncPackedHeaderParameterBuffer with type set to
- *   VAEncPackedHeaderType::VAEncPackedHeaderSlice ;
- * - a #VAEncPackedHeaderDataBuffer which holds the actual packed
- *   header data.
- *
- * If per-macroblock encoder configuration is needed, \c macroblock_info
- * references a buffer of type #VAEncMacroblockParameterBufferH264. This
- * buffer is not passed to vaRenderPicture(). i.e. it is not destroyed
- * by subsequent calls to vaRenderPicture() and then can be re-used
- * without re-allocating the whole buffer.
- */
-typedef struct _VAEncSliceParameterBufferH264 {
-    /** \brief Starting MB address for this slice. */
-    unsigned int    macroblock_address;
-    /** \brief Number of macroblocks in this slice. */
-    unsigned int    num_macroblocks;
-    /**
-     * \brief Per-MB encoder configuration buffer, or \c VA_INVALID_ID.
-     *
-     * If per-MB encoder configuration is needed, then \ref macroblock_info
-     * references a buffer of type #VAEncMacroblockParameterBufferH264
-     * (\c VAEncMacroblockParameterBufferType). Otherwise, buffer id
-     * is set to \c VA_INVALID_ID and per-MB configuration is derived
-     * from this slice parameter.
-     *
-     * The \c macroblock_info buffer must hold \ref num_macroblocks
-     * elements.
-     */
-    VABufferID      macroblock_info;
-    /** \brief Slice type.
-     *  Range: 0..2, 5..7, i.e. no switching slices.
-     */
-    unsigned char   slice_type;
-    /** \brief Same as the H.264 bitstream syntax element. */
-    unsigned char   pic_parameter_set_id;
-    /** \brief Same as the H.264 bitstream syntax element. */
-    unsigned short  idr_pic_id;
-
-    /** @name If pic_order_cnt_type == 0 */
-    /**@{*/
-    /** \brief The picture order count modulo MaxPicOrderCntLsb. */
-    unsigned short  pic_order_cnt_lsb;
-    /** \brief Valid if \c pic_order_present_flag and this is a bottom field. */
-    int             delta_pic_order_cnt_bottom;
-    /**@}*/
-    /** @name If pic_order_cnt_type == 1 && !delta_pic_order_always_zero_flag */
-    /**@{*/
-    /** \brief [0]: top, [1]: bottom. */
-    int             delta_pic_order_cnt[2];
-    /**@}*/
-
-    /** @name If slice_type == B */
-    /**@{*/
-    unsigned char   direct_spatial_mv_pred_flag;
-    /**@}*/
-
-    /** @name If slice_type == P */
-    /**@{*/
-    /** \brief Specifies if
-     * \ref _VAEncPictureParameterBufferH264::num_ref_idx_l0_active_minus1 or
-     * \ref _VAEncPictureParameterBufferH264::num_ref_idx_l1_active_minus1 are
-     * overriden by the values for this slice.
-     */
-    unsigned char   num_ref_idx_active_override_flag;
-    /** \brief Maximum reference index for reference picture list 0.
-     *  Range: 0 to 31, inclusive.
-     */
-    unsigned char   num_ref_idx_l0_active_minus1;
-    /** \brief Maximum reference index for reference picture list 1.
-     *  Range: 0 to 31, inclusive.
-     */
-    unsigned char   num_ref_idx_l1_active_minus1;
-    /** \brief Reference picture list 0 (for P slices). */
-    VAPictureH264   RefPicList0[32];
-    /** \brief Reference picture list 1 (for B slices). */
-    VAPictureH264   RefPicList1[32];
-    /**@}*/
-
-    /** @name pred_weight_table() */
-    /**@{*/
-    /** \brief Same as the H.264 bitstream syntax element. */
-    unsigned char   luma_log2_weight_denom;
-    /** \brief Same as the H.264 bitstream syntax element. */
-    unsigned char   chroma_log2_weight_denom;
-    /** \brief Same as the H.264 bitstream syntax element. */
-    unsigned char   luma_weight_l0_flag;
-    /** \brief Same as the H.264 bitstream syntax element. */
-    signed short    luma_weight_l0[32];
-    /** \brief Same as the H.264 bitstream syntax element. */
-    signed short    luma_offset_l0[32];
-    /** \brief Same as the H.264 bitstream syntax element. */
-    unsigned char   chroma_weight_l0_flag;
-    /** \brief Same as the H.264 bitstream syntax element. */
-    signed short    chroma_weight_l0[32][2];
-    /** \brief Same as the H.264 bitstream syntax element. */
-    signed short    chroma_offset_l0[32][2];
-    /** \brief Same as the H.264 bitstream syntax element. */
-    unsigned char   luma_weight_l1_flag;
-    /** \brief Same as the H.264 bitstream syntax element. */
-    signed short    luma_weight_l1[32];
-    /** \brief Same as the H.264 bitstream syntax element. */
-    signed short    luma_offset_l1[32];
-    /** \brief Same as the H.264 bitstream syntax element. */
-    unsigned char   chroma_weight_l1_flag;
-    /** \brief Same as the H.264 bitstream syntax element. */
-    signed short    chroma_weight_l1[32][2];
-    /** \brief Same as the H.264 bitstream syntax element. */
-    signed short    chroma_offset_l1[32][2];
-    /**@}*/
-
-    /** \brief Range: 0 to 2, inclusive. */
-    unsigned char   cabac_init_idc;
-    /** \brief Same as the H.264 bitstream syntax element. */
-    signed char     slice_qp_delta;
-    /** @name If deblocking_filter_control_present_flag */
-    /**@{*/
-    /** \brief Range: 0 to 2, inclusive. */
-    unsigned char   disable_deblocking_filter_idc;
-    /** \brief Same as the H.264 bitstream syntax element. */
-    signed char     slice_alpha_c0_offset_div2;
-    /** \brief Same as the H.264 bitstream syntax element. */
-    signed char     slice_beta_offset_div2;
-    /**@}*/
-} VAEncSliceParameterBufferH264;
-
-/**
- * @name Macroblock neighbour availability bits
- *
- * \anchor api_enc_h264_mb_pred_avail_bits
- * Definitions for macroblock neighbour availability bits used in
- * intra prediction mode (non MBAFF only).
- *
- * @{
- */
-/** \brief References macroblock in the top-left corner. */
-#define VA_MB_PRED_AVAIL_TOP_LEFT         (1 << 2)
-/** \brief References macroblock above the current macroblock. */
-#define VA_MB_PRED_AVAIL_TOP              (1 << 4)
-/** \brief References macroblock in the top-right corner. */
-#define VA_MB_PRED_AVAIL_TOP_RIGHT        (1 << 3)
-/** \brief References macroblock on the left of the current macroblock. */
-#define VA_MB_PRED_AVAIL_LEFT             (1 << 6)
-/**@}*/
-
-/**
- * \brief Macroblock parameter for H.264 encoding in baseline, main & high
- * profiles.
- *
- * This structure holds per-macroblock information. The buffer must be
- * allocated with as many elements (macroblocks) as necessary to fit
- * the slice to be encoded. Besides, the per-macroblock records must
- * be written in a strict raster order and with no gap. i.e. every
- * macroblock, regardless of its type, shall have an entry.
- */
-
-/**@}*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* VA_ENC_H264_H */
diff --git a/third_party/libva/va/va_enc_hevc.h b/third_party/libva/va/va_enc_hevc.h
deleted file mode 100644
index 5cd614b..0000000
--- a/third_party/libva/va/va_enc_hevc.h
+++ /dev/null
@@ -1,701 +0,0 @@
-/*
- * Copyright (c) 2007-2014 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * \file va_enc_hevc.h
- * \brief The HEVC encoding API
- *
- * This file contains the \ref api_enc_hevc "HEVC encoding API".
- *
- */
-
-#ifndef VA_ENC_HEVC_H
-#define VA_ENC_HEVC_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <stdint.h>
-
-/**
- * \defgroup api_enc_hevc HEVC encoding API
- *
- * @{
- */
-
-/**
- * @name Picture flags
- *
- * Those flags flags are meant to signal when a picture marks the end
- * of a sequence, a stream, or even both at once.
- *
- * @{
- */
-/**
- * \brief Marks the last picture in the sequence.
- *
- * i.e. the driver appends \c end_of_seq() NAL unit to the encoded frame.
- */
-#define HEVC_LAST_PICTURE_EOSEQ     0x01
-/**
- * \brief Marks the last picture in the stream.
- *
- * i.e. the driver appends \c end_of_stream() NAL unit to the encoded frame.
- */
-#define HEVC_LAST_PICTURE_EOSTREAM  0x02
-/**@}*/
-
-/**
- * \brief Packed header types specific to HEVC encoding.
- *
- * Types of packed headers generally used for HEVC encoding. Each
- * associated packed header data buffer shall contain the start code
- * prefix 0x000001 followed by the complete NAL unit, thus also
- * including the \c nal_unit_type.
- *
- * Note: the start code prefix can contain an arbitrary number of leading
- * zeros. The driver will skip them for emulation prevention bytes insertion,
- * if necessary.
- */
-typedef enum {
-    /**
-     * \brief Packed Video Parameter Set (VPS).
-     *
-     * The corresponding packed header data buffer shall contain the
-     * complete video_parameter_set_rbsp() syntax element.
-     *
-     * Note: packed \c nal_unit_type shall be equal to 32.
-     */
-    VAEncPackedHeaderHEVC_VPS   = VAEncPackedHeaderSequence,
-    /**
-     * \brief Packed Sequence Parameter Set (SPS).
-     *
-     * The corresponding packed header data buffer shall contain the
-     * complete seq_parameter_set_rbsp() syntax element.
-     *
-     * Note: packed \c nal_unit_type shall be equal to 33.
-     */
-    VAEncPackedHeaderHEVC_SPS   = VAEncPackedHeaderSequence,
-    /**
-     * \brief Packed Picture Parameter Set (PPS).
-     *
-     * The corresponding packed header data buffer shall contain the
-     * complete pic_parameter_set_rbsp() syntax element.
-     *
-     * Note: packed \c nal_unit_type shall be equal to 34.
-     */
-    VAEncPackedHeaderHEVC_PPS   = VAEncPackedHeaderPicture,
-    /**
-     * \brief Packed slice header.
-     *
-     * The corresponding packed header data buffer shall contain the
-     * \c slice_header() syntax element only, along with any start
-     * code prefix and NAL unit type preceeding it. i.e. this means
-     * that the buffer does not contain any of the \c slice_data() or
-     * the \c rbsp_slice_trailing_bits().
-     *
-     * Note: packed \c nal_unit_type shall be equal to 0 to 9 (non-IRAP
-     * picture), or 16 to 21 (IRAP picture).
-     */
-    VAEncPackedHeaderHEVC_Slice = VAEncPackedHeaderSlice,
-    /**
-     * \brief Packed Supplemental Enhancement Information (SEI).
-     *
-     * The corresponding packed header data buffer shall contain the
-     * complete sei_rbsp() syntax element, thus including several
-     * sei_message() elements if necessary.
-     *
-     * Note: packed \c nal_unit_type shall be equal to 39 or 40.
-     */
-    VAEncPackedHeaderHEVC_SEI   = (VAEncPackedHeaderMiscMask | 1),
-} VAEncPackedHeaderTypeHEVC;
-
-/**
- * \brief Sequence parameter for HEVC encoding in main & main 10
- * profiles.
- *
- * This structure holds information for \c seq_parameter_set_data() as
- * defined by the HEVC specification.
- *
- * If packed sequence headers mode is used, i.e. if the encoding
- * pipeline was configured with the #VA_ENC_PACKED_HEADER_SEQUENCE
- * flag, then the driver expects two more buffers to be provided to
- * the same \c vaRenderPicture() as this buffer:
- * - a #VAEncPackedHeaderParameterBuffer with type set to
- *   VAEncPackedHeaderType::VAEncPackedHeaderSequence ;
- * - a #VAEncPackedHeaderDataBuffer which holds the actual packed
- *   header data.
- *
- * If \c seq_scaling_matrix_present_flag is set to \c 1, then a
- * #VAQMatrixBufferHEVC buffer shall also be provided within the same
- * \c vaRenderPicture() call as this sequence parameter buffer.
- */
-typedef struct _VAEncSequenceParameterBufferHEVC {
-    /** \brief Same as the HEVC bitstream syntax element.
-     *  value range [1..2].
-     */
-    uint8_t     general_profile_idc;
-    /** \brief Same as the HEVC bitstream syntax element.
-     *  general_level_idc shall be set equal to a value of 30 times the level
-     *  numbers allowed [1, 2, 2.1, 3, 3.1, 4, 4.1, 5, 5.1, 5.2, 6, 6.1, 6.2]
-     */
-    uint8_t     general_level_idc;
-    /** \brief Same as the HEVC bitstream syntax element.
-     *  Only value 0 is allowed for level value below 4, exclusive.
-     */
-    uint8_t     general_tier_flag;
-    /** \brief Period between I frames. */
-    uint32_t    intra_period;
-    /** \brief Period between IDR frames. */
-    uint32_t    intra_idr_period;
-    /** \brief Period between I/P frames. */
-    uint32_t    ip_period;
-    /**
-     * \brief Initial bitrate set for this sequence in CBR or VBR modes.
-     *
-     * This field represents the initial bitrate value for this
-     * sequence if CBR or VBR mode is used, i.e. if the encoder
-     * pipeline was created with a #VAConfigAttribRateControl
-     * attribute set to either \ref VA_RC_CBR or \ref VA_RC_VBR.
-     *
-     * The bitrate can be modified later on through
-     * #VAEncMiscParameterRateControl buffers.
-     */
-    uint32_t    bits_per_second;
-    /** \brief Picture width in pixel samples.
-     *  Its value must be multiple of min CU size.
-     */
-    uint16_t    pic_width_in_luma_samples;
-    /** \brief Picture height in pixel samples.
-     *  Its value must be multiple of min CU size.
-     */
-    uint16_t    pic_height_in_luma_samples;
-
-    union {
-        struct {
-            /** \brief Same as the HEVC bitstream syntax element. */
-            uint32_t    chroma_format_idc                              : 2;
-            /** \brief Same as the HEVC bitstream syntax element. */
-            uint32_t    separate_colour_plane_flag                     : 1;
-            /** \brief Same as the HEVC bitstream syntax element. */
-            uint32_t    bit_depth_luma_minus8                          : 3;
-            /** \brief Same as the HEVC bitstream syntax element. */
-            uint32_t    bit_depth_chroma_minus8                        : 3;
-            /** \brief Same as the HEVC bitstream syntax element. */
-            uint32_t    scaling_list_enabled_flag                      : 1;
-            /** \brief Same as the HEVC bitstream syntax element. */
-            uint32_t    strong_intra_smoothing_enabled_flag            : 1;
-            /** \brief Same as the HEVC bitstream syntax element. */
-            uint32_t    amp_enabled_flag                               : 1;
-            /** \brief Same as the HEVC bitstream syntax element. */
-            uint32_t    sample_adaptive_offset_enabled_flag            : 1;
-            /** \brief Same as the HEVC bitstream syntax element. */
-            uint32_t    pcm_enabled_flag                               : 1;
-            /** \brief Same as the HEVC bitstream syntax element. */
-            uint32_t    pcm_loop_filter_disabled_flag                  : 1;
-            /** \brief Same as the HEVC bitstream syntax element. */
-            uint32_t    sps_temporal_mvp_enabled_flag                  : 1;
-
-            uint32_t    reserved_bits                                  : 16;
-        } bits;
-        uint32_t value;
-    } seq_fields;
-
-    /** \brief Same as the HEVC bitstream syntax element.
-     *  value range [0..3]
-     */
-    uint8_t     log2_min_luma_coding_block_size_minus3;
-
-    /** \brief Same as the HEVC bitstream syntax element.
-     */
-    uint8_t     log2_diff_max_min_luma_coding_block_size;
-
-    /** \brief Same as the HEVC bitstream syntax element.
-     *  value range [0..3]
-     */
-    uint8_t     log2_min_transform_block_size_minus2;
-
-    /** \brief Same as the HEVC bitstream syntax element.
-     */
-    uint8_t     log2_diff_max_min_transform_block_size;
-
-    /** \brief Same as the HEVC bitstream syntax element.
-     *  value range [2]
-     */
-    uint8_t     max_transform_hierarchy_depth_inter;
-
-    /** \brief Same as the HEVC bitstream syntax element.
-     *  value range [2]
-     */
-    uint8_t     max_transform_hierarchy_depth_intra;
-
-    /** \brief Same as the HEVC bitstream syntax element. */
-    uint32_t    pcm_sample_bit_depth_luma_minus1;
-
-    /** \brief Same as the HEVC bitstream syntax element. */
-    uint32_t    pcm_sample_bit_depth_chroma_minus1;
-
-    /** \brief Same as the HEVC bitstream syntax element. */
-    uint32_t    log2_min_pcm_luma_coding_block_size_minus3;
-
-    /** \brief Derived from the HEVC bitstream syntax element.
-    *  log2_min_pcm_luma_coding_block_size_minus3 +
-    *  log2_diff_max_min_pcm_luma_coding_block_size
-    */
-    uint32_t    log2_max_pcm_luma_coding_block_size_minus3;
-
-    /** @name VUI parameters (optional) */
-    /**@{*/
-    /** \brief Same as the HEVC bitstream syntax element. */
-    uint8_t     vui_parameters_present_flag;
-    union {
-        struct {
-            /** \brief Same as the HEVC bitstream syntax element. */
-            uint32_t    aspect_ratio_info_present_flag                 : 1;
-            /** \brief Same as the HEVC bitstream syntax element. */
-            uint32_t    neutral_chroma_indication_flag                 : 1;
-            /** \brief Same as the HEVC bitstream syntax element. */
-            uint32_t    field_seq_flag                                 : 1;
-            /** \brief Same as the HEVC bitstream syntax element. */
-            uint32_t    vui_timing_info_present_flag                   : 1;
-            /** \brief Same as the HEVC bitstream syntax element. */
-            uint32_t    bitstream_restriction_flag                     : 1;
-            /** \brief Same as the HEVC bitstream syntax element. */
-            uint32_t    tiles_fixed_structure_flag                     : 1;
-            /** \brief Same as the HEVC bitstream syntax element. */
-            uint32_t    motion_vectors_over_pic_boundaries_flag        : 1;
-            /** \brief Same as the HEVC bitstream syntax element. */
-            uint32_t    restricted_ref_pic_lists_flag                  : 1;
-            /** \brief Range: 0 to 16, inclusive. */
-            uint32_t    log2_max_mv_length_horizontal                  : 5;
-            /** \brief Range: 0 to 16, inclusive. */
-            uint32_t    log2_max_mv_length_vertical                    : 5;
-        } bits;
-        uint32_t value;
-    } vui_fields;
-    /** \brief Same as the HEVC bitstream syntax element. */
-    uint8_t     aspect_ratio_idc;
-    /** \brief Same as the HEVC bitstream syntax element. */
-    uint32_t    sar_width;
-    /** \brief Same as the HEVC bitstream syntax element. */
-    uint32_t    sar_height;
-    /** \brief Same as the HEVC bitstream syntax element. */
-    uint32_t    vui_num_units_in_tick;
-    /** \brief Same as the HEVC bitstream syntax element. */
-    uint32_t    vui_time_scale;
-    /** \brief Same as the HEVC bitstream syntax element. */
-    uint16_t    min_spatial_segmentation_idc;
-    /** \brief Same as the HEVC bitstream syntax element. */
-    uint8_t     max_bytes_per_pic_denom;
-    /** \brief Same as the HEVC bitstream syntax element. */
-    uint8_t     max_bits_per_min_cu_denom;
-    /**@}*/
-} VAEncSequenceParameterBufferHEVC;
-
-/****************************
- * HEVC data structures
- ****************************/
-/**
- * \brief Picture parameter for HEVC encoding in main & main 10
- * profiles.
- *
- * This structure holds information for \c pic_parameter_set_rbsp() as
- * defined by the HEVC specification.
- *
- * If packed picture headers mode is used, i.e. if the encoding
- * pipeline was configured with the #VA_ENC_PACKED_HEADER_PICTURE
- * flag, then the driver expects two more buffers to be provided to
- * the same \c vaRenderPicture() as this buffer:
- * - a #VAEncPackedHeaderParameterBuffer with type set to
- *   VAEncPackedHeaderType::VAEncPackedHeaderPicture ;
- * - a #VAEncPackedHeaderDataBuffer which holds the actual packed
- *   header data.
- *
- * If \c pic_scaling_matrix_present_flag is set to \c 1, then a
- * #VAQMatrixBufferHEVC buffer shall also be provided within the same
- * \c vaRenderPicture() call as this picture parameter buffer.
- */
-typedef struct _VAEncPictureParameterBufferHEVC {
-    /**
-     * \brief Information about the picture to be encoded.
-     *
-     * See #VAPictureHEVC for further description of each field.
-     * Note that decoded_curr_pic.picture_id represents the reconstructed
-     * (decoded) picture. User provides a scratch VA surface ID here.
-     * Long term reference and RPS related fields should be set to 0
-     * and ignored.
-     */
-    VAPictureHEVC   decoded_curr_pic;
-    /**
-     * \brief Decoded Picture Buffer (DPB).
-     *
-     * This array represents the list of reconstructed (decoded)
-     * frames used as reference. It is important to keep track of
-     * reconstructed frames so that they can be used later on as
-     * reference for P or B-frames encoding.
-     */
-    VAPictureHEVC   reference_frames[15];
-    /**
-     * \brief Output encoded bitstream.
-     *
-     * \ref coded_buf has type #VAEncCodedBufferType. It should be
-     * large enough to hold the compressed NAL slice and possibly VPS, SPS
-     * and PPS NAL units, and other NAL units such as SEI.
-     */
-    VABufferID      coded_buf;
-
-    /** \brief collocated reference picture buffer index of ReferenceFrames[].
-     * Please note it is different from HEVC syntac element collocated_ref_idx.
-     * When  the HEVC syntax element slice_temporal_mvp_enable_flag takes value 0,
-     * collocated_ref_pic_index should take value 0xFF. .
-     * Range: [0..14, 0xFF]
-     */
-    uint8_t         collocated_ref_pic_index;
-
-    /**
-     * \brief OR'd flags describing whether the picture is the last one or not.
-     *
-     * This fields holds 0 if the picture to be encoded is not the last
-     * one in the stream or sequence. Otherwise, it is a combination of
-     * \ref HEVC_LAST_PICTURE_EOSEQ or \ref HEVC_LAST_PICTURE_EOSTREAM.
-     */
-    uint8_t         last_picture;
-
-    /** \brief \c init_qp_minus26 + 26. */
-    uint8_t         pic_init_qp;
-
-    /** \brief Corresponds to HEVC syntax element of the same name. */
-    uint8_t         diff_cu_qp_delta_depth;
-
-    /** \brief Corresponds to HEVC syntax element of the same name. */
-    int8_t          pps_cb_qp_offset;
-
-    /** \brief Corresponds to HEVC syntax element of the same name. */
-    int8_t          pps_cr_qp_offset;
-
-    /** \brief Corresponds to HEVC syntax element of the same name. */
-    uint8_t         num_tile_columns_minus1;
-
-    /** \brief Corresponds to HEVC syntax element of the same name. */
-    uint8_t         num_tile_rows_minus1;
-
-    /** \brief Corresponds to HEVC syntax element of the same name. */
-    uint8_t         column_width_minus1[19];
-
-    /** \brief Corresponds to HEVC syntax element of the same name. */
-    uint8_t         row_height_minus1[21];
-
-    /** \brief Corresponds to HEVC syntax element of the same name. */
-    uint8_t         log2_parallel_merge_level_minus2;
-
-    /** \brief Application may set the CTU bit size limit based on
-     *  spec requirement (A.3.2), or other value for special purpose.
-     *  If the value is set 0, no bit size limit is checked.
-     */
-    uint8_t         ctu_max_bitsize_allowed;
-
-    /** \brief Maximum reference index for reference picture list 0.
-     *   value range: [0..14].
-     */
-    uint8_t         num_ref_idx_l0_default_active_minus1;
-
-    /** \brief Maximum reference index for reference picture list 1.
-     *  value range: [0..14].
-     */
-    uint8_t         num_ref_idx_l1_default_active_minus1;
-
-    /** \brief PPS header
-     *  Used by GPU to generate new slice headers in slice size control.
-     *  value range: [0..63].
-     */
-    uint8_t         slice_pic_parameter_set_id;
-
-    /** \brief NAL unit type
-     *  Used by GPU to generate new slice headers in slice size control.
-     *  value range: [0..63].
-     */
-    uint8_t         nal_unit_type;
-
-    union {
-        struct {
-            /** \brief Is picture an IDR picture? */
-            uint32_t    idr_pic_flag                                   : 1;
-            /** \brief Picture type.
-             *  I  - 1;
-             *  P  - 2;
-             *  B  - 3;
-             *  B1 - 4;
-             *  B2 - 5;
-             * B1 and B2 are frame types for hierachical B, explanation
-             * can refer to num_b_in_gop[].
-             */
-            uint32_t    coding_type                                    : 3;
-            /** \brief Is picture a reference picture? */
-            uint32_t    reference_pic_flag                             : 1;
-            /** \brief Corresponds to HEVC syntax element of the same name. */
-            uint32_t    dependent_slice_segments_enabled_flag          : 1;
-            /** \brief Corresponds to HEVC syntax element of the same name. */
-            uint32_t    sign_data_hiding_enabled_flag                  : 1;
-            /** \brief Corresponds to HEVC syntax element of the same name. */
-            uint32_t    constrained_intra_pred_flag                    : 1;
-            /** \brief Corresponds to HEVC syntax element of the same name. */
-            uint32_t    transform_skip_enabled_flag                    : 1;
-            /** \brief Corresponds to HEVC syntax element of the same name. */
-            uint32_t    cu_qp_delta_enabled_flag	               : 1;
-            /** \brief Corresponds to HEVC syntax element of the same name. */
-            uint32_t    weighted_pred_flag                             : 1;
-            /** \brief Corresponds to HEVC syntax element of the same name. */
-            uint32_t    weighted_bipred_flag                           : 1;
-            /** \brief Corresponds to HEVC syntax element of the same name. */
-            uint32_t    transquant_bypass_enabled_flag                 : 1;
-            /** \brief Corresponds to HEVC syntax element of the same name. */
-            uint32_t    tiles_enabled_flag                             : 1;
-            /** \brief Corresponds to HEVC syntax element of the same name. */
-            uint32_t    entropy_coding_sync_enabled_flag               : 1;
-            /** \brief Corresponds to HEVC syntax element of the same name. */
-            uint32_t    loop_filter_across_tiles_enabled_flag          : 1;
-            /** \brief Corresponds to HEVC syntax element of the same name. */
-            uint32_t    pps_loop_filter_across_slices_enabled_flag     : 1;
-            /** \brief A combination of HEVC syntax element of
-             *  sps_scaling_list_data_present_flag and
-             *  pps_scaling_list_data_present_flag
-             *  when scaling_list_enable_flag is 0, it must be 0.
-             */
-            uint32_t    scaling_list_data_present_flag                 : 1;
-            /** \brief indicate the current picture contains significant
-             *  screen contents (text, characters, etc.) or animated image.
-             *  GPU may want to treat them differently from normal video.
-             *  For example, encoder may choose a small transform unit size
-             *  and may use transform skip mode.
-             */
-            uint32_t    screen_content_flag                            : 1;
-            /**
-             *  When either weighted_pred_flag or weighted_bipred_flag is
-             *  turned on, the flag enable_gpu_weighted_prediction requests
-             *  GPU to determine weighted prediction factors. In this case,
-             *  the following parameters in slice control data structure
-             *  shall be ignored:
-             *  luma_log2_weight_denom, delta_chroma_log2_weight_denom,
-             *  luma_offset_l0[15], luma_offset_l1[15],
-             *  delta_luma_weight_l0[15], delta_luma_weight_l1[15],
-             *  chroma_offset_l0[15][2], chroma_offset_l1[15][2],
-             *  and delta_chroma_weight_l0[15][2], delta_chroma_weight_l1[15][2].
-             */
-            uint32_t    enable_gpu_weighted_prediction                 : 1;
-            /** \brief HEVC syntax element in slice segment header
-             *  GPU uses it to generate new slice headers in slice size control.
-             */
-            uint32_t    no_output_of_prior_pics_flag                   : 1;
-            uint32_t    reserved                                       : 11;
-        } bits;
-        uint32_t        value;
-    } pic_fields;
-} VAEncPictureParameterBufferHEVC;
-
-/**
- * \brief Slice parameter for HEVC encoding in main & main 10 profiles.
- *
- * This structure holds information for \c
- * slice_segment_layer_rbsp() as defined by the HEVC
- * specification.
- *
- * If packed slice headers mode is used, i.e. if the encoding
- * pipeline was configured with the #VA_ENC_PACKED_HEADER_SLICE
- * flag, then the driver expects two more buffers to be provided to
- * the same \c vaRenderPicture() as this buffer:
- * - a #VAEncPackedHeaderParameterBuffer with type set to
- *   VAEncPackedHeaderType::VAEncPackedHeaderSlice ;
- * - a #VAEncPackedHeaderDataBuffer which holds the actual packed
- *   header data.
- *
- */
-typedef struct _VAEncSliceParameterBufferHEVC {
-    /** \brief Starting CTU address for this slice. */
-    uint32_t        slice_segment_address;
-    /** \brief Number of CTUs in this slice. */
-    uint32_t        num_ctu_in_slice;
-
-    /** \brief Slice type.
-     *  Corresponds to HEVC syntax element of the same name.
-     */
-    uint8_t         slice_type;
-    /** \brief Same as the HEVC bitstream syntax element. */
-    uint8_t         slice_pic_parameter_set_id;
-
-    /** \brief Maximum reference index for reference picture list 0.
-     *  Range: 0 to 14, inclusive.
-     */
-    uint8_t         num_ref_idx_l0_active_minus1;
-    /** \brief Maximum reference index for reference picture list 1.
-     *  Range: 0 to 14, inclusive.
-     */
-    uint8_t         num_ref_idx_l1_active_minus1;
-    /** \brief Reference picture list 0 (for P slices). */
-    VAPictureHEVC   ref_pic_list0[15];
-    /** \brief Reference picture list 1 (for B slices). */
-    VAPictureHEVC   ref_pic_list1[15];
-    /**@}*/
-
-    /** @name pred_weight_table() */
-    /**@{*/
-    /** \brief Same as the HEVC bitstream syntax element. */
-    uint8_t         luma_log2_weight_denom;
-    /** \brief Same as the HEVC bitstream syntax element. */
-    int8_t          delta_chroma_log2_weight_denom;
-    /** \brief Same as the HEVC bitstream syntax element. */
-    int8_t          delta_luma_weight_l0[15];
-    /** \brief Same as the HEVC bitstream syntax element. */
-    int8_t          luma_offset_l0[15];
-    /** \brief Same as the HEVC bitstream syntax element. */
-    int8_t          delta_chroma_weight_l0[15][2];
-    /** \brief Same as the HEVC spec variable ChromaOffsetL0[]. */
-    int8_t          chroma_offset_l0[15][2];
-    /** \brief Same as the HEVC bitstream syntax element. */
-    int8_t          delta_luma_weight_l1[15];
-    /** \brief Same as the HEVC bitstream syntax element. */
-    int8_t          luma_offset_l1[15];
-    /** \brief Same as the HEVC bitstream syntax element. */
-    int8_t          delta_chroma_weight_l1[15][2];
-    /** \brief Same as the HEVC spec variable ChromaOffsetL1[]. */
-    int8_t          chroma_offset_l1[15][2];
-    /**@}*/
-
-    /** \brief Corresponds to HEVC spec variable MaxNumMergeCand.
-     *  Range: [1..5].
-     */
-    uint8_t         max_num_merge_cand;
-
-    /** \brief Same as the HEVC bitstream syntax element. */
-    int8_t          slice_qp_delta;
-
-    /** \brief Same as the HEVC bitstream syntax element. */
-    int8_t          slice_cb_qp_offset;
-
-    /** \brief Same as the HEVC bitstream syntax element. */
-    int8_t          slice_cr_qp_offset;
-
-    /** \brief Same as the HEVC bitstream syntax element. */
-    int8_t          slice_beta_offset_div2;
-
-    /** \brief Same as the HEVC bitstream syntax element. */
-    int8_t          slice_tc_offset_div2;
-
-    union {
-        struct {
-            /** \brief Indicates if current slice is the last one in picture */
-            uint32_t    last_slice_of_pic_flag                         : 1;
-            /** \brief Corresponds to HEVC syntax element of the same name */
-            uint32_t    dependent_slice_segment_flag                   : 1;
-            /** \brief Corresponds to HEVC syntax element of the same name */
-            uint32_t    colour_plane_id                                : 2;
-            /** \brief Corresponds to HEVC syntax element of the same name. */
-            uint32_t    slice_temporal_mvp_enabled_flag                : 1;
-            /** \brief Corresponds to HEVC syntax element of the same name. */
-            uint32_t    slice_sao_luma_flag                            : 1;
-            /** \brief Corresponds to HEVC syntax element of the same name. */
-            uint32_t    slice_sao_chroma_flag                          : 1;
-            /** \brief Corresponds to HEVC syntax element of the same name.
-             *  if this flag is set to 0, num_ref_idx_l0_active_minus1 should be
-             *  equal to num_ref_idx_l0_default_active_minus1
-             *  as well as for that for l1.
-             */
-            uint32_t    num_ref_idx_active_override_flag               : 1;
-            /** \brief Corresponds to HEVC syntax element of the same name. */
-            uint32_t    mvd_l1_zero_flag                               : 1;
-            /** \brief Corresponds to HEVC syntax element of the same name. */
-            uint32_t    cabac_init_flag        	                    : 1;
-            /** \brief Corresponds to HEVC syntax element of the same name. */
-            uint32_t    slice_deblocking_filter_disabled_flag          : 2;
-            /** \brief Corresponds to HEVC syntax element of the same name. */
-            uint32_t    slice_loop_filter_across_slices_enabled_flag   : 1;
-            /** \brief Corresponds to HEVC syntax element of the same name. */
-            uint32_t    collocated_from_l0_flag                        : 1;
-        } bits;
-        uint32_t        value;
-    } slice_fields;
-    /**@}*/
-} VAEncSliceParameterBufferHEVC;
-
-/**
- * \brief HEVC Quantization Matrix Buffer Structure
- *
- * This structure is sent once per frame,
- * and only when scaling_list_enabled_flag = 1 and scaling_list_data_present_flag = 1.
- * Only when scaling_list_data_present_flag = 1, app still
- * needs to send in this structure. When scaling_list_enabled_flag = 1 and
- * scaling_list_data_present_flag = 0, driver is responsible to generate
- * the default scaling list values.
- *
- * Matrix entries are in raster scan order which follows HEVC spec.
- */
-typedef struct _VAQMatrixBufferHEVC
-{
-    /**
-     * \brief scaling lists,
-     * corresponds to same HEVC spec syntax element
-     * ScalingList[ i ][ MatrixID ][ j ].
-     *
-     * \brief 4x4 scaling,
-     */
-    uint8_t             scaling_lists_4x4[3][2][16];
-    /**
-     * \brief 8x8 scaling,
-     */
-    uint8_t             scaling_lists_8x8[3][2][64];
-    /**
-     * \brief 16x16 scaling,
-     * correspongs i = 2, MatrixID is in the range of 0 to 5,
-     * inclusive. And j is in the range of 0 to 63, inclusive.
-     */
-    uint8_t             scaling_lists_16x16[3][2][64];
-    /**
-     * \brief 32x32 scaling,
-     * correspongs i = 3, MatrixID is in the range of 0 to 1,
-     * inclusive. And j is in the range of 0 to 63, inclusive.
-     */
-    uint8_t             scaling_lists_32x32[2][64];
-    /**
-     * \brief DC values of the 16x16 scaling lists,
-     * corresponds to HEVC spec syntax
-     * scaling_list_dc_coef_minus8[ sizeID - 2 ][ matrixID ] + 8
-     * with sizeID = 2 and matrixID in the range of 0 to 5, inclusive.
-     */
-    uint8_t             scaling_list_dc_16x16[3][2];
-    /**
-     * \brief DC values of the 32x32 scaling lists,
-     * corresponds to HEVC spec syntax
-     * scaling_list_dc_coef_minus8[ sizeID - 2 ][ matrixID ] + 8
-     * with sizeID = 3 and matrixID in the range of 0 to 1, inclusive.
-     */
-    uint8_t             scaling_list_dc_32x32[2];
-} VAQMatrixBufferHEVC;
-
-/**@}*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* VA_ENC_HEVC_H */
diff --git a/third_party/libva/va/va_enc_jpeg.h b/third_party/libva/va/va_enc_jpeg.h
deleted file mode 100644
index 3aba7ad..0000000
--- a/third_party/libva/va/va_enc_jpeg.h
+++ /dev/null
@@ -1,156 +0,0 @@
-/*
- * Copyright (c) 2007-2013 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * \file va_enc_jpeg.h
- * \brief JPEG encoding API
- *
- * This file contains the \ref api_enc_jpeg "JPEG encoding API".
- */
-
-#ifndef VA_ENC_JPEG_H
-#define VA_ENC_JPEG_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * \defgroup api_enc_jpeg JPEG encoding API
- *
- * @{
- */
-
-/**
- * \brief JPEG Encoding Picture Parameter Buffer Structure
- *
- * This structure conveys picture level parameters.
- *
- */
-typedef struct  _VAEncPictureParameterBufferJPEG
-{
-    /** \brief holds reconstructed picture. */
-    VASurfaceID reconstructed_picture;
-    /** \brief picture width. */
-    unsigned short picture_width;
-    /** \brief picture height. */
-    unsigned short picture_height;
-    /** \brief holds coded data. */
-    VABufferID coded_buf;
-
-    /** 
-     * \brief pic_flags
-     *
-     */
-    union {
-        struct {
-            /** 
-             * \brief profile: 
-             * 0 - Baseline, 1 - Extended, 2 - Lossless, 3 - Hierarchical
-             */ 
-            unsigned int profile     : 2;
-            /** 
-             * \brief progressive: 
-             * 0 - sequential, 1 - extended, 2 - progressive
-             */ 
-            unsigned int progressive : 1;
-            /** 
-             * \brief huffman: 
-             * 0 - arithmetic, 1 - huffman
-             */ 
-            unsigned int huffman     : 1;
-            /** 
-             * \brief interleaved: 
-             * 0 - non interleaved, 1 - interleaved
-             */ 
-            unsigned int interleaved : 1;
-            /** 
-             * \brief differential: 
-             * 0 - non differential, 1 - differential
-             */ 
-            unsigned int differential   : 1;
-        } bits;
-        unsigned int value;
-    } pic_flags;
-
-    /** \brief number of bits per sample. */
-    unsigned char    sample_bit_depth;
-    /** \brief total number of scans in image. */
-    unsigned char    num_scan;
-    /** \brief number of image components in frame. */
-    unsigned short   num_components;
-    /** \brief Component identifier (Ci). */
-    unsigned char    component_id[4];
-    /** \brief Quantization table selector (Tqi). */
-    unsigned char    quantiser_table_selector[4];
-    /** \brief number from 1 to 100 that specifies quality of image. */
-    unsigned char    quality;
-
-} VAEncPictureParameterBufferJPEG;
-
-
-/**
- * \brief Slice parameter for JPEG encoding. 
- *
- * This structure conveys slice (scan) level parameters.
- *
- */
-typedef struct _VAEncSliceParameterBufferJPEG {
-    /** \brief Restart interval definition (Ri). */
-    unsigned short    restart_interval;
-    /** \brief number of image components in a scan. */
-    unsigned short    num_components;
-    struct {
-        /** \brief Scan component selector (Csj). */
-        unsigned char   component_selector;
-        /** \brief DC entropy coding table selector (Tdj). */
-        unsigned char   dc_table_selector;
-        /** \brief AC entropy coding table selector (Taj). */
-        unsigned char   ac_table_selector;
-    } components[4];
-} VAEncSliceParameterBufferJPEG;
-
-/**
- * \brief Quantization table for JPEG encoding.
- *
- */
-typedef struct _VAQMatrixBufferJPEG
-{
-    /** \brief load luma quantization table. */
-    int load_lum_quantiser_matrix;
-    /** \brief load chroma quantization table. */
-    int load_chroma_quantiser_matrix;
-    /** \brief luma quantization table. */
-    unsigned char lum_quantiser_matrix[64];
-    /** \brief chroma quantization table. */
-    unsigned char chroma_quantiser_matrix[64];
-} VAQMatrixBufferJPEG;
-
-/**@}*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* VA_ENC_JPEG_H */
diff --git a/third_party/libva/va/va_enc_mpeg2.h b/third_party/libva/va/va_enc_mpeg2.h
deleted file mode 100644
index c12c8de..0000000
--- a/third_party/libva/va/va_enc_mpeg2.h
+++ /dev/null
@@ -1,287 +0,0 @@
-/*
- * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * \file va_enc_mpeg2.h
- * \brief The MPEG-2 encoding API
- *
- * This file contains the \ref api_enc_mpeg2 "MPEG-2 encoding API".
- */
-
-#ifndef _VA_ENC_MPEG2_H_
-#define _VA_ENC_MPEG2_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * \defgroup api_enc_mpeg2 MPEG-2 encoding API
- *
- * @{
- */
-
-/**
- * \brief MPEG-2 Quantization Matrix Buffer
- *
- */
-typedef VAIQMatrixBufferMPEG2 VAQMatrixBufferMPEG2;
-
-/**
- * \brief Packed header types specific to MPEG-2 encoding.
- *
- * Types of packed headers generally used for MPEG-2 encoding.
- */
-typedef enum {
-    /**
-     * \brief Packed Sequence Parameter Set (SPS).
-     *
-     */
-    VAEncPackedHeaderMPEG2_SPS = VAEncPackedHeaderSequence,
-    /**
-     * \brief Packed Picture Parameter Set (PPS).
-     *
-     */
-    VAEncPackedHeaderMPEG2_PPS = VAEncPackedHeaderPicture,
-    /**
-     * \brief Packed slice header.
-     *
-     */
-    VAEncPackedHeaderMPEG2_Slice = VAEncPackedHeaderSlice,
-} VAEncPackedHeaderTypeMPEG2;
-
-/**
- * \brief Sequence parameter for MPEG-2 encoding
- *
- * This structure holds information for \c sequence_header() and
- * sequence_extension().
- *
- * If packed sequence headers mode is used, i.e. if the encoding
- * pipeline was configured with the #VA_ENC_PACKED_HEADER_SEQUENCE
- * flag, then the driver expects two more buffers to be provided to
- * the same \c vaRenderPicture() as this buffer:
- * - a #VAEncPackedHeaderParameterBuffer with type set to
- *   VAEncPackedHeaderType::VAEncPackedHeaderSequence ;
- * - a #VAEncPackedHeaderDataBuffer which holds the actual packed
- *   header data.
- *
- */
-typedef struct _VAEncSequenceParameterBufferMPEG2 {
-    /** \brief Period between I frames. */
-    unsigned int intra_period;
-    /** \brief Period between I/P frames. */
-    unsigned int ip_period;
-    /** \brief Picture width.
-     *
-     * A 14bits unsigned inter, the lower 12bits 
-     * is horizontal_size_value, and the upper 
-     * 2bits is \c horizontal_size_extension
-     *
-     */
-    unsigned short picture_width;
-    /** \brief Picture height.
-     *
-     * A 14bits unsigned inter, the lower 12bits
-     * is vertical_size_value, and the upper 2bits is 
-     * vertical_size_size_extension
-     *
-     */
-    unsigned short picture_height;
-    /**
-     * \brief Initial bitrate set for this sequence in CBR or VBR modes.
-     *
-     * This field represents the initial bitrate value for this
-     * sequence if CBR or VBR mode is used, i.e. if the encoder
-     * pipeline was created with a #VAConfigAttribRateControl
-     * attribute set to either \ref VA_RC_CBR or \ref VA_RC_VBR.
-     *
-     * bits_per_second may be derived from bit_rate.
-     *
-     */
-    unsigned int bits_per_second;
-    /**
-     * \brief Frame rate
-     * 
-     * Derived from frame_rate_value, frame_rate_extension_n and 
-     * frame_rate_extension_d
-     *
-     */
-    float frame_rate;
-    /** \brief Same as the element in sequence_header() */
-    unsigned short aspect_ratio_information;
-    /** \brief Define the size of VBV */
-    unsigned int vbv_buffer_size;
-
-    union {
-        struct {
-            /** \brief Same as the element in Sequence extension() */
-            unsigned int profile_and_level_indication   : 8;
-            /** \brief Same as the element in Sequence extension() */
-            unsigned int progressive_sequence           : 1;
-            /** \brief Same as the element in Sequence extension() */
-            unsigned int chroma_format                  : 2;
-            /** \brief Same as the element in Sequence extension() */
-            unsigned int low_delay                      : 1;
-            /** \brief Same as the element in Sequence extension() */
-            unsigned int frame_rate_extension_n         : 2;
-            /** \brief Same as the element in Sequence extension() */
-            unsigned int frame_rate_extension_d         : 5;
-        } bits;
-        unsigned int value;
-    } sequence_extension;
-
-    /** \brief Flag to indicate the following GOP header are being updated */
-    unsigned int new_gop_header;
-
-    union {
-        struct {
-            /** \brief Time code */
-            unsigned int time_code                      : 25;
-            /** \brief Same as the element in GOP header */
-            unsigned int closed_gop                     : 1;
-            /** \brief SAme as the element in GOP header */
-            unsigned int broken_link                    : 1;
-        } bits;
-        unsigned int value;
-    } gop_header;
-} VAEncSequenceParameterBufferMPEG2;
-
-/**
- * \brief Picture parameter for MPEG-2 encoding
- *
- * This structure holds information for picture_header() and 
- * picture_coding_extension()
- *
- * If packed picture headers mode is used, i.e. if the encoding
- * pipeline was configured with the #VA_ENC_PACKED_HEADER_PICTURE
- * flag, then the driver expects two more buffers to be provided to
- * the same \c vaRenderPicture() as this buffer:
- * - a #VAEncPackedHeaderParameterBuffer with type set to
- *   VAEncPackedHeaderType::VAEncPackedHeaderPicture ;
- * - a #VAEncPackedHeaderDataBuffer which holds the actual packed
- *   header data.
- *
- */
-typedef struct _VAEncPictureParameterBufferMPEG2 {
-    /** \brief Forward reference picture */
-    VASurfaceID forward_reference_picture;
-    /** \brief Backward reference picture */
-    VASurfaceID backward_reference_picture;
-    /** \brief Reconstructed(decoded) picture */
-    VASurfaceID reconstructed_picture;
-    /**
-     * \brief Output encoded bitstream.
-     *
-     * \ref coded_buf has type #VAEncCodedBufferType. It should be
-     * large enough to hold the compressed NAL slice and possibly SPS
-     * and PPS NAL units.
-     */
-    VABufferID coded_buf;
-    /**
-     * \brief Flag to indicate the picture is the last one or not.
-     *
-     * This fields holds 0 if the picture to be encoded is not 
-     * the last one in the stream. Otherwise, it 
-     * is \ref MPEG2_LAST_PICTURE_EOSTREAM.
-     */
-    unsigned char last_picture;
-    /** \brief Picture type */
-    VAEncPictureType picture_type;
-    /** \brief Same as the element in picture_header() */
-    unsigned int temporal_reference;
-    /** \brief Same as the element in picture_header() */
-    unsigned int vbv_delay;
-    /** \brief Same as the element in Picture coding extension */
-    unsigned char f_code[2][2];
-    union {
-        struct {
-            /** \brief Same as the element in Picture coding extension */
-            unsigned int intra_dc_precision             : 2; 
-            /** \brief Same as the element in Picture coding extension */
-            unsigned int picture_structure              : 2; 
-            /** \brief Same as the element in Picture coding extension */
-            unsigned int top_field_first                : 1; 
-            /** \brief Same as the element in Picture coding extension */
-            unsigned int frame_pred_frame_dct           : 1; 
-            /** \brief Same as the element in Picture coding extension */
-            unsigned int concealment_motion_vectors     : 1;
-            /** \brief Same as the element in Picture coding extension */
-            unsigned int q_scale_type                   : 1;
-            /** \brief Same as the element in Picture coding extension */
-            unsigned int intra_vlc_format               : 1;
-            /** \brief Same as the element in Picture coding extension */
-            unsigned int alternate_scan                 : 1;
-            /** \brief Same as the element in Picture coding extension */
-            unsigned int repeat_first_field             : 1;
-            /** \brief Same as the element in Picture coding extension */
-            unsigned int progressive_frame              : 1;
-            /** \brief Same as the element in Picture coding extension */
-            unsigned int composite_display_flag         : 1;
-        } bits;
-        unsigned int value;
-    } picture_coding_extension;
-
-    /* \brief Parameters for composite display
-     *
-     * Valid only when omposite_display_flag is 1
-     */
-    union {
-        struct {
-            /** \brief Same as the element in Picture coding extension */            
-            unsigned int v_axis                         : 1;
-            /** \brief Same as the element in Picture coding extension */
-            unsigned int field_sequence                 : 3;
-            /** \brief Same as the element in Picture coding extension */
-            unsigned int sub_carrier                    : 1;
-            /** \brief Same as the element in Picture coding extension */
-            unsigned int burst_amplitude                : 7;
-            /** \brief Same as the element in Picture coding extension */
-            unsigned int sub_carrier_phase              : 8;
-        } bits;
-        unsigned int value;
-    } composite_display;
-} VAEncPictureParameterBufferMPEG2;
-
-/**
- * \brief Slice parameter for MPEG-2 encoding
- *
- */
-typedef struct _VAEncSliceParameterBufferMPEG2 {
-    /** \brief Starting MB address for this slice. */
-    unsigned int macroblock_address;
-    /** \brief Number of macroblocks in this slice. */
-    unsigned int num_macroblocks;
-    /** \brief Same as the element in slice() */
-    int quantiser_scale_code;
-    /** \brief Flag to indicate intra slice */
-    int is_intra_slice;
-} VAEncSliceParameterBufferMPEG2;
-
-/**@}*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _VA_ENC_MPEG2_H_ */
diff --git a/third_party/libva/va/va_enc_vp8.h b/third_party/libva/va/va_enc_vp8.h
deleted file mode 100644
index d294042..0000000
--- a/third_party/libva/va/va_enc_vp8.h
+++ /dev/null
@@ -1,330 +0,0 @@
-/*
- * Copyright (c) 2007-2012 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * \file va_enc_vp8.h
- * \brief VP8 encoding API
- *
- * This file contains the \ref api_enc_vp8 "VP8 encoding API".
- */
-
-#ifndef VA_ENC_VP8_H
-#define VA_ENC_VP8_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * \defgroup api_enc_vp8 VP8 encoding API
- *
- * @{
- */
-
-/**
- * \brief VP8 Encoding Sequence Parameter Buffer Structure
- *
- * This structure conveys sequence level parameters.
- *
- */
-typedef struct  _VAEncSequenceParameterBufferVP8
-{
-    /* frame width in pixels */
-    unsigned int frame_width;
-    /* frame height in pixels */
-    unsigned int frame_height;
-    /* horizontal scale */
-    unsigned int frame_width_scale;
-    /* vertical scale */
-    unsigned int frame_height_scale;
-
-    /* whether to enable error resilience features */
-    unsigned int error_resilient;
-    /* auto keyframe placement, non-zero means enable auto keyframe placement */
-    unsigned int kf_auto;
-    /* keyframe minimum interval */
-    unsigned int kf_min_dist;
-    /* keyframe maximum interval */
-    unsigned int kf_max_dist;
-
-
-    /* RC related fields. RC modes are set with VAConfigAttribRateControl */
-    /* For VP8, CBR implies HRD conformance and VBR implies no HRD conformance */
-
-    /**
-     * Initial bitrate set for this sequence in CBR or VBR modes.
-     *
-     * This field represents the initial bitrate value for this
-     * sequence if CBR or VBR mode is used, i.e. if the encoder
-     * pipeline was created with a #VAConfigAttribRateControl
-     * attribute set to either \ref VA_RC_CBR or \ref VA_RC_VBR.
-     *
-     * The bitrate can be modified later on through
-     * #VAEncMiscParameterRateControl buffers.
-     */
-    unsigned int bits_per_second;
-    /* Period between I frames. */
-    unsigned int intra_period;
-
-    /* reference and reconstructed frame buffers
-     * Used for driver auto reference management when configured through 
-     * VAConfigAttribEncAutoReference. 
-     */
-    VASurfaceID reference_frames[4];
-
-} VAEncSequenceParameterBufferVP8;
-
-
-/**
- * \brief VP8 Encoding Picture Parameter Buffer Structure
- *
- * This structure conveys picture level parameters.
- *
- */
-typedef struct  _VAEncPictureParameterBufferVP8
-{
-    /* surface to store reconstructed frame  */
-    VASurfaceID reconstructed_frame;
-
-    /* 
-     * surfaces to store reference frames in non auto reference mode
-     * VA_INVALID_SURFACE can be used to denote an invalid reference frame. 
-     */
-    VASurfaceID ref_last_frame;
-    VASurfaceID ref_gf_frame;
-    VASurfaceID ref_arf_frame;
-
-    /* buffer to store coded data */
-    VABufferID coded_buf;
-
-    union {
-        struct {
-            /* force this frame to be a keyframe */
-            unsigned int force_kf                       : 1;
-            /* don't reference the last frame */
-            unsigned int no_ref_last                    : 1;
-            /* don't reference the golden frame */
-            unsigned int no_ref_gf                      : 1;
-            /* don't reference the alternate reference frame */
-            unsigned int no_ref_arf                     : 1;
-            unsigned int reserved                       : 28;
-        } bits;
-        unsigned int value;
-    } ref_flags;
-
-    union {
-        struct {
-            /* version */
-            unsigned int frame_type                     : 1;
-            unsigned int version                        : 3;
-            /* show_frame */
-            unsigned int show_frame                     : 1;
-            /* color_space */						   
-            unsigned int color_space                    : 1;
-            /*  0: bicubic, 1: bilinear, other: none */
-            unsigned int recon_filter_type              : 2;
-            /*  0: no loop fitler, 1: simple loop filter */
-            unsigned int loop_filter_type               : 2;
-            /* 0: disabled, 1: normal, 2: simple */
-            unsigned int auto_partitions                : 1;
-            /* same as log2_nbr_of_dct_partitions in frame header syntax */
-            unsigned int num_token_partitions           : 2;
-
-            /** 
-             * The following fields correspond to the same VP8 syntax elements 
-             * in the frame header.
-             */
-	    /**
-             * 0: clamping of reconstruction pixels is disabled,
-             * 1: clamping enabled.
-             */
-            unsigned int clamping_type                  : 1;
-            /* indicate segmentation is enabled for the current frame. */
-            unsigned int segmentation_enabled           : 1;
-            /**
-             * Determines if the MB segmentation map is updated in the current 
-             * frame.
-             */
-            unsigned int update_mb_segmentation_map     : 1;
-            /**
-             * Indicates if the segment feature data is updated in the current 
-             * frame.
-             */
-            unsigned int update_segment_feature_data    : 1;
-            /**
-             * indicates if the MB level loop filter adjustment is enabled for 
-             * the current frame (0 off, 1 on).  
-             */
-	    unsigned int loop_filter_adj_enable         : 1;
-            /**
-             * Determines whether updated token probabilities are used only for 
-             * this frame or until further update. 
-             * It may be used by application to enable error resilient mode. 
-             * In this mode probability updates are allowed only at Key Frames.
-             */
-            unsigned int refresh_entropy_probs          : 1;
-            /**
-             * Determines if the current decoded frame refreshes the golden frame.
-             */
-            unsigned int refresh_golden_frame           : 1;
-            /** 
-             * Determines if the current decoded frame refreshes the alternate 
-             * reference frame.
-             */
-            unsigned int refresh_alternate_frame        : 1;
-            /**
-             * Determines if the current decoded frame refreshes the last frame 
-             * reference buffer.
-             */
-            unsigned int refresh_last                   : 1;
-            /**
-             * Determines if the golden reference is replaced by another reference.
-             */
-            unsigned int copy_buffer_to_golden          : 2;
-            /**
-             * Determines if the alternate reference is replaced by another reference.
-             */
-            unsigned int copy_buffer_to_alternate       : 2;
-            /** 
-             * Controls the sign of motion vectors when the golden frame is referenced.  
-             */
-            unsigned int sign_bias_golden               : 1;
-            /**
-             * Controls the sign of motion vectors when the alternate frame is 
-             * referenced. 
-             */
-	    unsigned int sign_bias_alternate            : 1;
-            /**
-             * Enables or disables the skipping of macroblocks containing no 
-             * non-zero coefficients. 
-             */
-	    unsigned int mb_no_coeff_skip               : 1;
-            /** 
-             * Enforces unconditional per-MB loop filter delta update setting frame 
-             * header flags mode_ref_lf_delta_update, all mb_mode_delta_update_flag[4], 
-             * and all ref_frame_delta_update_flag[4] to 1. 
-	     * Since loop filter deltas are not automatically refreshed to default 
-             * values at key frames, dropped frame with delta update may prevent 
-             * correct decoding from the next key frame. 
-	     * Encoder application is advised to set this flag to 1 at key frames.
-	     */
-            unsigned int forced_lf_adjustment           : 1;
-            unsigned int reserved                       : 2;
-        } bits;
-        unsigned int value;
-    } pic_flags;
-
-    /**
-     * Contains a list of 4 loop filter level values (updated value if applicable)
-     * controlling the deblocking filter strength. Each entry represents a segment.
-     * When segmentation is disabled, use entry 0. 
-     * When loop_filter_level is 0, loop filter shall be disabled. 
-     */
-    char loop_filter_level[4];
-
-    /** 
-     * Contains a list of 4 delta values for reference frame based MB-level 
-     * loop filter adjustment.  
-     * If no update, then set to 0.
-     */
-    char ref_lf_delta[4];
-
-    /**
-     * Contains a list of 4 delta values for coding mode based MB-level loop
-     * filter adjustment.  
-     * If no update, then set to 0. 
-     */
-    char mode_lf_delta[4];
-	
-    /**
-     * Controls the deblocking filter sensitivity. 
-     * Corresponds to the same VP8 syntax element in frame header.
-     */
-    unsigned char sharpness_level;
-	
-    /** 
-     * Application supplied maximum clamp value for Qindex used in quantization.  
-     * Qindex will not be allowed to exceed this value.  
-     * It has a valid range [0..127] inclusive.  
-     */
-    unsigned char clamp_qindex_high;
-	
-    /**
-     * Application supplied minimum clamp value for Qindex used in quantization.  
-     * Qindex will not be allowed to be lower than this value.  
-     * It has a valid range [0..127] inclusive.  
-     * Condition clamp_qindex_low <= clamp_qindex_high must be guaranteed, 
-     * otherwise they are ignored. 
-     */
-    unsigned char clamp_qindex_low;
-	
-} VAEncPictureParameterBufferVP8;
-
-
-/**
- * \brief VP8 MB Segmentation ID Buffer
- *
- * application provides buffer containing the initial segmentation id for each 
- * MB, in raster scan order. Rate control may reassign it.
- * For an 640x480 video, the buffer has 1200 entries. 
- * the value of each entry should be in the range [0..3], inclusive.
- * If segmentation is not enabled, application does not need to provide it. 
- */
-typedef struct _VAEncMBMapBufferVP8
-{
-    /** 
-     * number of MBs in the frame.
-     * It is also the number of entries of mb_segment_id[];
-     */
-    unsigned int num_mbs;
-    /**
-     * per MB Segmentation ID Buffer
-     */
-    unsigned char *mb_segment_id;
-} VAEncMBMapBufferVP8;
-
-
-/**
- * \brief VP8 Quantization Matrix Buffer Structure
- *
- * Contains quantization index for yac(0-3) for each segment and quantization 
- * index deltas, ydc(0), y2dc(1), y2ac(2), uvdc(3), uvac(4) that are applied 
- * to all segments.  When segmentation is disabled, only quantization_index[0] 
- * will be used. This structure is sent once per frame.
- */
-typedef struct _VAQMatrixBufferVP8
-{
-    unsigned short quantization_index[4];
-    short quantization_index_delta[5];
-} VAQMatrixBufferVP8;
-
-
-
-/**@}*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* VA_ENC_VP8_H */
diff --git a/third_party/libva/va/va_enc_vp9.h b/third_party/libva/va/va_enc_vp9.h
deleted file mode 100644
index 64d3d52..0000000
--- a/third_party/libva/va/va_enc_vp9.h
+++ /dev/null
@@ -1,588 +0,0 @@
-/*
- * Copyright (c) 2007-2015 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * \file va_enc_vp9.h
- * \brief VP9 encoding API
- *
- * This file contains the \ref api_enc_vp9 "VP9 encoding API".
- *
- */
-
-#ifndef VA_ENC_VP9_H
-#define VA_ENC_VP9_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * \defgroup api_enc_vp9 VP9 encoding API
- *
- * @{
- */
-
-/**
- * \brief VP9 Encoding Status Data Buffer Structure
- *
- * This structure is used to convey status data from encoder to application.
- * Driver allocates VACodedBufferVP9Status as a private data buffer.
- * Driver encapsulates the status buffer with a VACodedBufferSegment,
- * and sets VACodedBufferSegment.status to be
- * VA_CODED_BUF_STATUS_CODEC_SPECIFIC. And driver associates status data segment
- * to the bit stream buffer segment by setting VACodedBufferSegment.next of
- * coded_buf (bit stream) to the private buffer segment of status data.
- * Application accesses it by calling VAMapBuffer() with VAEncCodedBufferType.
- */
-typedef struct _VACodedBufferVP9Status {
-  /** Final quantization index used (yac), determined by BRC.
-   *  Application is providing quantization index deltas
-   *  ydc(0), y2dc(1), y2ac(2), uvdc(3), uvac(4) that are applied to all
-   * segments and segmentation qi deltas, they will not be changed by BRC.
-   */
-  uint16_t base_qp_index;
-
-  /** Final loopfilter levels for the frame, if segmentation is disabled only
-   *  index 0 is used.
-   *  If loop_filter_level is 0, it indicates loop filter is disabled.
-   */
-  uint8_t loop_filter_level;
-
-  /**
-   * Long term reference frame indication from BRC.  BRC recommends the
-   * current frame that is being queried is a good candidate for a long
-   * term reference.
-   */
-  uint8_t long_term_indication;
-
-  /* suggested next frame width */
-  uint16_t next_frame_width;
-
-  /* suggested next frame height */
-  uint16_t next_frame_height;
-
-} VACodedBufferVP9Status;
-
-/**
- * \brief VP9 Encoding Sequence Parameter Buffer Structure
- *
- * This structure conveys sequence level parameters.
- *
- */
-typedef struct _VAEncSequenceParameterBufferVP9 {
-  /** \brief Frame size note:
-   *  Picture resolution may change frame by frame.
-   *  Application needs to allocate surfaces and frame buffers based on
-   *  max frame resolution in case resolution changes for later frames.
-   *  The source and recon surfaces allocated should be 64x64(SB) aligned
-   *  on both horizontal and vertical directions.
-   *  But buffers on the surfaces need to be aligned to CU boundaries.
-   */
-  /* maximum frame width in pixels for the whole sequence */
-  uint32_t max_frame_width;
-
-  /* maximum frame height in pixels for the whole sequence */
-  uint32_t max_frame_height;
-
-  /* auto keyframe placement, non-zero means enable auto keyframe placement */
-  uint32_t kf_auto;
-
-  /* keyframe minimum interval */
-  uint32_t kf_min_dist;
-
-  /* keyframe maximum interval */
-  uint32_t kf_max_dist;
-
-  /* RC related fields. RC modes are set with VAConfigAttribRateControl */
-  /* For VP9, CBR implies HRD conformance and VBR implies no HRD conformance */
-
-  /**
-   * Initial bitrate set for this sequence in CBR or VBR modes.
-   *
-   * This field represents the initial bitrate value for this
-   * sequence if CBR or VBR mode is used, i.e. if the encoder
-   * pipeline was created with a #VAConfigAttribRateControl
-   * attribute set to either \ref VA_RC_CBR or \ref VA_RC_VBR.
-   *
-   * The bitrate can be modified later on through
-   * #VAEncMiscParameterRateControl buffers.
-   */
-  uint32_t bits_per_second;
-
-  /* Period between key frames */
-  uint32_t intra_period;
-
-} VAEncSequenceParameterBufferVP9;
-
-/**
- * \brief VP9 Encoding Picture Parameter Buffer Structure
- *
- * This structure conveys picture level parameters.
- *
- */
-typedef struct _VAEncPictureParameterBufferVP9 {
-  /** VP9 encoder may support dynamic scaling function.
-   *  If enabled (enable_dynamic_scaling is set), application may request
-   *  GPU encodes picture with a different resolution from the raw source.
-   *  GPU should handle the scaling process of source and
-   *  all reference frames.
-   */
-  /* raw source frame width in pixels */
-  uint32_t frame_width_src;
-  /* raw source frame height in pixels */
-  uint32_t frame_height_src;
-
-  /* to be encoded frame width in pixels */
-  uint32_t frame_width_dst;
-  /* to be encoded frame height in pixels */
-  uint32_t frame_height_dst;
-
-  /* surface to store reconstructed frame, not used for enc only case */
-  VASurfaceID reconstructed_frame;
-
-  /** \brief reference frame buffers
-   *  Each entry of the array specifies the surface index of the picture
-   *  that is referred by current picture or will be referred by any future
-   *  picture. The valid entries take value from 0 to 127, inclusive.
-   *  Non-valid entries, those do not point to pictures which are referred
-   *  by current picture or future pictures, should take value 0xFF.
-   *  Other values are not allowed.
-   *
-   *  Application should update this array based on the refreshing
-   *  information expected.
-   */
-  VASurfaceID reference_frames[8];
-
-  /* buffer to store coded data */
-  VABufferID coded_buf;
-
-  union {
-    struct {
-      /* force this frame to be a keyframe */
-      uint32_t force_kf : 1;
-
-      /** \brief Indiates which frames to be used as reference.
-       *  (Ref_frame_ctrl & 0x01) ? 1: last frame as reference frame, 0: not.
-       *  (Ref_frame_ctrl & 0x02) ? 1: golden frame as reference frame, 0: not.
-       *  (Ref_frame_ctrl & 0x04) ? 1: alt frame as reference frame, 0: not.
-       *  L0 is for forward prediction.
-       *  L1 is for backward prediction.
-       */
-      uint32_t ref_frame_ctrl_l0 : 3;
-      uint32_t ref_frame_ctrl_l1 : 3;
-
-      /** \brief Last Reference Frame index
-       *  Specifies the index to RefFrameList[] which points to the LAST
-       *  reference frame. It corresponds to active_ref_idx[0] in VP9 code.
-       */
-      uint32_t ref_last_idx : 3;
-
-      /** \brief Specifies the Sign Bias of the LAST reference frame.
-       *  It corresponds to ref_frame_sign_bias[LAST_FRAME] in VP9 code.
-       */
-      uint32_t ref_last_sign_bias : 1;
-
-      /** \brief GOLDEN Reference Frame index
-       *  Specifies the index to RefFrameList[] which points to the Golden
-       *  reference frame. It corresponds to active_ref_idx[1] in VP9 code.
-       */
-      uint32_t ref_gf_idx : 3;
-
-      /** \brief Specifies the Sign Bias of the GOLDEN reference frame.
-       *  It corresponds to ref_frame_sign_bias[GOLDEN_FRAME] in VP9 code.
-       */
-      uint32_t ref_gf_sign_bias : 1;
-
-      /** \brief Alternate Reference Frame index
-       *  Specifies the index to RefFrameList[] which points to the Alternate
-       *  reference frame. It corresponds to active_ref_idx[2] in VP9 code.
-       */
-      uint32_t ref_arf_idx : 3;
-
-      /** \brief Specifies the Sign Bias of the ALTERNATE reference frame.
-       *  It corresponds to ref_frame_sign_bias[ALTREF_FRAME] in VP9 code.
-       */
-      uint32_t ref_arf_sign_bias : 1;
-
-      /* The temporal id the frame belongs to */
-      uint32_t temporal_id : 8;
-
-      uint32_t reserved : 5;
-    } bits;
-    uint32_t value;
-  } ref_flags;
-
-  union {
-    struct {
-      /**
-       * Indicates if the current frame is a key frame or not.
-       * Corresponds to the same VP9 syntax element in frame tag.
-       */
-      uint32_t frame_type : 1;
-
-      /** \brief show_frame
-       *  0: current frame is not for display
-       *  1: current frame is for display
-       */
-      uint32_t show_frame : 1;
-
-      /**
-       * The following fields correspond to the same VP9 syntax elements
-       * in the frame header.
-       */
-      uint32_t error_resilient_mode : 1;
-
-      /** \brief Indicate intra-only for inter pictures.
-       *  Must be 0 for key frames.
-       *  0: inter frame use both intra and inter blocks
-       *  1: inter frame use only intra blocks.
-       */
-      uint32_t intra_only : 1;
-
-      /** \brief Indicate high precision mode for Motion Vector prediction
-       *  0: normal mode
-       *  1: high precision mode
-       */
-      uint32_t allow_high_precision_mv : 1;
-
-      /** \brief Motion Compensation Filter type
-       *  0: eight-tap  (only this mode is supported now.)
-       *  1: eight-tap-smooth
-       *  2: eight-tap-sharp
-       *  3: bilinear
-       *  4: switchable
-       */
-      uint32_t mcomp_filter_type : 3;
-      uint32_t frame_parallel_decoding_mode : 1;
-      uint32_t reset_frame_context : 2;
-      uint32_t refresh_frame_context : 1;
-      uint32_t frame_context_idx : 2;
-      uint32_t segmentation_enabled : 1;
-
-      /* corresponds to variable temporal_update in VP9 code.
-       * Indicates whether Segment ID is from bitstream or from previous
-       * frame.
-       * 0: Segment ID from bitstream
-       * 1: Segment ID from previous frame
-       */
-      uint32_t segmentation_temporal_update : 1;
-
-      /* corresponds to variable update_mb_segmentation_map in VP9 code.
-       * Indicates how hardware determines segmentation ID
-       * 0: intra block - segment id is 0;
-       *    inter block - segment id from previous frame
-       * 1: intra block - segment id from bitstream (app or GPU decides)
-       *    inter block - depends on segmentation_temporal_update
-       */
-      uint32_t segmentation_update_map : 1;
-
-      /** \brief Specifies if the picture is coded in lossless mode.
-       *
-       *  lossless_mode = base_qindex == 0 && y_dc_delta_q == 0  \
-       *                  && uv_dc_delta_q == 0 && uv_ac_delta_q == 0;
-       *  Where base_qindex, y_dc_delta_q, uv_dc_delta_q and uv_ac_delta_q
-       *  are all variables in VP9 code.
-       *
-       *  When enabled, tx_mode needs to be set to 4x4 only and all
-       *  tu_size in CU record set to 4x4 for entire frame.
-       *  Software also has to program such that final_qindex=0 and
-       *  final_filter_level=0 following the Quant Scale and
-       *  Filter Level Table in Segmentation State section.
-       *  Hardware forces Hadamard Tx when this bit is set.
-       *  When lossless_mode is on, BRC has to be turned off.
-       *  0: normal mode
-       *  1: lossless mode
-       */
-      uint32_t lossless_mode : 1;
-
-      /** \brief MV prediction mode. Corresponds to VP9 variable with same name.
-       *  comp_prediction_mode = 0:		single prediction ony,
-       *  comp_prediction_mode = 1:		compound prediction,
-       *  comp_prediction_mode = 2:		hybrid prediction
-       *
-       *  Not mandatory. App may suggest the setting based on power or
-       *  performance. Kernal may use it as a guildline and decide the proper
-       *  setting on its own.
-       */
-      uint32_t comp_prediction_mode : 2;
-
-      /** \brief Indicate how segmentation is specified
-       *  0   application specifies segmentation partitioning and
-       *      relevant parameters.
-       *  1   GPU may decide on segmentation. If application already
-       *      provides segmentation information, GPU may choose to
-       *      honor it and further split into more levels if possible.
-       */
-      uint32_t auto_segmentation : 1;
-
-      /** \brief Indicate super frame syntax should be inserted
-       *  0   current frame is not encapsulated in super frame structure
-       *  1   current fame is to be encapsulated in super frame structure.
-       *      super frame index syntax will be inserted by encoder at
-       *      the end of current frame.
-       */
-      uint32_t super_frame_flag : 1;
-
-      uint32_t reserved : 10;
-    } bits;
-    uint32_t value;
-  } pic_flags;
-
-  /** \brief indicate which frames in DPB should be refreshed.
-   *  same syntax and semantic as in VP9 code.
-   */
-  uint8_t refresh_frame_flags;
-
-  /** \brief Base Q index in the VP9 term.
-   *  Added with per segment delta Q index to get Q index of Luma AC.
-   */
-  uint8_t luma_ac_qindex;
-
-  /**
-   *  Q index delta from base Q index in the VP9 term for Luma DC.
-   */
-  int8_t luma_dc_qindex_delta;
-
-  /**
-   *  Q index delta from base Q index in the VP9 term for Chroma AC.
-   */
-  int8_t chroma_ac_qindex_delta;
-
-  /**
-   *  Q index delta from base Q index in the VP9 term for Chroma DC.
-   */
-  int8_t chroma_dc_qindex_delta;
-
-  /** \brief filter level
-   *  Corresponds to the same VP9 syntax element in frame header.
-   */
-  uint8_t filter_level;
-
-  /**
-   * Controls the deblocking filter sensitivity.
-   * Corresponds to the same VP9 syntax element in frame header.
-   */
-  uint8_t sharpness_level;
-
-  /** \brief Loop filter level reference delta values.
-   *  Contains a list of 4 delta values for reference frame based block-level
-   *  loop filter adjustment.
-   *  If no update, set to 0.
-   *  value range [-63..63]
-   */
-  int8_t ref_lf_delta[4];
-
-  /** \brief Loop filter level mode delta values.
-   *  Contains a list of 4 delta values for coding mode based MB-level loop
-   *  filter adjustment.
-   *  If no update, set to 0.
-   *  value range [-63..63]
-   */
-  int8_t mode_lf_delta[2];
-
-  /**
-   *  Offset from starting position of output bitstream in bits where
-   *  ref_lf_delta[] should be inserted. This offset should cover any metadata
-   *  ahead of uncompressed header in inserted bit stream buffer (the offset
-   *  should be same as that for final output bitstream buffer).
-   *
-   *  In BRC mode, always insert ref_lf_delta[] (This implies uncompressed
-   *  header should have mode_ref_delta_enabled=1 and mode_ref_delta_update=1).
-   */
-  uint16_t bit_offset_ref_lf_delta;
-
-  /**
-   *  Offset from starting position of output bitstream in bits where
-   *  mode_lf_delta[] should be inserted.
-   *
-   *  In BRC mode, always insert mode_lf_delta[] (This implies uncompressed
-   *  header should have mode_ref_delta_enabled=1 and mode_ref_delta_update=1).
-   */
-  uint16_t bit_offset_mode_lf_delta;
-
-  /**
-   *  Offset from starting position of output bitstream in bits where (loop)
-   *  filter_level should be inserted.
-   */
-  uint16_t bit_offset_lf_level;
-
-  /**
-   *  Offset from starting position of output bitstream in bits where
-   *  Base Qindex should be inserted.
-   */
-  uint16_t bit_offset_qindex;
-
-  /**
-   *  Offset from starting position of output bitstream in bits where
-   *  First Partition Size should be inserted.
-   */
-  uint16_t bit_offset_first_partition_size;
-
-  /**
-   *  Offset from starting position of output bitstream in bits where
-   *  segmentation_enabled is located in bitstream. When auto_segmentation
-   *  is enabled, GPU uses this offset to locate and update the
-   *  segmentation related information.
-   */
-  uint16_t bit_offset_segmentation;
-
-  /** \brief length in bit of segmentation portion from the location
-   *  in bit stream where segmentation_enabled syntax is coded.
-   *  When auto_segmentation is enabled, GPU uses this bit size to locate
-   *  and update the information after segmentation.
-   */
-  uint16_t bit_size_segmentation;
-
-  /** \brief log2 of number of tile rows
-   *  Corresponds to the same VP9 syntax element in frame header.
-   *  value range [0..2]
-   */
-  uint8_t log2_tile_rows;
-
-  /** \brief log2 of number of tile columns
-   *  Corresponds to the same VP9 syntax element in frame header.
-   *  value range [0..5]
-   */
-  uint8_t log2_tile_columns;
-
-  /** \brief indicate frame-skip happens
-   *  Application may choose to drop/skip one or mulitple encoded frames or
-   *  to-be-encoded frame due to various reasons such as insufficient
-   *  bandwidth.
-   *  Application uses the following three flags to inform GPU about frame-skip.
-   *
-   *  value range of skip_frame_flag: [0..2]
-   *      0 - encode as normal, no skip;
-   *      1 - one or more frames were skipped by application prior to the
-   *          current frame. Encode the current frame as normal. The driver
-   *          will pass the number_skip_frames and skip_frames_size
-   *          to bit rate control for adjustment.
-   *      2 - the current frame is to be skipped. Do not encode it but encrypt
-   *          the packed header contents. This is for the secure encoding case
-   *          where application generates a frame of all skipped blocks.
-   *          The packed header will contain the skipped frame.
-   */
-  uint8_t skip_frame_flag;
-
-  /** \brief The number of frames skipped prior to the current frame.
-   *  It includes only the skipped frames that were not counted before,
-   *  and does not include the frame with skip_frame_flag == 2.
-   *  Valid when skip_frame_flag = 1.
-   */
-  uint8_t number_skip_frames;
-
-  /** \brief When skip_frame_flag = 1, the size of the skipped frames in bits.
-   *  It includes only the skipped frames that were not counted before,
-   *  and does not include the frame size with skip_frame_flag = 2.
-   *  When skip_frame_flag = 2, it is the size of the current skipped frame
-   *  that is to be encrypted.
-   */
-  uint32_t skip_frames_size;
-
-} VAEncPictureParameterBufferVP9;
-
-/**
- * \brief Per segment parameters
- */
-typedef struct _VAEncSegParamVP9 {
-  union {
-    struct {
-      /** \brief Indicates if per segment reference frame indicator is enabled.
-       *  Corresponding to variable feature_enabled when
-       *  j == SEG_LVL_REF_FRAME in function setup_segmentation() VP9 code.
-       */
-      uint8_t segment_reference_enabled : 1;
-
-      /** \brief Specifies per segment reference indication.
-       *  0: reserved
-       *  1: Last ref
-       *  2: golden
-       *  3: altref
-       *  Value can be derived from variable data when
-       *  j == SEG_LVL_REF_FRAME in function setup_segmentation() VP9 code.
-       *  value range: [0..3]
-       */
-      uint8_t segment_reference : 2;
-
-      /** \brief Indicates if per segment skip mode is enabled.
-       *  Corresponding to variable feature_enabled when
-       *  j == SEG_LVL_SKIP in function setup_segmentation() VP9 code.
-       */
-      uint8_t segment_reference_skipped : 1;
-
-      uint8_t reserved : 4;
-
-    } bits;
-    uint8_t value;
-  } seg_flags;
-
-  /** \brief Specifies per segment Loop Filter Delta.
-   *  Must be 0 when segmentation_enabled == 0.
-   *  value range: [-63..63]
-   */
-  int8_t segment_lf_level_delta;
-
-  /** \brief Specifies per segment QIndex Delta.
-   *  Must be 0 when segmentation_enabled == 0.
-   *  value range: [-255..255]
-   */
-  int16_t segment_qindex_delta;
-
-} VAEncSegParamVP9;
-
-/**
- *  Structure to convey all segment related information.
- *  If segmentation is disabled, this data structure is still required.
- *  In this case, only seg_data[0] contains valid data.
- *  This buffer is sent once per frame.
- *
- *  The buffer is created with VABufferType VAQMatrixBufferType.
- *
- */
-typedef struct _VAEncMiscParameterTypeVP9PerSegmantParam {
-  /**
-   *  Parameters for 8 segments.
-   */
-  VAEncSegParamVP9 seg_data[8];
-
-} VAEncMiscParameterTypeVP9PerSegmantParam;
-
-/**
- * \brief VP9 Block Segmentation ID Buffer
- *
- * The application provides a buffer of VAEncMacroblockMapBufferType containing
- * the initial segmentation id for each 8x8 block, one byte each, in raster scan
- * order. Rate control may reassign it.  For example, a 640x480 video, the
- * buffer has 4800 entries. The value of each entry should be in the range
- * [0..7], inclusive. If segmentation is not enabled, the application does not
- * need to provide it.
- */
-
-/**@}*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* VA_ENC_VP9_H */
diff --git a/third_party/libva/va/va_fool.h b/third_party/libva/va/va_fool.h
deleted file mode 100644
index 6f4f917..0000000
--- a/third_party/libva/va/va_fool.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Copyright (c) 2009 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-
-#ifndef VA_FOOL_H
-#define VA_FOOL_H
-
-#include <stdio.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-extern int fool_codec;
-extern int fool_postp;
-
-#define VA_FOOL_FLAG_DECODE  0x1
-#define VA_FOOL_FLAG_ENCODE  0x2
-#define VA_FOOL_FLAG_JPEG    0x4
-
-#define VA_FOOL_FUNC(fool_func,...)            \
-    if (fool_codec) {                          \
-        if (fool_func(__VA_ARGS__))            \
-            return VA_STATUS_SUCCESS;          \
-    }
-    
-void va_FoolInit(VADisplay dpy);
-int va_FoolEnd(VADisplay dpy);
-
-int va_FoolCreateConfig(
-        VADisplay dpy,
-        VAProfile profile, 
-        VAEntrypoint entrypoint, 
-        VAConfigAttrib *attrib_list,
-        int num_attribs,
-        VAConfigID *config_id /* out */
-);
-
-
-VAStatus va_FoolCreateBuffer(
-    VADisplay dpy,
-    VAContextID context,	/* in */
-    VABufferType type,		/* in */
-    unsigned int size,		/* in */
-    unsigned int num_elements,	/* in */
-    void *data,			/* in */
-    VABufferID *buf_id		/* out */
-);
-
-VAStatus va_FoolMapBuffer (
-    VADisplay dpy,
-    VABufferID buf_id,	/* in */
-    void **pbuf 	/* out */
-);
-
-VAStatus va_FoolBufferInfo (
-    VADisplay dpy,
-    VABufferID buf_id,  /* in */
-    VABufferType *type, /* out */
-    unsigned int *size,         /* out */
-    unsigned int *num_elements /* out */
-);
-    
-VAStatus va_FoolCheckContinuity(VADisplay dpy);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff --git a/third_party/libva/va/va_tpi.h b/third_party/libva/va/va_tpi.h
deleted file mode 100644
index d4a9d06..0000000
--- a/third_party/libva/va/va_tpi.h
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Copyright (c) 2007-2009 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#ifndef _VA_TPI_H_
-#define _VA_TPI_H_
-
-#include <va/va.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-typedef enum {
-    VAExternalMemoryNULL, /* it is not external buffer, but requires the implementation allocates
-                           * the surface with the input attribute
-                           */
-    VAExternalMemoryV4L2Buffer,
-    VAExternalMemoryCIFrame, /* the memory is from camera frames and buffers points the frame ID list */
-    VAExternalMemoryUserPointer, /* the memory is malloc-ed and buffers points to the buffers */
-    VAExternalMemoryKernelDRMBufffer, /* the memory is from kernel DRM buffers and buffers points the
-                                       * DRM buffer handle list
-                                       */
-    VAExternalMemoryAndroidGrallocBuffer, /* the memory is from Android Gralloc memory, and buffers points
-                                           * the gralloc native_handle_t list
-                                           */
-} VASurfaceMemoryType;
-
-typedef struct _VASurfaceAttributeTPI {
-    VASurfaceMemoryType type;
-    unsigned int width;
-    unsigned int height;
-    unsigned int size;
-    unsigned int pixel_format; /* buffer format */
-    unsigned int tiling; /* the memory is tiling or not */
-    unsigned int luma_stride; /* luma stride, could be width aligned with a special value */
-    unsigned int chroma_u_stride; /* chroma stride */
-    unsigned int chroma_v_stride;
-    unsigned int luma_offset; /* could be 0 */
-    unsigned int chroma_u_offset; /* U offset from the beginning of the memory */
-    unsigned int chroma_v_offset; /* V offset from the beginning of the memory */
-    unsigned int count; /* buffer count for surface creation */
-    unsigned int *buffers; /* buffer handles or user pointers */
-    unsigned int reserved[4]; /* used to pass additional information, like
-                               * Android native window pointer
-                               */
-} VASurfaceAttributeTPI;
-
-
-VAStatus vaPutSurfaceBuf (
-    VADisplay dpy,
-    VASurfaceID surface,
-    unsigned char* data,
-    int* data_len,
-    short srcx,
-    short srcy,
-    unsigned short srcw,
-    unsigned short srch,
-    short destx,
-    short desty,
-    unsigned short destw,
-    unsigned short desth,
-    VARectangle *cliprects, /* client supplied clip list */
-    unsigned int number_cliprects, /* number of clip rects in the clip list */
-    unsigned int flags /* de-interlacing flags */
-);
-
-
-VAStatus vaCreateSurfacesWithAttribute (
-    VADisplay dpy,
-    int width,
-    int height,
-    int format,
-    int num_surfaces,
-    VASurfaceID *surfaces,       /* out */
-    VASurfaceAttributeTPI *attribute_tpi
-);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif 
diff --git a/third_party/libva/va/va_trace.h b/third_party/libva/va/va_trace.h
deleted file mode 100644
index 04c7c1f..0000000
--- a/third_party/libva/va/va_trace.h
+++ /dev/null
@@ -1,244 +0,0 @@
-/*
- * Copyright (c) 2009 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef VA_TRACE_H
-#define VA_TRACE_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-extern int trace_flag;
-
-#define VA_TRACE_FLAG_LOG             0x1
-#define VA_TRACE_FLAG_BUFDATA         0x2
-#define VA_TRACE_FLAG_CODEDBUF        0x4
-#define VA_TRACE_FLAG_SURFACE_DECODE  0x8
-#define VA_TRACE_FLAG_SURFACE_ENCODE  0x10
-#define VA_TRACE_FLAG_SURFACE_JPEG    0x20
-#define VA_TRACE_FLAG_SURFACE         (VA_TRACE_FLAG_SURFACE_DECODE | \
-                                       VA_TRACE_FLAG_SURFACE_ENCODE | \
-                                       VA_TRACE_FLAG_SURFACE_JPEG)
-
-#define VA_TRACE_LOG(trace_func,...)            \
-    if (trace_flag & VA_TRACE_FLAG_LOG) {       \
-        trace_func(__VA_ARGS__);                \
-    }
-#define VA_TRACE_ALL(trace_func,...)            \
-    if (trace_flag) {                           \
-        trace_func(__VA_ARGS__);                \
-    }
-
-DLL_HIDDEN
-void va_TraceInit(VADisplay dpy);
-DLL_HIDDEN
-void va_TraceEnd(VADisplay dpy);
-
-DLL_HIDDEN
-void va_TraceInitialize (
-    VADisplay dpy,
-    int *major_version,	 /* out */
-    int *minor_version 	 /* out */
-);
-
-DLL_HIDDEN
-void va_TraceTerminate (
-    VADisplay dpy
-);
-
-DLL_HIDDEN
-void va_TraceCreateConfig(
-    VADisplay dpy,
-    VAProfile profile, 
-    VAEntrypoint entrypoint, 
-    VAConfigAttrib *attrib_list,
-    int num_attribs,
-    VAConfigID *config_id /* out */
-);
-
-DLL_HIDDEN
-void va_TraceDestroyConfig(VADisplay dpy, VAConfigID config_id);
-
-DLL_HIDDEN
-void va_TraceCreateSurfaces(
-    VADisplay dpy,
-    int width,
-    int height,
-    int format,
-    int num_surfaces,
-    VASurfaceID *surfaces,	/* out */
-    VASurfaceAttrib    *attrib_list,
-    unsigned int        num_attribs
-);
-
-DLL_HIDDEN
-void va_TraceDestroySurfaces(
-    VADisplay dpy,
-    VASurfaceID *surface_list,
-    int num_surfaces
-);
-
-DLL_HIDDEN
-void va_TraceCreateContext(
-    VADisplay dpy,
-    VAConfigID config_id,
-    int picture_width,
-    int picture_height,
-    int flag,
-    VASurfaceID *render_targets,
-    int num_render_targets,
-    VAContextID *context		/* out */
-);
-
-DLL_HIDDEN
-void va_TraceDestroyContext(VADisplay dpy, VAContextID context);
-
-DLL_HIDDEN
-void va_TraceCreateBuffer (
-    VADisplay dpy,
-    VAContextID context,	/* in */
-    VABufferType type,		/* in */
-    unsigned int size,		/* in */
-    unsigned int num_elements,	/* in */
-    void *data,			/* in */
-    VABufferID *buf_id		/* out */
-);
-
-DLL_HIDDEN
-void va_TraceDestroyBuffer (
-    VADisplay dpy,
-    VABufferID buf_id    /* in */
-);
-
-DLL_HIDDEN
-void va_TraceMapBuffer (
-    VADisplay dpy,
-    VABufferID buf_id,	/* in */
-    void **pbuf 	/* out */
-);
-
-
-DLL_HIDDEN
-void va_TraceBeginPicture(
-    VADisplay dpy,
-    VAContextID context,
-    VASurfaceID render_target
-);
-
-DLL_HIDDEN
-void va_TraceRenderPicture(
-    VADisplay dpy,
-    VAContextID context,
-    VABufferID *buffers,
-    int num_buffers
-);
-
-DLL_HIDDEN
-void va_TraceEndPicture(
-    VADisplay dpy,
-    VAContextID context,
-    int endpic_done
-);
-
-DLL_HIDDEN
-void va_TraceSyncSurface(
-    VADisplay dpy,
-    VASurfaceID render_target
-);
-
-DLL_HIDDEN
-void va_TraceQuerySurfaceAttributes(
-    VADisplay           dpy,
-    VAConfigID          config,
-    VASurfaceAttrib    *attrib_list,
-    unsigned int       *num_attribs
-);
-
-DLL_HIDDEN
-void va_TraceQuerySurfaceStatus(
-    VADisplay dpy,
-    VASurfaceID render_target,
-    VASurfaceStatus *status	/* out */
-);
-
-DLL_HIDDEN
-void va_TraceQuerySurfaceError(
-	VADisplay dpy,
-	VASurfaceID surface,
-	VAStatus error_status,
-	void **error_info /*out*/
-);
-
-
-DLL_HIDDEN
-void va_TraceMaxNumDisplayAttributes (
-    VADisplay dpy,
-    int number
-);
-
-DLL_HIDDEN
-void va_TraceQueryDisplayAttributes (
-    VADisplay dpy,
-    VADisplayAttribute *attr_list,	/* out */
-    int *num_attributes			/* out */
-);
-
-DLL_HIDDEN
-void va_TraceGetDisplayAttributes (
-    VADisplay dpy,
-    VADisplayAttribute *attr_list,
-    int num_attributes
-);
-
-DLL_HIDDEN
-void va_TraceSetDisplayAttributes (
-    VADisplay dpy,
-    VADisplayAttribute *attr_list,
-    int num_attributes
-);
-
-/* extern function called by display side */
-void va_TracePutSurface (
-    VADisplay dpy,
-    VASurfaceID surface,
-    void *draw, /* the target Drawable */
-    short srcx,
-    short srcy,
-    unsigned short srcw,
-    unsigned short srch,
-    short destx,
-    short desty,
-    unsigned short destw,
-    unsigned short desth,
-    VARectangle *cliprects, /* client supplied clip list */
-    unsigned int number_cliprects, /* number of clip rects in the clip list */
-    unsigned int flags /* de-interlacing flags */
-);
-
-#ifdef __cplusplus
-}
-#endif
-    
-
-#endif /* VA_TRACE_H */
diff --git a/third_party/libva/va/va_version.h b/third_party/libva/va/va_version.h
deleted file mode 100644
index 7cf8850..0000000
--- a/third_party/libva/va/va_version.h
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (C) 2009 Splitted-Desktop Systems. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef VA_VERSION_H
-#define VA_VERSION_H
-
-/**
- * VA_MAJOR_VERSION:
- *
- * The major version of VA-API (1, if %VA_VERSION is 1.2.3)
- */
-#define VA_MAJOR_VERSION    0
-
-/**
- * VA_MINOR_VERSION:
- *
- * The minor version of VA-API (2, if %VA_VERSION is 1.2.3)
- */
-#define VA_MINOR_VERSION 39
-
-/**
- * VA_MICRO_VERSION:
- *
- * The micro version of VA-API (3, if %VA_VERSION is 1.2.3)
- */
-#define VA_MICRO_VERSION 2
-
-/**
- * VA_VERSION:
- *
- * The full version of VA-API, like 1.2.3
- */
-#define VA_VERSION 0.39.2
-
-/**
- * VA_VERSION_S:
- *
- * The full version of VA-API, in string form (suited for string
- * concatenation)
- */
-#define VA_VERSION_S "0.39.2"
-
-/**
- * VA_VERSION_HEX:
- *
- * Numerically encoded version of VA-API, like 0x010203
- */
-#define VA_VERSION_HEX     ((VA_MAJOR_VERSION << 24) | \
-                            (VA_MINOR_VERSION << 16) | \
-                            (VA_MICRO_VERSION << 8))
-
-/**
- * VA_CHECK_VERSION:
- * @major: major version, like 1 in 1.2.3
- * @minor: minor version, like 2 in 1.2.3
- * @micro: micro version, like 3 in 1.2.3
- *
- * Evaluates to %TRUE if the version of VA-API is greater than
- * @major, @minor and @micro
- */
-#define VA_CHECK_VERSION(major,minor,micro) \
-        (VA_MAJOR_VERSION > (major) || \
-         (VA_MAJOR_VERSION == (major) && VA_MINOR_VERSION > (minor)) || \
-         (VA_MAJOR_VERSION == (major) && VA_MINOR_VERSION == (minor) && VA_MICRO_VERSION >= (micro)))
-
-#endif /* VA_VERSION_H */
diff --git a/third_party/libva/va/va_vpp.h b/third_party/libva/va/va_vpp.h
deleted file mode 100644
index 8ac0923..0000000
--- a/third_party/libva/va/va_vpp.h
+++ /dev/null
@@ -1,750 +0,0 @@
-/*
- * Copyright (c) 2007-2011 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * \file va_vpp.h
- * \brief The video processing API
- *
- * This file contains the \ref api_vpp "Video processing API".
- */
-
-#ifndef VA_VPP_H
-#define VA_VPP_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * \defgroup api_vpp Video processing API
- *
- * @{
- *
- * The video processing API uses the same paradigm as for decoding:
- * - Query for supported filters;
- * - Set up a video processing pipeline;
- * - Send video processing parameters through VA buffers.
- *
- * \section api_vpp_caps Query for supported filters
- *
- * Checking whether video processing is supported can be performed
- * with vaQueryConfigEntrypoints() and the profile argument set to
- * #VAProfileNone. If video processing is supported, then the list of
- * returned entry-points will include #VAEntrypointVideoProc.
- *
- * \code
- * VAEntrypoint *entrypoints;
- * int i, num_entrypoints, supportsVideoProcessing = 0;
- *
- * num_entrypoints = vaMaxNumEntrypoints();
- * entrypoints = malloc(num_entrypoints * sizeof(entrypoints[0]);
- * vaQueryConfigEntrypoints(va_dpy, VAProfileNone,
- *     entrypoints, &num_entrypoints);
- *
- * for (i = 0; !supportsVideoProcessing && i < num_entrypoints; i++) {
- *     if (entrypoints[i] == VAEntrypointVideoProc)
- *         supportsVideoProcessing = 1;
- * }
- * \endcode
- *
- * Then, the vaQueryVideoProcFilters() function is used to query the
- * list of video processing filters.
- *
- * \code
- * VAProcFilterType filters[VAProcFilterCount];
- * unsigned int num_filters = VAProcFilterCount;
- *
- * // num_filters shall be initialized to the length of the array
- * vaQueryVideoProcFilters(va_dpy, vpp_ctx, &filters, &num_filters);
- * \endcode
- *
- * Finally, individual filter capabilities can be checked with
- * vaQueryVideoProcFilterCaps().
- *
- * \code
- * VAProcFilterCap denoise_caps;
- * unsigned int num_denoise_caps = 1;
- * vaQueryVideoProcFilterCaps(va_dpy, vpp_ctx,
- *     VAProcFilterNoiseReduction,
- *     &denoise_caps, &num_denoise_caps
- * );
- *
- * VAProcFilterCapDeinterlacing deinterlacing_caps[VAProcDeinterlacingCount];
- * unsigned int num_deinterlacing_caps = VAProcDeinterlacingCount;
- * vaQueryVideoProcFilterCaps(va_dpy, vpp_ctx,
- *     VAProcFilterDeinterlacing,
- *     &deinterlacing_caps, &num_deinterlacing_caps
- * );
- * \endcode
- *
- * \section api_vpp_setup Set up a video processing pipeline
- *
- * A video processing pipeline buffer is created for each source
- * surface we want to process. However, buffers holding filter
- * parameters can be created once and for all. Rationale is to avoid
- * multiple creation/destruction chains of filter buffers and also
- * because filter parameters generally won't change frame after
- * frame. e.g. this makes it possible to implement a checkerboard of
- * videos where the same filters are applied to each video source.
- *
- * The general control flow is demonstrated by the following pseudo-code:
- * \code
- * // Create filters
- * VABufferID denoise_filter, deint_filter;
- * VABufferID filter_bufs[VAProcFilterCount];
- * unsigned int num_filter_bufs;
- *
- * for (i = 0; i < num_filters; i++) {
- *     switch (filters[i]) {
- *     case VAProcFilterNoiseReduction: {       // Noise reduction filter
- *         VAProcFilterParameterBuffer denoise;
- *         denoise.type  = VAProcFilterNoiseReduction;
- *         denoise.value = 0.5;
- *         vaCreateBuffer(va_dpy, vpp_ctx,
- *             VAProcFilterParameterBufferType, sizeof(denoise), 1,
- *             &denoise, &denoise_filter
- *         );
- *         filter_bufs[num_filter_bufs++] = denoise_filter;
- *         break;
- *     }
- *
- *     case VAProcFilterDeinterlacing:          // Motion-adaptive deinterlacing
- *         for (j = 0; j < num_deinterlacing_caps; j++) {
- *             VAProcFilterCapDeinterlacing * const cap = &deinterlacing_caps[j];
- *             if (cap->type != VAProcDeinterlacingMotionAdaptive)
- *                 continue;
- *
- *             VAProcFilterParameterBufferDeinterlacing deint;
- *             deint.type                   = VAProcFilterDeinterlacing;
- *             deint.algorithm              = VAProcDeinterlacingMotionAdaptive;
- *             vaCreateBuffer(va_dpy, vpp_ctx,
- *                 VAProcFilterParameterBufferType, sizeof(deint), 1,
- *                 &deint, &deint_filter
- *             );
- *             filter_bufs[num_filter_bufs++] = deint_filter;
- *         }
- *     }
- * }
- * \endcode
- *
- * Once the video processing pipeline is set up, the caller shall check the
- * implied capabilities and requirements with vaQueryVideoProcPipelineCaps().
- * This function can be used to validate the number of reference frames are
- * needed by the specified deinterlacing algorithm, the supported color
- * primaries, etc.
- * \code
- * // Create filters
- * VAProcPipelineCaps pipeline_caps;
- * VASurfaceID *forward_references;
- * unsigned int num_forward_references;
- * VASurfaceID *backward_references;
- * unsigned int num_backward_references;
- * VAProcColorStandardType in_color_standards[VAProcColorStandardCount];
- * VAProcColorStandardType out_color_standards[VAProcColorStandardCount];
- *
- * pipeline_caps.input_color_standards      = NULL;
- * pipeline_caps.num_input_color_standards  = ARRAY_ELEMS(in_color_standards);
- * pipeline_caps.output_color_standards     = NULL;
- * pipeline_caps.num_output_color_standards = ARRAY_ELEMS(out_color_standards);
- * vaQueryVideoProcPipelineCaps(va_dpy, vpp_ctx,
- *     filter_bufs, num_filter_bufs,
- *     &pipeline_caps
- * );
- *
- * num_forward_references  = pipeline_caps.num_forward_references;
- * forward_references      =
- *     malloc(num__forward_references * sizeof(VASurfaceID));
- * num_backward_references = pipeline_caps.num_backward_references;
- * backward_references     =
- *     malloc(num_backward_references * sizeof(VASurfaceID));
- * \endcode
- *
- * \section api_vpp_submit Send video processing parameters through VA buffers
- *
- * Video processing pipeline parameters are submitted for each source
- * surface to process. Video filter parameters can also change, per-surface.
- * e.g. the list of reference frames used for deinterlacing.
- *
- * \code
- * foreach (iteration) {
- *     vaBeginPicture(va_dpy, vpp_ctx, vpp_surface);
- *     foreach (surface) {
- *         VARectangle output_region;
- *         VABufferID pipeline_buf;
- *         VAProcPipelineParameterBuffer *pipeline_param;
- *
- *         vaCreateBuffer(va_dpy, vpp_ctx,
- *             VAProcPipelineParameterBuffer, sizeof(*pipeline_param), 1,
- *             NULL, &pipeline_buf
- *         );
- *
- *         // Setup output region for this surface
- *         // e.g. upper left corner for the first surface
- *         output_region.x     = BORDER;
- *         output_region.y     = BORDER;
- *         output_region.width =
- *             (vpp_surface_width - (Nx_surfaces + 1) * BORDER) / Nx_surfaces;
- *         output_region.height =
- *             (vpp_surface_height - (Ny_surfaces + 1) * BORDER) / Ny_surfaces;
- *
- *         vaMapBuffer(va_dpy, pipeline_buf, &pipeline_param);
- *         pipeline_param->surface              = surface;
- *         pipeline_param->surface_region       = NULL;
- *         pipeline_param->output_region        = &output_region;
- *         pipeline_param->output_background_color = 0;
- *         if (first surface to render)
- *             pipeline_param->output_background_color = 0xff000000; // black
- *         pipeline_param->filter_flags         = VA_FILTER_SCALING_HQ;
- *         pipeline_param->filters              = filter_bufs;
- *         pipeline_param->num_filters          = num_filter_bufs;
- *         vaUnmapBuffer(va_dpy, pipeline_buf);
- *
- *         // Update reference frames for deinterlacing, if necessary
- *         pipeline_param->forward_references      = forward_references;
- *         pipeline_param->num_forward_references  = num_forward_references_used;
- *         pipeline_param->backward_references     = backward_references;
- *         pipeline_param->num_backward_references = num_bacward_references_used;
- *
- *         // Apply filters
- *         vaRenderPicture(va_dpy, vpp_ctx, &pipeline_buf, 1);
- *     }
- *     vaEndPicture(va_dpy, vpp_ctx);
- * }
- * \endcode
- */
-
-/** \brief Video filter types. */
-typedef enum _VAProcFilterType {
-    VAProcFilterNone = 0,
-    /** \brief Noise reduction filter. */
-    VAProcFilterNoiseReduction,
-    /** \brief Deinterlacing filter. */
-    VAProcFilterDeinterlacing,
-    /** \brief Sharpening filter. */
-    VAProcFilterSharpening,
-    /** \brief Color balance parameters. */
-    VAProcFilterColorBalance,
-    /** \brief Skin Tone Enhancement. */
-    VAProcFilterSkinToneEnhancement,
-    VAProcFilterCount
-} VAProcFilterType;
-
-/** \brief Deinterlacing types. */
-typedef enum _VAProcDeinterlacingType {
-    VAProcDeinterlacingNone = 0,
-    /** \brief Bob deinterlacing algorithm. */
-    VAProcDeinterlacingBob,
-    /** \brief Weave deinterlacing algorithm. */
-    VAProcDeinterlacingWeave,
-    /** \brief Motion adaptive deinterlacing algorithm. */
-    VAProcDeinterlacingMotionAdaptive,
-    /** \brief Motion compensated deinterlacing algorithm. */
-    VAProcDeinterlacingMotionCompensated,
-    /** \brief Number of deinterlacing algorithms. */
-    VAProcDeinterlacingCount
-} VAProcDeinterlacingType;
-
-/** \brief Color balance types. */
-typedef enum _VAProcColorBalanceType {
-    VAProcColorBalanceNone = 0,
-    /** \brief Hue. */
-    VAProcColorBalanceHue,
-    /** \brief Saturation. */
-    VAProcColorBalanceSaturation,
-    /** \brief Brightness. */
-    VAProcColorBalanceBrightness,
-    /** \brief Contrast. */
-    VAProcColorBalanceContrast,
-    /** \brief Automatically adjusted saturation. */
-    VAProcColorBalanceAutoSaturation,
-    /** \brief Automatically adjusted brightness. */
-    VAProcColorBalanceAutoBrightness,
-    /** \brief Automatically adjusted contrast. */
-    VAProcColorBalanceAutoContrast,
-    /** \brief Number of color balance attributes. */
-    VAProcColorBalanceCount
-} VAProcColorBalanceType;
-
-/** \brief Color standard types. */
-typedef enum _VAProcColorStandardType {
-    VAProcColorStandardNone = 0,
-    /** \brief ITU-R BT.601. */
-    VAProcColorStandardBT601,
-    /** \brief ITU-R BT.709. */
-    VAProcColorStandardBT709,
-    /** \brief ITU-R BT.470-2 System M. */
-    VAProcColorStandardBT470M,
-    /** \brief ITU-R BT.470-2 System B, G. */
-    VAProcColorStandardBT470BG,
-    /** \brief SMPTE-170M. */
-    VAProcColorStandardSMPTE170M,
-    /** \brief SMPTE-240M. */
-    VAProcColorStandardSMPTE240M,
-    /** \brief Generic film. */
-    VAProcColorStandardGenericFilm,
-    /** \brief Number of color standards. */
-    VAProcColorStandardCount
-} VAProcColorStandardType;
-
-/** @name Video pipeline flags */
-/**@{*/
-/** \brief Specifies whether to apply subpictures when processing a surface. */
-#define VA_PROC_PIPELINE_SUBPICTURES    0x00000001
-/**
- * \brief Specifies whether to apply power or performance
- * optimizations to a pipeline.
- *
- * When processing several surfaces, it may be necessary to prioritize
- * more certain pipelines than others. This flag is only a hint to the
- * video processor so that it can omit certain filters to save power
- * for example. Typically, this flag could be used with video surfaces
- * decoded from a secondary bitstream.
- */
-#define VA_PROC_PIPELINE_FAST           0x00000002
-/**@}*/
-
-/** @name Video filter flags */
-/**@{*/
-/** \brief Specifies whether the filter shall be present in the pipeline. */
-#define VA_PROC_FILTER_MANDATORY        0x00000001
-/**@}*/
-
-/** @name Pipeline end flags */
-/**@{*/
-/** \brief Specifies the pipeline is the last. */
-#define VA_PIPELINE_FLAG_END		0x00000004
-/**@}*/
-
-/** \brief Video processing pipeline capabilities. */
-typedef struct _VAProcPipelineCaps {
-    /** \brief Pipeline flags. See VAProcPipelineParameterBuffer::pipeline_flags. */
-    unsigned int        pipeline_flags;
-    /** \brief Extra filter flags. See VAProcPipelineParameterBuffer::filter_flags. */
-    unsigned int        filter_flags;
-    /** \brief Number of forward reference frames that are needed. */
-    unsigned int        num_forward_references;
-    /** \brief Number of backward reference frames that are needed. */
-    unsigned int        num_backward_references;
-    /** \brief List of color standards supported on input. */
-    VAProcColorStandardType *input_color_standards;
-    /** \brief Number of elements in \ref input_color_standards array. */
-    unsigned int        num_input_color_standards;
-    /** \brief List of color standards supported on output. */
-    VAProcColorStandardType *output_color_standards;
-    /** \brief Number of elements in \ref output_color_standards array. */
-    unsigned int        num_output_color_standards;
-} VAProcPipelineCaps;
-
-/** \brief Specification of values supported by the filter. */
-typedef struct _VAProcFilterValueRange {
-    /** \brief Minimum value supported, inclusive. */
-    float               min_value;
-    /** \brief Maximum value supported, inclusive. */
-    float               max_value;
-    /** \brief Default value. */
-    float               default_value;
-    /** \brief Step value that alters the filter behaviour in a sensible way. */
-    float               step;
-} VAProcFilterValueRange;
-
-/**
- * \brief Video processing pipeline configuration.
- *
- * This buffer defines a video processing pipeline. As for any buffer
- * passed to \c vaRenderPicture(), this is a one-time usage model.
- * However, the actual filters to be applied are provided in the
- * \c filters field, so they can be re-used in other processing
- * pipelines.
- *
- * The target surface is specified by the \c render_target argument of
- * \c vaBeginPicture(). The general usage model is described as follows:
- * - \c vaBeginPicture(): specify the target surface that receives the
- *   processed output;
- * - \c vaRenderPicture(): specify a surface to be processed and composed
- *   into the \c render_target. Use as many \c vaRenderPicture() calls as
- *   necessary surfaces to compose ;
- * - \c vaEndPicture(): tell the driver to start processing the surfaces
- *   with the requested filters.
- *
- * If a filter (e.g. noise reduction) needs to be applied with different
- * values for multiple surfaces, the application needs to create as many
- * filter parameter buffers as necessary. i.e. the filter parameters shall
- * not change between two calls to \c vaRenderPicture().
- *
- * For composition usage models, the first surface to process will generally
- * use an opaque background color, i.e. \c output_background_color set with
- * the most significant byte set to \c 0xff. For instance, \c 0xff000000 for
- * a black background. Then, subsequent surfaces would use a transparent
- * background color.
- */
-typedef struct _VAProcPipelineParameterBuffer {
-    /**
-     * \brief Source surface ID.
-     *
-     * ID of the source surface to process. If subpictures are associated
-     * with the video surfaces then they shall be rendered to the target
-     * surface, if the #VA_PROC_PIPELINE_SUBPICTURES pipeline flag is set.
-     */
-    VASurfaceID         surface;
-    /**
-     * \brief Region within the source surface to be processed.
-     *
-     * Pointer to a #VARectangle defining the region within the source
-     * surface to be processed. If NULL, \c surface_region implies the
-     * whole surface.
-     */
-    const VARectangle  *surface_region;
-    /**
-     * \brief Requested input color primaries.
-     *
-     * Color primaries are implicitly converted throughout the processing
-     * pipeline. The video processor chooses the best moment to apply
-     * this conversion. The set of supported color primaries primaries
-     * for input shall be queried with vaQueryVideoProcPipelineCaps().
-     */
-    VAProcColorStandardType surface_color_standard;
-    /**
-     * \brief Region within the output surface.
-     *
-     * Pointer to a #VARectangle defining the region within the output
-     * surface that receives the processed pixels. If NULL, \c output_region
-     * implies the whole surface. 
-     *
-     * Note that any pixels residing outside the specified region will
-     * be filled in with the \ref output_background_color.
-     */
-    const VARectangle  *output_region;
-    /**
-     * \brief Background color.
-     *
-     * Background color used to fill in pixels that reside outside of the
-     * specified \ref output_region. The color is specified in ARGB format:
-     * [31:24] alpha, [23:16] red, [15:8] green, [7:0] blue.
-     *
-     * Unless the alpha value is zero or the \ref output_region represents
-     * the whole target surface size, implementations shall not render the
-     * source surface to the target surface directly. Rather, in order to
-     * maintain the exact semantics of \ref output_background_color, the
-     * driver shall use a temporary surface and fill it in with the
-     * appropriate background color. Next, the driver will blend this
-     * temporary surface into the target surface.
-     */
-    unsigned int        output_background_color;
-    /**
-     * \brief Requested output color primaries.
-     */
-    VAProcColorStandardType output_color_standard;
-    /**
-     * \brief Pipeline filters. See video pipeline flags.
-     *
-     * Flags to control the pipeline, like whether to apply subpictures
-     * or not, notify the driver that it can opt for power optimizations,
-     * should this be needed.
-     */
-    unsigned int        pipeline_flags;
-    /**
-     * \brief Extra filter flags. See vaPutSurface() flags.
-     *
-     * Filter flags are used as a fast path, wherever possible, to use
-     * vaPutSurface() flags instead of explicit filter parameter buffers.
-     *
-     * Allowed filter flags API-wise. Use vaQueryVideoProcPipelineCaps()
-     * to check for implementation details:
-     * - Bob-deinterlacing: \c VA_FRAME_PICTURE, \c VA_TOP_FIELD,
-     *   \c VA_BOTTOM_FIELD. Note that any deinterlacing filter
-     *   (#VAProcFilterDeinterlacing) will override those flags.
-     * - Color space conversion: \c VA_SRC_BT601, \c VA_SRC_BT709,
-     *   \c VA_SRC_SMPTE_240. 
-     * - Scaling: \c VA_FILTER_SCALING_DEFAULT, \c VA_FILTER_SCALING_FAST,
-     *   \c VA_FILTER_SCALING_HQ, \c VA_FILTER_SCALING_NL_ANAMORPHIC.
-     */
-    unsigned int        filter_flags;
-    /**
-     * \brief Array of filters to apply to the surface.
-     *
-     * The list of filters shall be ordered in the same way the driver expects
-     * them. i.e. as was returned from vaQueryVideoProcFilters().
-     * Otherwise, a #VA_STATUS_ERROR_INVALID_FILTER_CHAIN is returned
-     * from vaRenderPicture() with this buffer.
-     *
-     * #VA_STATUS_ERROR_UNSUPPORTED_FILTER is returned if the list
-     * contains an unsupported filter.
-     *
-     * Note: no filter buffer is destroyed after a call to vaRenderPicture(),
-     * only this pipeline buffer will be destroyed as per the core API
-     * specification. This allows for flexibility in re-using the filter for
-     * other surfaces to be processed.
-     */
-    VABufferID         *filters;
-    /** \brief Actual number of filters. */
-    unsigned int        num_filters;
-    /** \brief Array of forward reference frames. */
-    VASurfaceID        *forward_references;
-    /** \brief Number of forward reference frames that were supplied. */
-    unsigned int        num_forward_references;
-    /** \brief Array of backward reference frames. */
-    VASurfaceID        *backward_references;
-    /** \brief Number of backward reference frames that were supplied. */
-    unsigned int        num_backward_references;
-} VAProcPipelineParameterBuffer;
-
-/**
- * \brief Filter parameter buffer base.
- *
- * This is a helper structure used by driver implementations only.
- * Users are not supposed to allocate filter parameter buffers of this
- * type.
- */
-typedef struct _VAProcFilterParameterBufferBase {
-    /** \brief Filter type. */
-    VAProcFilterType    type;
-} VAProcFilterParameterBufferBase;
-
-/**
- * \brief Default filter parametrization.
- *
- * Unless there is a filter-specific parameter buffer,
- * #VAProcFilterParameterBuffer is the default type to use.
- */
-typedef struct _VAProcFilterParameterBuffer {
-    /** \brief Filter type. */
-    VAProcFilterType    type;
-    /** \brief Value. */
-    float               value;
-} VAProcFilterParameterBuffer;
-
-/** @name De-interlacing flags */
-/**@{*/
-/** 
- * \brief Bottom field first in the input frame. 
- * if this is not set then assumes top field first.
- */
-#define VA_DEINTERLACING_BOTTOM_FIELD_FIRST	0x0001
-/** 
- * \brief Bottom field used in deinterlacing. 
- * if this is not set then assumes top field is used.
- */
-#define VA_DEINTERLACING_BOTTOM_FIELD		0x0002
-/** 
- * \brief A single field is stored in the input frame. 
- * if this is not set then assumes the frame contains two interleaved fields.
- */
-#define VA_DEINTERLACING_ONE_FIELD		0x0004
-/**@}*/
-
-/** \brief Deinterlacing filter parametrization. */
-typedef struct _VAProcFilterParameterBufferDeinterlacing {
-    /** \brief Filter type. Shall be set to #VAProcFilterDeinterlacing. */
-    VAProcFilterType            type;
-    /** \brief Deinterlacing algorithm. */
-    VAProcDeinterlacingType     algorithm;
-    /** \brief Deinterlacing flags. */
-    unsigned int     		flags;
-} VAProcFilterParameterBufferDeinterlacing;
-
-/**
- * \brief Color balance filter parametrization.
- *
- * This buffer defines color balance attributes. A VA buffer can hold
- * several color balance attributes by creating a VA buffer of desired
- * number of elements. This can be achieved by the following pseudo-code:
- *
- * \code
- * enum { kHue, kSaturation, kBrightness, kContrast };
- *
- * // Initial color balance parameters
- * static const VAProcFilterParameterBufferColorBalance colorBalanceParams[4] =
- * {
- *     [kHue] =
- *         { VAProcFilterColorBalance, VAProcColorBalanceHue, 0.5 },
- *     [kSaturation] =
- *         { VAProcFilterColorBalance, VAProcColorBalanceSaturation, 0.5 },
- *     [kBrightness] =
- *         { VAProcFilterColorBalance, VAProcColorBalanceBrightness, 0.5 },
- *     [kSaturation] =
- *         { VAProcFilterColorBalance, VAProcColorBalanceSaturation, 0.5 }
- * };
- *
- * // Create buffer
- * VABufferID colorBalanceBuffer;
- * vaCreateBuffer(va_dpy, vpp_ctx,
- *     VAProcFilterParameterBufferType, sizeof(*pColorBalanceParam), 4,
- *     colorBalanceParams,
- *     &colorBalanceBuffer
- * );
- *
- * VAProcFilterParameterBufferColorBalance *pColorBalanceParam;
- * vaMapBuffer(va_dpy, colorBalanceBuffer, &pColorBalanceParam);
- * {
- *     // Change brightness only
- *     pColorBalanceBuffer[kBrightness].value = 0.75;
- * }
- * vaUnmapBuffer(va_dpy, colorBalanceBuffer);
- * \endcode
- */
-typedef struct _VAProcFilterParameterBufferColorBalance {
-    /** \brief Filter type. Shall be set to #VAProcFilterColorBalance. */
-    VAProcFilterType            type;
-    /** \brief Color balance attribute. */
-    VAProcColorBalanceType      attrib;
-    /**
-     * \brief Color balance value.
-     *
-     * Special case for automatically adjusted attributes. e.g. 
-     * #VAProcColorBalanceAutoSaturation,
-     * #VAProcColorBalanceAutoBrightness,
-     * #VAProcColorBalanceAutoContrast.
-     * - If \ref value is \c 1.0 +/- \c FLT_EPSILON, the attribute is
-     *   automatically adjusted and overrides any other attribute of
-     *   the same type that would have been set explicitly;
-     * - If \ref value is \c 0.0 +/- \c FLT_EPSILON, the attribute is
-     *   disabled and other attribute of the same type is used instead.
-     */
-    float                       value;
-} VAProcFilterParameterBufferColorBalance;
-
-/**
- * \brief Default filter cap specification (single range value).
- *
- * Unless there is a filter-specific cap structure, #VAProcFilterCap is the
- * default type to use for output caps from vaQueryVideoProcFilterCaps().
- */
-typedef struct _VAProcFilterCap {
-    /** \brief Range of supported values for the filter. */
-    VAProcFilterValueRange      range;
-} VAProcFilterCap;
-
-/** \brief Capabilities specification for the deinterlacing filter. */
-typedef struct _VAProcFilterCapDeinterlacing {
-    /** \brief Deinterlacing algorithm. */
-    VAProcDeinterlacingType     type;
-} VAProcFilterCapDeinterlacing;
-
-/** \brief Capabilities specification for the color balance filter. */
-typedef struct _VAProcFilterCapColorBalance {
-    /** \brief Color balance operation. */
-    VAProcColorBalanceType      type;
-    /** \brief Range of supported values for the specified operation. */
-    VAProcFilterValueRange      range;
-} VAProcFilterCapColorBalance;
-
-/**
- * \brief Queries video processing filters.
- *
- * This function returns the list of video processing filters supported
- * by the driver. The \c filters array is allocated by the user and
- * \c num_filters shall be initialized to the number of allocated
- * elements in that array. Upon successful return, the actual number
- * of filters will be overwritten into \c num_filters. Otherwise,
- * \c VA_STATUS_ERROR_MAX_NUM_EXCEEDED is returned and \c num_filters
- * is adjusted to the number of elements that would be returned if enough
- * space was available.
- *
- * The list of video processing filters supported by the driver shall
- * be ordered in the way they can be iteratively applied. This is needed
- * for both correctness, i.e. some filters would not mean anything if
- * applied at the beginning of the pipeline; but also for performance
- * since some filters can be applied in a single pass (e.g. noise
- * reduction + deinterlacing).
- *
- * @param[in] dpy               the VA display
- * @param[in] context           the video processing context
- * @param[out] filters          the output array of #VAProcFilterType elements
- * @param[in,out] num_filters the number of elements allocated on input,
- *      the number of elements actually filled in on output
- */
-VAStatus
-vaQueryVideoProcFilters(
-    VADisplay           dpy,
-    VAContextID         context,
-    VAProcFilterType   *filters,
-    unsigned int       *num_filters
-);
-
-/**
- * \brief Queries video filter capabilities.
- *
- * This function returns the list of capabilities supported by the driver
- * for a specific video filter. The \c filter_caps array is allocated by
- * the user and \c num_filter_caps shall be initialized to the number
- * of allocated elements in that array. Upon successful return, the
- * actual number of filters will be overwritten into \c num_filter_caps.
- * Otherwise, \c VA_STATUS_ERROR_MAX_NUM_EXCEEDED is returned and
- * \c num_filter_caps is adjusted to the number of elements that would be
- * returned if enough space was available.
- *
- * @param[in] dpy               the VA display
- * @param[in] context           the video processing context
- * @param[in] type              the video filter type
- * @param[out] filter_caps      the output array of #VAProcFilterCap elements
- * @param[in,out] num_filter_caps the number of elements allocated on input,
- *      the number of elements actually filled in output
- */
-VAStatus
-vaQueryVideoProcFilterCaps(
-    VADisplay           dpy,
-    VAContextID         context,
-    VAProcFilterType    type,
-    void               *filter_caps,
-    unsigned int       *num_filter_caps
-);
-
-/**
- * \brief Queries video processing pipeline capabilities.
- *
- * This function returns the video processing pipeline capabilities. The
- * \c filters array defines the video processing pipeline and is an array
- * of buffers holding filter parameters.
- *
- * Note: the #VAProcPipelineCaps structure contains user-provided arrays.
- * If non-NULL, the corresponding \c num_* fields shall be filled in on
- * input with the number of elements allocated. Upon successful return,
- * the actual number of elements will be overwritten into the \c num_*
- * fields. Otherwise, \c VA_STATUS_ERROR_MAX_NUM_EXCEEDED is returned
- * and \c num_* fields are adjusted to the number of elements that would
- * be returned if enough space was available.
- *
- * @param[in] dpy               the VA display
- * @param[in] context           the video processing context
- * @param[in] filters           the array of VA buffers defining the video
- *      processing pipeline
- * @param[in] num_filters       the number of elements in filters
- * @param[in,out] pipeline_caps the video processing pipeline capabilities
- */
-VAStatus
-vaQueryVideoProcPipelineCaps(
-    VADisplay           dpy,
-    VAContextID         context,
-    VABufferID         *filters,
-    unsigned int        num_filters,
-    VAProcPipelineCaps *pipeline_caps
-);
-
-/**@}*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* VA_VPP_H */
diff --git a/third_party/libva/va/va_x11.h b/third_party/libva/va/va_x11.h
deleted file mode 100644
index c9be38d..0000000
--- a/third_party/libva/va/va_x11.h
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#ifndef _VA_X11_H_
-#define _VA_X11_H_
-
-#include <va/va.h>
-#include <X11/Xlib.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
- * Returns a suitable VADisplay for VA API
- */
-VADisplay vaGetDisplay (
-    Display *dpy
-);
-
-/*
- * Output rendering
- * Following is the rendering interface for X windows, 
- * to get the decode output surface to a X drawable
- * It basically performs a de-interlacing (if needed), 
- * color space conversion and scaling to the destination
- * rectangle
- */
-VAStatus vaPutSurface (
-    VADisplay dpy,
-    VASurfaceID surface,	
-    Drawable draw, /* X Drawable */
-    short srcx,
-    short srcy,
-    unsigned short srcw,
-    unsigned short srch,
-    short destx,
-    short desty,
-    unsigned short destw,
-    unsigned short desth,
-    VARectangle *cliprects, /* client supplied destination clip list */
-    unsigned int number_cliprects, /* number of clip rects in the clip list */
-    unsigned int flags /* PutSurface flags */
-);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _VA_X11_H_ */
diff --git a/third_party/libva/va/wayland/va_backend_wayland.h b/third_party/libva/va/wayland/va_backend_wayland.h
deleted file mode 100644
index b33e3a1..0000000
--- a/third_party/libva/va/wayland/va_backend_wayland.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * va_backend_wayland.h - VA driver implementation hooks for Wayland
- *
- * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef VA_BACKEND_WAYLAND_H
-#define VA_BACKEND_WAYLAND_H
-
-#include <va/va.h>
-#include <wayland-client.h>
-
-/** \brief VA/Wayland API version. */
-#define VA_WAYLAND_API_VERSION  (0x574c4400) /* WLD0 */
-
-/* Forward declarations */
-struct VADriverContext;
-
-/** \brief VA/Wayland implementation hooks. */
-struct VADriverVTableWayland {
-    /**
-     * \brief Interface version.
-     *
-     * Implementations shall set this field to \ref VA_WAYLAND_API_VERSION.
-     */
-    unsigned int version;
-
-    /** \brief Hook to return Wayland buffer associated with the VA surface. */
-    VAStatus (*vaGetSurfaceBufferWl)(
-        struct VADriverContext *ctx,
-        VASurfaceID             surface,
-        unsigned int            flags,
-        struct wl_buffer      **out_buffer
-    );
-
-    /** \brief Hook to return Wayland buffer associated with the VA image. */
-    VAStatus (*vaGetImageBufferWl)(
-        struct VADriverContext *ctx,
-        VAImageID               image,
-        unsigned int            flags,
-        struct wl_buffer      **out_buffer
-    );
-};
-
-#endif /* VA_BACKEND_WAYLAND_H */
diff --git a/third_party/libva/va/wayland/va_wayland.h b/third_party/libva/va/wayland/va_wayland.h
deleted file mode 100644
index 46fbf2c..0000000
--- a/third_party/libva/va/wayland/va_wayland.h
+++ /dev/null
@@ -1,131 +0,0 @@
-/*
- * va_wayland.h - Wayland API
- *
- * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef VA_WAYLAND_H
-#define VA_WAYLAND_H
-
-#include <va/va.h>
-#include <wayland-client.h>
-
-/**
- * \file va_wayland.h
- * \brief The Wayland rendering API
- *
- * This file contains the \ref api_wayland "Wayland rendering API".
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * \defgroup api_wayland Wayland rendering API
- *
- * @{
- *
- * Theory of operations:
- * - Create a VA display for an active Wayland display ;
- * - Perform normal VA-API operations, e.g. decode to a VA surface ;
- * - Get wl_buffer associated to the VA surface ;
- * - Attach wl_buffer to wl_surface ;
- */
-
-/**
- * \brief Returns a VA display wrapping the specified Wayland display.
- *
- * This functions returns a (possibly cached) VA display from the
- * specified Wayland @display.
- *
- * @param[in]   display         the native Wayland display
- * @return the VA display
- */
-VADisplay
-vaGetDisplayWl(struct wl_display *display);
-
-/**
- * \brief Returns the Wayland buffer associated with a VA surface.
- *
- * This function returns a wl_buffer handle that can be used as an
- * argument to wl_surface_attach(). This buffer references the
- * underlying VA @surface. As such, the VA @surface and Wayland
- * @out_buffer have the same size and color format. Should specific
- * color conversion be needed, then VA/VPP API can fulfill this
- * purpose.
- *
- * The @flags describe the desired picture structure. This is useful
- * to expose a de-interlaced buffer. If the VA driver does not support
- * any of the supplied flags, then #VA_STATUS_ERROR_FLAG_NOT_SUPPORTED
- * is returned. The following flags are allowed: \c VA_FRAME_PICTURE,
- * \c VA_TOP_FIELD, \c VA_BOTTOM_FIELD.
- *
- * @param[in]   dpy         the VA display
- * @param[in]   surface     the VA surface
- * @param[in]   flags       the deinterlacing flags
- * @param[out]  out_buffer  a wl_buffer wrapping the VA @surface
- * @return VA_STATUS_SUCCESS if successful
- */
-VAStatus
-vaGetSurfaceBufferWl(
-    VADisplay           dpy,
-    VASurfaceID         surface,
-    unsigned int        flags,
-    struct wl_buffer  **out_buffer
-);
-
-/**
- * \brief Returns the Wayland buffer associated with a VA image.
- *
- * This function returns a wl_buffer handle that can be used as an
- * argument to wl_surface_attach(). This buffer references the
- * underlying VA @image. As such, the VA @image and Wayland
- * @out_buffer have the same size and color format. Should specific
- * color conversion be needed, then VA/VPP API can fulfill this
- * purpose.
- *
- * The @flags describe the desired picture structure. See
- * vaGetSurfaceBufferWl() description for more details.
- *
- * @param[in]   dpy         the VA display
- * @param[in]   image       the VA image
- * @param[in]   flags       the deinterlacing flags
- * @param[out]  out_buffer  a wl_buffer wrapping the VA @image
- * @return VA_STATUS_SUCCESS if successful
- */
-VAStatus
-vaGetImageBufferWl(
-    VADisplay           dpy,
-    VAImageID           image,
-    unsigned int        flags,
-    struct wl_buffer  **out_buffer
-);
-
-/**@}*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* VA_WAYLAND_H */
diff --git a/third_party/libva/va/wayland/va_wayland_drm.h b/third_party/libva/va/wayland/va_wayland_drm.h
deleted file mode 100644
index 6fb8f52..0000000
--- a/third_party/libva/va/wayland/va_wayland_drm.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * va_wayland_drm.h - Wayland/DRM helpers
- *
- * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef VA_WAYLAND_DRM_H
-#define VA_WAYLAND_DRM_H
-
-#include <stdbool.h>
-#include "va_wayland.h"
-#include "va_backend.h"
-#include "va_backend_wayland.h"
-
-/**
- * \brief Initializes Wayland/DRM layer.
- *
- * This is an internal function used to initialize the VA/DRM subsystem
- * if the application is running on a DRM-based server.
- *
- * @param[in]   pDisplayContext the VA display context
- * @return true if successful
- */
-DLL_HIDDEN
-bool
-va_wayland_drm_create(VADisplayContextP pDisplayContext);
-
-DLL_HIDDEN
-void
-va_wayland_drm_destroy(VADisplayContextP pDisplayContext);
-
-#endif /* VA_WAYLAND_DRM_H */
diff --git a/third_party/libva/va/wayland/va_wayland_emgd.h b/third_party/libva/va/wayland/va_wayland_emgd.h
deleted file mode 100644
index 053b6b4..0000000
--- a/third_party/libva/va/wayland/va_wayland_emgd.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * va_wayland_emgd.h - Wayland/EMGD helpers
- *
- * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef VA_WAYLAND_EMGD_H
-#define VA_WAYLAND_EMGD_H
-
-#include <stdbool.h>
-#include "va_wayland.h"
-#include "va_backend.h"
-#include "va_backend_wayland.h"
-
-/**
- * \brief Initializes Wayland/EMGD layer.
- *
- * This is an internal function used to initialize the VA/EMGD subsystem
- * if the application is running on an EMGD-based server.
- *
- * @param[in]   pDisplayContext the VA display context
- * @return true if successful
- */
-DLL_HIDDEN
-bool
-va_wayland_emgd_create(VADisplayContextP pDisplayContext);
-
-DLL_HIDDEN
-void
-va_wayland_emgd_destroy(VADisplayContextP pDisplayContext);
-
-#endif /* VA_WAYLAND_EMGD_H */
diff --git a/third_party/libva/va/wayland/va_wayland_private.h b/third_party/libva/va/wayland/va_wayland_private.h
deleted file mode 100644
index f09f4b7..0000000
--- a/third_party/libva/va/wayland/va_wayland_private.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * va_wayland_private.h - Wayland private API
- *
- * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef VA_WAYLAND_PRIVATE_H
-#define VA_WAYLAND_PRIVATE_H
-
-struct va_wayland_context;
-
-typedef bool (*VADisplayContextCreateFunc)(VADisplayContextP pDisplayContext);
-typedef void (*VADisplayContextDestroyFunc)(VADisplayContextP pDisplayContext);
-
-/* VA/Wayland base display context */
-typedef struct va_wayland_context {
-    VADisplayContextDestroyFunc destroy;
-} VADisplayContextWayland, *VADisplayContextWaylandP;
-
-DLL_HIDDEN
-void
-va_wayland_error(const char *format, ...);
-
-#endif /* VA_WAYLAND_PRIVATE_H */
diff --git a/third_party/libva/va/wayland/wayland-drm-client-protocol.h b/third_party/libva/va/wayland/wayland-drm-client-protocol.h
deleted file mode 100644
index 8f0e00e..0000000
--- a/third_party/libva/va/wayland/wayland-drm-client-protocol.h
+++ /dev/null
@@ -1,210 +0,0 @@
-/*
- * Copyright ¬© 2008-2011 Kristian H√∏gsberg
- * Copyright ¬© 2010-2011 Intel Corporation
- *
- * Permission to use, copy, modify, distribute, and sell this
- * software and its documentation for any purpose is hereby granted
- * without fee, provided that\n the above copyright notice appear in
- * all copies and that both that copyright notice and this permission
- * notice appear in supporting documentation, and that the name of
- * the copyright holders not be used in advertising or publicity
- * pertaining to distribution of the software without specific,
- * written prior permission.  The copyright holders make no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied
- * warranty.
- *
- * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
- * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
- * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
- * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
- * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
- * THIS SOFTWARE.
- */
-
-#ifndef DRM_CLIENT_PROTOCOL_H
-#define DRM_CLIENT_PROTOCOL_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <stddef.h>
-#include <stdint.h>
-#include "wayland-client.h"
-
-struct wl_client;
-struct wl_resource;
-
-struct wl_drm;
-
-extern const struct wl_interface wl_drm_interface;
-
-#ifndef WL_DRM_ERROR_ENUM
-#define WL_DRM_ERROR_ENUM
-enum wl_drm_error {
-  WL_DRM_ERROR_AUTHENTICATE_FAIL = 0,
-  WL_DRM_ERROR_INVALID_FORMAT = 1,
-  WL_DRM_ERROR_INVALID_NAME = 2,
-};
-#endif /* WL_DRM_ERROR_ENUM */
-
-#ifndef WL_DRM_FORMAT_ENUM
-#define WL_DRM_FORMAT_ENUM
-enum wl_drm_format {
-  WL_DRM_FORMAT_C8 = 0x20203843,
-  WL_DRM_FORMAT_RGB332 = 0x38424752,
-  WL_DRM_FORMAT_BGR233 = 0x38524742,
-  WL_DRM_FORMAT_XRGB4444 = 0x32315258,
-  WL_DRM_FORMAT_XBGR4444 = 0x32314258,
-  WL_DRM_FORMAT_RGBX4444 = 0x32315852,
-  WL_DRM_FORMAT_BGRX4444 = 0x32315842,
-  WL_DRM_FORMAT_ARGB4444 = 0x32315241,
-  WL_DRM_FORMAT_ABGR4444 = 0x32314241,
-  WL_DRM_FORMAT_RGBA4444 = 0x32314152,
-  WL_DRM_FORMAT_BGRA4444 = 0x32314142,
-  WL_DRM_FORMAT_XRGB1555 = 0x35315258,
-  WL_DRM_FORMAT_XBGR1555 = 0x35314258,
-  WL_DRM_FORMAT_RGBX5551 = 0x35315852,
-  WL_DRM_FORMAT_BGRX5551 = 0x35315842,
-  WL_DRM_FORMAT_ARGB1555 = 0x35315241,
-  WL_DRM_FORMAT_ABGR1555 = 0x35314241,
-  WL_DRM_FORMAT_RGBA5551 = 0x35314152,
-  WL_DRM_FORMAT_BGRA5551 = 0x35314142,
-  WL_DRM_FORMAT_RGB565 = 0x36314752,
-  WL_DRM_FORMAT_BGR565 = 0x36314742,
-  WL_DRM_FORMAT_RGB888 = 0x34324752,
-  WL_DRM_FORMAT_BGR888 = 0x34324742,
-  WL_DRM_FORMAT_XRGB8888 = 0x34325258,
-  WL_DRM_FORMAT_XBGR8888 = 0x34324258,
-  WL_DRM_FORMAT_RGBX8888 = 0x34325852,
-  WL_DRM_FORMAT_BGRX8888 = 0x34325842,
-  WL_DRM_FORMAT_ARGB8888 = 0x34325241,
-  WL_DRM_FORMAT_ABGR8888 = 0x34324241,
-  WL_DRM_FORMAT_RGBA8888 = 0x34324152,
-  WL_DRM_FORMAT_BGRA8888 = 0x34324142,
-  WL_DRM_FORMAT_XRGB2101010 = 0x30335258,
-  WL_DRM_FORMAT_XBGR2101010 = 0x30334258,
-  WL_DRM_FORMAT_RGBX1010102 = 0x30335852,
-  WL_DRM_FORMAT_BGRX1010102 = 0x30335842,
-  WL_DRM_FORMAT_ARGB2101010 = 0x30335241,
-  WL_DRM_FORMAT_ABGR2101010 = 0x30334241,
-  WL_DRM_FORMAT_RGBA1010102 = 0x30334152,
-  WL_DRM_FORMAT_BGRA1010102 = 0x30334142,
-  WL_DRM_FORMAT_YUYV = 0x56595559,
-  WL_DRM_FORMAT_YVYU = 0x55595659,
-  WL_DRM_FORMAT_UYVY = 0x59565955,
-  WL_DRM_FORMAT_VYUY = 0x59555956,
-  WL_DRM_FORMAT_AYUV = 0x56555941,
-  WL_DRM_FORMAT_NV12 = 0x3231564e,
-  WL_DRM_FORMAT_NV21 = 0x3132564e,
-  WL_DRM_FORMAT_NV16 = 0x3631564e,
-  WL_DRM_FORMAT_NV61 = 0x3136564e,
-  WL_DRM_FORMAT_YUV410 = 0x39565559,
-  WL_DRM_FORMAT_YVU410 = 0x39555659,
-  WL_DRM_FORMAT_YUV411 = 0x31315559,
-  WL_DRM_FORMAT_YVU411 = 0x31315659,
-  WL_DRM_FORMAT_YUV420 = 0x32315559,
-  WL_DRM_FORMAT_YVU420 = 0x32315659,
-  WL_DRM_FORMAT_YUV422 = 0x36315559,
-  WL_DRM_FORMAT_YVU422 = 0x36315659,
-  WL_DRM_FORMAT_YUV444 = 0x34325559,
-  WL_DRM_FORMAT_YVU444 = 0x34325659,
-};
-#endif /* WL_DRM_FORMAT_ENUM */
-
-struct wl_drm_listener {
-  /**
-   * device - device
-   * @name: name
-   */
-  void (*device)(void* data, struct wl_drm* wl_drm, const char* name);
-  /**
-   * format - format
-   * @format: format
-   */
-  void (*format)(void* data, struct wl_drm* wl_drm, uint32_t format);
-  /**
-   * authenticated - authenticated
-   */
-  void (*authenticated)(void* data, struct wl_drm* wl_drm);
-};
-
-static inline int wl_drm_add_listener(struct wl_drm* wl_drm,
-                                      const struct wl_drm_listener* listener,
-                                      void* data) {
-  return wl_proxy_add_listener((struct wl_proxy*)wl_drm,
-                               (void (**)(void))listener, data);
-}
-
-#define WL_DRM_AUTHENTICATE 0
-#define WL_DRM_CREATE_BUFFER 1
-#define WL_DRM_CREATE_PLANAR_BUFFER 2
-
-static inline void wl_drm_set_user_data(struct wl_drm* wl_drm,
-                                        void* user_data) {
-  wl_proxy_set_user_data((struct wl_proxy*)wl_drm, user_data);
-}
-
-static inline void* wl_drm_get_user_data(struct wl_drm* wl_drm) {
-  return wl_proxy_get_user_data((struct wl_proxy*)wl_drm);
-}
-
-static inline void wl_drm_destroy(struct wl_drm* wl_drm) {
-  wl_proxy_destroy((struct wl_proxy*)wl_drm);
-}
-
-static inline void wl_drm_authenticate(struct wl_drm* wl_drm, uint32_t id) {
-  wl_proxy_marshal((struct wl_proxy*)wl_drm, WL_DRM_AUTHENTICATE, id);
-}
-
-static inline struct wl_buffer* wl_drm_create_buffer(struct wl_drm* wl_drm,
-                                                     uint32_t name,
-                                                     int32_t width,
-                                                     int32_t height,
-                                                     uint32_t stride,
-                                                     uint32_t format) {
-  struct wl_proxy* id;
-
-  id = wl_proxy_create((struct wl_proxy*)wl_drm, &wl_buffer_interface);
-  if (!id)
-    return NULL;
-
-  wl_proxy_marshal((struct wl_proxy*)wl_drm, WL_DRM_CREATE_BUFFER, id, name,
-                   width, height, stride, format);
-
-  return (struct wl_buffer*)id;
-}
-
-static inline struct wl_buffer* wl_drm_create_planar_buffer(
-    struct wl_drm* wl_drm,
-    uint32_t name,
-    int32_t width,
-    int32_t height,
-    uint32_t format,
-    int32_t offset0,
-    int32_t stride0,
-    int32_t offset1,
-    int32_t stride1,
-    int32_t offset2,
-    int32_t stride2) {
-  struct wl_proxy* id;
-
-  id = wl_proxy_create((struct wl_proxy*)wl_drm, &wl_buffer_interface);
-  if (!id)
-    return NULL;
-
-  wl_proxy_marshal((struct wl_proxy*)wl_drm, WL_DRM_CREATE_PLANAR_BUFFER, id,
-                   name, width, height, format, offset0, stride0, offset1,
-                   stride1, offset2, stride2);
-
-  return (struct wl_buffer*)id;
-}
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff --git a/third_party/libva/va/x11/va_dri2.h b/third_party/libva/va/x11/va_dri2.h
deleted file mode 100644
index 165f3fe..0000000
--- a/third_party/libva/va/x11/va_dri2.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright ¬© 2007,2008 Red Hat, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Soft-
- * ware"), to deal in the Software without restriction, including without
- * limitation the rights to use, copy, modify, merge, publish, distribute,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, provided that the above copyright
- * notice(s) and this permission notice appear in all copies of the Soft-
- * ware and that both the above copyright notice(s) and this permission
- * notice appear in supporting documentation.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
- * ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY
- * RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN
- * THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSE-
- * QUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
- * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
- * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFOR-
- * MANCE OF THIS SOFTWARE.
- *
- * Except as contained in this notice, the name of a copyright holder shall
- * not be used in advertising or otherwise to promote the sale, use or
- * other dealings in this Software without prior written authorization of
- * the copyright holder.
- *
- * Authors:
- *   Kristian H√∏gsberg (krh@redhat.com)
- */
-
-#ifndef _VA_DRI2_H_
-#define _VA_DRI2_H_
-
-#include <X11/Xproto.h>
-#include <X11/extensions/Xfixes.h>
-#include <X11/Xfuncproto.h>
-#include <xf86drm.h>
-
-typedef struct {
-    unsigned int attachment;
-    unsigned int name;
-    unsigned int pitch;
-    unsigned int cpp;
-    unsigned int flags;
-} VA_DRI2Buffer;
-
-extern Bool
-VA_DRI2QueryExtension(Display *display, int *eventBase, int *errorBase);
-extern Bool
-VA_DRI2QueryVersion(Display *display, int *major, int *minor);
-extern Bool
-VA_DRI2Connect(Display *display, XID window,
-	    char **driverName, char **deviceName);
-extern Bool
-VA_DRI2Authenticate(Display *display, XID window, drm_magic_t magic);
-extern void
-VA_DRI2CreateDrawable(Display *display, XID drawable);
-extern void
-VA_DRI2DestroyDrawable(Display *display, XID handle);
-extern VA_DRI2Buffer *
-VA_DRI2GetBuffers(Display *dpy, XID drawable,
-	       int *width, int *height,
-	       unsigned int *attachments, int count,
-	       int *outCount);
-extern void
-VA_DRI2CopyRegion(Display *dpy, XID drawable, XserverRegion region,
-                  CARD32 dest, CARD32 src);
-extern void
-VA_DRI2SwapBuffers(Display *dpy, XID drawable, CARD64 target_msc, CARD64 divisor,
-                   CARD64 remainder, CARD64 *count);
-#endif
diff --git a/third_party/libva/va/x11/va_dri2str.h b/third_party/libva/va/x11/va_dri2str.h
deleted file mode 100644
index 1515eeb..0000000
--- a/third_party/libva/va/x11/va_dri2str.h
+++ /dev/null
@@ -1,227 +0,0 @@
-/*
- * Copyright ¬© 2008 Red Hat, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Soft-
- * ware"), to deal in the Software without restriction, including without
- * limitation the rights to use, copy, modify, merge, publish, distribute,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, provided that the above copyright
- * notice(s) and this permission notice appear in all copies of the Soft-
- * ware and that both the above copyright notice(s) and this permission
- * notice appear in supporting documentation.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
- * ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY
- * RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN
- * THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSE-
- * QUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
- * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
- * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFOR-
- * MANCE OF THIS SOFTWARE.
- *
- * Except as contained in this notice, the name of a copyright holder shall
- * not be used in advertising or otherwise to promote the sale, use or
- * other dealings in this Software without prior written authorization of
- * the copyright holder.
- *
- * Authors:
- *   Kristian H√∏gsberg (krh@redhat.com)
- */
-
-#ifndef _DRI2_PROTO_H_
-#define _DRI2_PROTO_H_
-
-#define DRI2_NAME			"DRI2"
-#define DRI2_MAJOR			1
-#define DRI2_MINOR			2
-
-#define DRI2NumberErrors		0
-#define DRI2NumberEvents		2
-#define DRI2NumberRequests		13
-
-#define X_DRI2QueryVersion		0
-#define X_DRI2Connect			1
-#define X_DRI2Authenticate		2
-#define X_DRI2CreateDrawable		3
-#define X_DRI2DestroyDrawable		4
-#define X_DRI2GetBuffers		5
-#define X_DRI2CopyRegion		6
-#define X_DRI2GetBuffersWithFormat	7
-#define X_DRI2SwapBuffers		8
-#define X_DRI2GetMSC			9
-#define X_DRI2WaitMSC			10
-#define X_DRI2WaitSBC			11
-#define X_DRI2SwapInterval		12
-
-typedef struct {
-    CARD32  attachment B32;
-    CARD32  name B32;
-    CARD32  pitch B32;
-    CARD32  cpp B32;
-    CARD32  flags B32;
-} xDRI2Buffer;
-
-typedef struct {
-    CARD8   reqType;
-    CARD8   dri2ReqType;
-    CARD16  length B16;
-    CARD32  majorVersion B32;
-    CARD32  minorVersion B32;
-} xDRI2QueryVersionReq;
-#define sz_xDRI2QueryVersionReq   12
-
-typedef struct {
-    BYTE    type;   /* X_Reply */
-    BYTE    pad1;
-    CARD16  sequenceNumber B16;
-    CARD32  length B32;
-    CARD32  majorVersion B32;
-    CARD32  minorVersion B32;
-    CARD32  pad2 B32;
-    CARD32  pad3 B32;
-    CARD32  pad4 B32;
-    CARD32  pad5 B32;
-} xDRI2QueryVersionReply;
-#define sz_xDRI2QueryVersionReply	32
-
-typedef struct {
-    CARD8   reqType;
-    CARD8   dri2ReqType;
-    CARD16  length B16;
-    CARD32  window B32;
-    CARD32  driverType B32;
-} xDRI2ConnectReq;
-#define sz_xDRI2ConnectReq	12
-
-typedef struct {
-    BYTE    type;   /* X_Reply */
-    BYTE    pad1;
-    CARD16  sequenceNumber B16;
-    CARD32  length B32;
-    CARD32  driverNameLength B32;
-    CARD32  deviceNameLength B32;
-    CARD32  pad2 B32;
-    CARD32  pad3 B32;
-    CARD32  pad4 B32;
-    CARD32  pad5 B32;
-} xDRI2ConnectReply;
-#define sz_xDRI2ConnectReply	32
-
-typedef struct {
-    CARD8   reqType;
-    CARD8   dri2ReqType;
-    CARD16  length B16;
-    CARD32  window B32;
-    CARD32  magic B32;
-} xDRI2AuthenticateReq;
-#define sz_xDRI2AuthenticateReq   12
-
-typedef struct {
-    BYTE    type;   /* X_Reply */
-    BYTE    pad1;
-    CARD16  sequenceNumber B16;
-    CARD32  length B32;
-    CARD32  authenticated B32;
-    CARD32  pad2 B32;
-    CARD32  pad3 B32;
-    CARD32  pad4 B32;
-    CARD32  pad5 B32;
-    CARD32  pad6 B32;
-} xDRI2AuthenticateReply;
-#define sz_xDRI2AuthenticateReply	32
-
-typedef struct {
-    CARD8   reqType;
-    CARD8   dri2ReqType;
-    CARD16  length B16;
-    CARD32  drawable B32;
-} xDRI2CreateDrawableReq;
-#define sz_xDRI2CreateDrawableReq   8
-
-typedef struct {
-    CARD8   reqType;
-    CARD8   dri2ReqType;
-    CARD16  length B16;
-    CARD32  drawable B32;
-} xDRI2DestroyDrawableReq;
-#define sz_xDRI2DestroyDrawableReq   8
-
-typedef struct {
-    CARD8   reqType;
-    CARD8   dri2ReqType;
-    CARD16  length B16;
-    CARD32  drawable B32;
-    CARD32  count B32;
-} xDRI2GetBuffersReq;
-#define sz_xDRI2GetBuffersReq   12
-
-typedef struct {
-    BYTE    type;   /* X_Reply */
-    BYTE    pad1;
-    CARD16  sequenceNumber B16;
-    CARD32  length B32;
-    CARD32  width B32;
-    CARD32  height B32;
-    CARD32  count B32;
-    CARD32  pad2 B32;
-    CARD32  pad3 B32;
-    CARD32  pad4 B32;
-} xDRI2GetBuffersReply;
-#define sz_xDRI2GetBuffersReply	32
-
-typedef struct {
-    CARD8   reqType;
-    CARD8   dri2ReqType;
-    CARD16  length B16;
-    CARD32  drawable B32;
-    CARD32  region B32;
-    CARD32  dest B32;
-    CARD32  src B32;
-} xDRI2CopyRegionReq;
-#define sz_xDRI2CopyRegionReq   20
-
-typedef struct {
-    BYTE    type;   /* X_Reply */
-    BYTE    pad1;
-    CARD16  sequenceNumber B16;
-    CARD32  length B32;
-    CARD32  pad2 B32;
-    CARD32  pad3 B32;
-    CARD32  pad4 B32;
-    CARD32  pad5 B32;
-    CARD32  pad6 B32;
-    CARD32  pad7 B32;
-} xDRI2CopyRegionReply;
-#define sz_xDRI2CopyRegionReply	32
-
-typedef struct {
-    CARD8   reqType;
-    CARD8   dri2ReqType;
-    CARD16  length B16;
-    CARD32  drawable B32;
-    CARD32  target_msc_hi B32;
-    CARD32  target_msc_lo B32;
-    CARD32  divisor_hi B32;
-    CARD32  divisor_lo B32;
-    CARD32  remainder_hi B32;
-    CARD32  remainder_lo B32;
-} xDRI2SwapBuffersReq;
-#define sz_xDRI2SwapBuffersReq  32
-
-typedef struct {
-    BYTE    type;   /* X_Reply */
-    BYTE    pad1;
-    CARD16  sequenceNumber B16;
-    CARD32  length B32;
-    CARD32  swap_hi B32;
-    CARD32  swap_lo B32;
-    CARD32  pad2 B32;
-    CARD32  pad3 B32;
-    CARD32  pad4 B32;
-    CARD32  pad5 B32;
-} xDRI2SwapBuffersReply;
-#define sz_xDRI2SwapBuffersReply 32
-
-#endif
diff --git a/third_party/libva/va/x11/va_dri2tokens.h b/third_party/libva/va/x11/va_dri2tokens.h
deleted file mode 100644
index 087159f..0000000
--- a/third_party/libva/va/x11/va_dri2tokens.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright ¬© 2008 Red Hat, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Soft-
- * ware"), to deal in the Software without restriction, including without
- * limitation the rights to use, copy, modify, merge, publish, distribute,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, provided that the above copyright
- * notice(s) and this permission notice appear in all copies of the Soft-
- * ware and that both the above copyright notice(s) and this permission
- * notice appear in supporting documentation.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
- * ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY
- * RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN
- * THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSE-
- * QUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
- * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
- * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFOR-
- * MANCE OF THIS SOFTWARE.
- *
- * Except as contained in this notice, the name of a copyright holder shall
- * not be used in advertising or otherwise to promote the sale, use or
- * other dealings in this Software without prior written authorization of
- * the copyright holder.
- *
- * Authors:
- *   Kristian H√∏gsberg (krh@redhat.com)
- */
-
-#ifndef _DRI2_TOKENS_H_
-#define _DRI2_TOKENS_H_
-
-#define DRI2BufferFrontLeft		0
-#define DRI2BufferBackLeft		1
-#define DRI2BufferFrontRight		2
-#define DRI2BufferBackRight		3
-#define DRI2BufferDepth			4
-#define DRI2BufferStencil		5
-#define DRI2BufferAccum			6
-#define DRI2BufferFakeFrontLeft		7
-#define DRI2BufferFakeFrontRight	8
-
-#define DRI2DriverDRI			0
-
-#endif
diff --git a/third_party/libva/va/x11/va_dricommon.h b/third_party/libva/va/x11/va_dricommon.h
deleted file mode 100644
index eb6ddad..0000000
--- a/third_party/libva/va/x11/va_dricommon.h
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#ifndef _VA_DRICOMMON_H_
-#define _VA_DRICOMMON_H_
-
-#ifndef ANDROID
-#include <X11/Xlib.h>
-#include <xf86drm.h>
-#include <drm.h>
-#include <drm_sarea.h>
-#endif
-
-#include <va/va_backend.h>
-#include <va/va_drmcommon.h>
-
-#ifdef ANDROID
-#define XID unsigned int
-#define Bool int
-#endif
-
-enum {
-    /* Compatibility. Do not use for newly-written code. */
-    VA_NONE     = VA_DRM_AUTH_NONE,
-    VA_DRI1     = VA_DRM_AUTH_DRI1,
-    VA_DRI2     = VA_DRM_AUTH_DRI2,
-    VA_DUMMY    = VA_DRM_AUTH_CUSTOM
-};
-
-union dri_buffer 
-{
-    struct {
-        unsigned int attachment;
-        unsigned int name;
-        unsigned int pitch;
-        unsigned int cpp;
-        unsigned int flags;
-    } dri2;
-};
-
-struct dri_drawable 
-{
-    XID x_drawable;
-    int is_window;
-    int x;
-    int y;
-    unsigned int width;
-    unsigned int height;
-    struct dri_drawable *next;
-};
-
-#define DRAWABLE_HASH_SZ 32
-struct dri_state 
-{
-    struct drm_state base;
-#ifndef ANDROID
-    struct dri_drawable *drawable_hash[DRAWABLE_HASH_SZ];
-
-    struct dri_drawable *(*createDrawable)(VADriverContextP ctx, XID x_drawable);
-    void (*destroyDrawable)(VADriverContextP ctx, struct dri_drawable *dri_drawable);
-    void (*swapBuffer)(VADriverContextP ctx, struct dri_drawable *dri_drawable);
-    union dri_buffer *(*getRenderingBuffer)(VADriverContextP ctx, struct dri_drawable *dri_drawable);
-    void (*close)(VADriverContextP ctx);
-#endif
-};
-
-Bool isDRI2Connected(VADriverContextP ctx, char **driver_name);
-void free_drawable(VADriverContextP ctx, struct dri_drawable* dri_drawable);
-void free_drawable_hashtable(VADriverContextP ctx);
-struct dri_drawable *dri_get_drawable(VADriverContextP ctx, XID drawable);
-void dri_swap_buffer(VADriverContextP ctx, struct dri_drawable *dri_drawable);
-union dri_buffer *dri_get_rendering_buffer(VADriverContextP ctx, struct dri_drawable *dri_drawable);
-
-#endif /* _VA_DRICOMMON_H_ */
diff --git a/third_party/libva/va/x11/va_fglrx.h b/third_party/libva/va/x11/va_fglrx.h
deleted file mode 100644
index 93ddd4b..0000000
--- a/third_party/libva/va/x11/va_fglrx.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2010 Splitted-Desktop Systems. All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef VA_FGLRX_H
-#define VA_FGLRX_H
-
-#include <X11/Xlib.h>
-
-DLL_HIDDEN
-Bool VA_FGLRXGetClientDriverName( Display *dpy, int screen,
-    int *ddxDriverMajorVersion, int *ddxDriverMinorVersion,
-    int *ddxDriverPatchVersion, char **clientDriverName );
-
-#endif /* VA_FGLRX_H */
diff --git a/third_party/libva/va/x11/va_nvctrl.h b/third_party/libva/va/x11/va_nvctrl.h
deleted file mode 100644
index 3617537..0000000
--- a/third_party/libva/va/x11/va_nvctrl.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (c) 2008 NVIDIA, Corporation
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-#ifndef VA_NVCTRLLIB_H
-#define VA_NVCTRLLIB_H
-
-#include <X11/Xlib.h>
-
-DLL_HIDDEN
-Bool VA_NVCTRLQueryDirectRenderingCapable( Display *dpy, int screen,
-    Bool *isCapable );
-
-DLL_HIDDEN
-Bool VA_NVCTRLGetClientDriverName( Display *dpy, int screen,
-    int *ddxDriverMajorVersion, int *ddxDriverMinorVersion,
-    int *ddxDriverPatchVersion, char **clientDriverName );
-
-#endif /* VA_NVCTRLLIB_H */
diff --git a/tools/licenses.py b/tools/licenses.py
index ee65177..9a202c7e 100755
--- a/tools/licenses.py
+++ b/tools/licenses.py
@@ -291,7 +291,6 @@
     os.path.join('third_party', 'libevent'),
     os.path.join('third_party', 'libjpeg'),
     os.path.join('third_party', 'libusb'),
-    os.path.join('third_party', 'libva'),
     os.path.join('third_party', 'libxslt'),
     os.path.join('third_party', 'lss'),
     os.path.join('third_party', 'lzma_sdk'),
